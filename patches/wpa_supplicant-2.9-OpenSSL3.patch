diff -aruN old/src/ap/drv_callbacks.c new/src/ap/drv_callbacks.c
--- old/src/ap/drv_callbacks.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/ap/drv_callbacks.c	2021-12-30 13:43:43.641474588 +0000
@@ -131,6 +131,21 @@
 			   "hostapd_notif_assoc: Skip event with no address");
 		return -1;
 	}
+
+   if (is_multicast_ether_addr(addr) ||
+       is_zero_ether_addr(addr) ||
+       os_memcmp(addr, hapd->own_addr, ETH_ALEN) == 0) {
+      /* 
+       * Do not process any frames with unexpected/invalid SA so that
+       * we do not add any state for unexpected STA addresses or end
+       * up sending out frames to unexpected destinations.
+       */
+      wpa_printf(MSG_DEBUG, "%s: Invalid SA=" MACSTR 
+            " in received indication - ignore this indication silently",
+            __func__, MAC2STR(addr));
+      return 0;
+   }
+
 	random_add_randomness(addr, ETH_ALEN);
 
 	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
diff -aruN old/src/ap/ieee802_11.c new/src/ap/ieee802_11.c
--- old/src/ap/ieee802_11.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/ap/ieee802_11.c	2021-12-30 13:43:43.641474588 +0000
@@ -4626,6 +4626,20 @@
 	fc = le_to_host16(mgmt->frame_control);
 	stype = WLAN_FC_GET_STYPE(fc);
 
+   if (is_multicast_ether_addr(mgmt->sa) ||
+       is_zero_ether_addr(mgmt->sa) ||
+       os_memcmp(mgmt->sa, hapd->own_addr, ETH_ALEN) == 0) {
+      /*
+       * Do not process any frames with unexpected/invalid SA so that
+       * we do not add any state for unexpected STA addresses or end
+       * up sending out frames to unexpected destinations.
+       */
+      wpa_printf(MSG_DEBUG, "MGMT: Invalid SA=" MACSTR
+                 " in received frame - ignore this frame silently",
+                 MAC2STR(mgmt->sa));
+      return 0;
+   }
+
 	if (stype == WLAN_FC_STYPE_BEACON) {
 		handle_beacon(hapd, mgmt, len, fi);
 		return 1;
diff -aruN old/src/crypto/crypto_openssl.c new/src/crypto/crypto_openssl.c
--- old/src/crypto/crypto_openssl.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/crypto/crypto_openssl.c	2021-12-30 13:43:56.704547038 +0000
@@ -195,8 +195,8 @@
 int des_encrypt(const u8 *clear, const u8 *key, u8 *cypher)
 {
 	u8 pkey[8], next, tmp;
-	int i;
-	DES_key_schedule ks;
+	int i, plen, ret = -1;
+	EVP_CIPHER_CTX *ctx;
 
 	/* Add parity bits to the key */
 	next = 0;
@@ -207,10 +207,19 @@
 	}
 	pkey[i] = next | 1;
 
-	DES_set_key((DES_cblock *) &pkey, &ks);
-	DES_ecb_encrypt((DES_cblock *) clear, (DES_cblock *) cypher, &ks,
-			DES_ENCRYPT);
-	return 0;
+	ctx = EVP_CIPHER_CTX_new();
+   if (ctx &&
+       EVP_EncryptInit_ex(ctx, EVP_des_ecb(), NULL, pkey, NULL) == 1 &&
+       EVP_CIPHER_CTX_set_padding(ctx, 0) == 1 &&
+       EVP_EncryptUpdate(ctx, cypher, &plen, clear, 8) == 1 &&
+       EVP_EncryptFinal_ex(ctx, &cypher[plen], &plen) == 1)
+      ret = 0;
+   else
+      wpa_printf(MSG_ERROR, "OpenSSL: DES encrypt failed");
+
+   if (ctx)
+      EVP_CIPHER_CTX_free(ctx);
+   return ret;
 }
 
 
@@ -228,8 +237,8 @@
 
 	ctx = EVP_CIPHER_CTX_new();
 	if (!ctx ||
-	    !EVP_CIPHER_CTX_set_padding(ctx, 0) ||
 	    !EVP_CipherInit_ex(ctx, EVP_rc4(), NULL, NULL, NULL, 1) ||
+       !EVP_CIPHER_CTX_set_padding(ctx, 0) ||
 	    !EVP_CIPHER_CTX_set_key_length(ctx, keylen) ||
 	    !EVP_CipherInit_ex(ctx, NULL, NULL, key, NULL, 1))
 		goto out;
@@ -688,9 +697,9 @@
 		return NULL;
 	}
 
-	if (!(ctx->enc = EVP_CIPHER_CTX_new()) ||
-	    !EVP_CIPHER_CTX_set_padding(ctx->enc, 0) ||
+	if (!(ctx->enc = EVP_CIPHER_CTX_new()) || 
 	    !EVP_EncryptInit_ex(ctx->enc, cipher, NULL, NULL, NULL) ||
+       !EVP_CIPHER_CTX_set_padding(ctx->enc, 0) ||
 	    !EVP_CIPHER_CTX_set_key_length(ctx->enc, key_len) ||
 	    !EVP_EncryptInit_ex(ctx->enc, NULL, NULL, key, iv)) {
 		if (ctx->enc)
@@ -700,8 +709,8 @@
 	}
 
 	if (!(ctx->dec = EVP_CIPHER_CTX_new()) ||
-	    !EVP_CIPHER_CTX_set_padding(ctx->dec, 0) ||
 	    !EVP_DecryptInit_ex(ctx->dec, cipher, NULL, NULL, NULL) ||
+       !EVP_CIPHER_CTX_set_padding(ctx->dec, 0) ||
 	    !EVP_CIPHER_CTX_set_key_length(ctx->dec, key_len) ||
 	    !EVP_DecryptInit_ex(ctx->dec, NULL, NULL, key, iv)) {
 		EVP_CIPHER_CTX_free(ctx->enc);
diff -aruN old/src/crypto/tls_openssl.c new/src/crypto/tls_openssl.c
--- old/src/crypto/tls_openssl.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/crypto/tls_openssl.c	2021-12-30 13:43:56.704547038 +0000
@@ -1044,6 +1044,8 @@
 	SSL_CTX_set_options(ssl, SSL_OP_NO_SSLv2);
 	SSL_CTX_set_options(ssl, SSL_OP_NO_SSLv3);
 
+   SSL_CTX_set_mode(ssl, SSL_MODE_AUTO_RETRY);
+
 #ifdef SSL_MODE_NO_AUTO_CHAIN
 	/* Number of deployed use cases assume the default OpenSSL behavior of
 	 * auto chaining the local certificate is in use. BoringSSL removed this
@@ -2951,16 +2953,12 @@
 
 		/* Explicit request to enable TLS versions even if needing to
 		 * override systemwide policies. */
-		if (flags & TLS_CONN_ENABLE_TLSv1_0) {
+		if (flags & TLS_CONN_ENABLE_TLSv1_0) 
 			version = TLS1_VERSION;
-		} else if (flags & TLS_CONN_ENABLE_TLSv1_1) {
-			if (!(flags & TLS_CONN_DISABLE_TLSv1_0))
-				version = TLS1_1_VERSION;
-		} else if (flags & TLS_CONN_ENABLE_TLSv1_2) {
-			if (!(flags & (TLS_CONN_DISABLE_TLSv1_0 |
-				       TLS_CONN_DISABLE_TLSv1_1)))
-				version = TLS1_2_VERSION;
-		}
+		else if (flags & TLS_CONN_ENABLE_TLSv1_1)
+         version = TLS1_1_VERSION;
+      else if (flags & TLS_CONN_ENABLE_TLSv1_2)
+         version = TLS1_2_VERSION;
 		if (!version) {
 			wpa_printf(MSG_DEBUG,
 				   "OpenSSL: Invalid TLS version configuration");
@@ -2974,6 +2972,18 @@
 		}
 	}
 #endif /* >= 1.1.0 */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \
+   !defined(LIBRESSL_VERSION_NUMBER) && \
+   !defined (OPENSSL_IS_BORINGSSL)
+   if ((flags & (TLS_CONN_ENABLE_TLSv1_0 | TLS_CONN_ENABLE_TLSv1_1)) &&
+         SSL_get_security_level(ssl) >= 2) {
+      /*
+       * Need to drop to security level 1 to allow TLS versions older
+       * than 1.2 to be used when explicitly enabled in configuration.
+       */
+      SSL_set_security_level(conn->ssl, 1);
+   }
+#endif
 
 #ifdef CONFIG_SUITEB
 #ifdef OPENSSL_IS_BORINGSSL
@@ -4431,10 +4441,18 @@
 		return NULL;
 	res = SSL_read(conn->ssl, wpabuf_mhead(buf), wpabuf_size(buf));
 	if (res < 0) {
-		tls_show_errors(MSG_INFO, __func__,
-				"Decryption failed - SSL_read");
-		wpabuf_free(buf);
-		return NULL;
+		int err = SSL_get_error(conn->ssl, res);
+
+      if (err == SSL_ERROR_WANT_READ) {
+         wpa_printf(MSG_DEBUG,
+                    "SSL: SSL_connect - want more data");
+         res = 0;
+      } else {
+         tls_show_errors(MSG_INFO, __func__,
+                         "Decryption failed - SSL_read");
+         wpabuf_free(buf);
+         return NULL;
+      }
 	}
 	wpabuf_put(buf, res);
 
diff -aruN old/src/eap_peer/eap_peap.c new/src/eap_peer/eap_peap.c
--- old/src/eap_peer/eap_peap.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/eap_peer/eap_peap.c	2021-12-30 13:43:56.707880305 +0000
@@ -787,6 +787,10 @@
 	res = eap_peer_tls_decrypt(sm, &data->ssl, in_data, &in_decrypted);
 	if (res)
 		return res;
+   if (wpabuf_len(in_decrypted) == 0) {
+      wpabuf_free(in_decrypted);
+      return 1;
+   }
 
 continue_req:
 	wpa_hexdump_buf(MSG_DEBUG, "EAP-PEAP: Decrypted Phase 2 EAP",
diff -aruN old/src/eap_peer/eap_ttls.c new/src/eap_peer/eap_ttls.c
--- old/src/eap_peer/eap_ttls.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/eap_peer/eap_ttls.c	2021-12-30 13:43:56.707880305 +0000
@@ -1424,6 +1424,7 @@
 
 	if ((in_data == NULL || wpabuf_len(in_data) == 0) &&
 	    data->phase2_start) {
+start:
 		return eap_ttls_phase2_start(sm, data, ret, identifier,
 					     out_data);
 	}
@@ -1438,6 +1439,10 @@
 	retval = eap_peer_tls_decrypt(sm, &data->ssl, in_data, &in_decrypted);
 	if (retval)
 		goto done;
+   if (wpabuf_len(in_decrypted) == 0) {
+      wpabuf_free(in_decrypted);
+      goto start;
+   }
 
 continue_req:
 	data->phase2_start = 0;
diff -aruN old/src/p2p/p2p.c new/src/p2p/p2p.c
--- old/src/p2p/p2p.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/p2p/p2p.c	2021-12-30 13:43:43.644807855 +0000
@@ -453,6 +453,8 @@
 	dev->info.config_methods = cli->config_methods;
 	os_memcpy(dev->info.pri_dev_type, cli->pri_dev_type, 8);
 	dev->info.wps_sec_dev_type_list_len = 8 * cli->num_sec_dev_types;
+   if (dev->info.wps_sec_dev_type_list_len > WPS_SEC_DEV_TYPE_MAX_LEN)
+       dev->info.wps_sec_dev_type_list_len = WPS_SEC_DEV_TYPE_MAX_LEN;
 	os_memcpy(dev->info.wps_sec_dev_type_list, cli->sec_dev_types,
 		  dev->info.wps_sec_dev_type_list_len);
 }
diff -aruN old/src/p2p/p2p_pd.c new/src/p2p/p2p_pd.c
--- old/src/p2p/p2p_pd.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/p2p/p2p_pd.c	2021-12-30 13:43:43.644807855 +0000
@@ -595,14 +595,12 @@
 			goto out;
 		}
 
+      dev = p2p_get_device(p2p, sa);
 		if (!dev) {
-			dev = p2p_get_device(p2p, sa);
-			if (!dev) {
-				p2p_dbg(p2p,
-					"Provision Discovery device not found "
-					MACSTR, MAC2STR(sa));
-				goto out;
-			}
+			p2p_dbg(p2p,
+                 "Provision Discovery device not found " 
+                 MACSTR, MAC2STR(sa));
+         goto out;
 		}
 	} else if (msg.wfd_subelems) {
 		wpabuf_free(dev->info.wfd_subelems);
diff -aruN old/src/tls/pkcs1.c new/src/tls/pkcs1.c
--- old/src/tls/pkcs1.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/tls/pkcs1.c	2021-12-30 13:43:43.644807855 +0000
@@ -241,6 +241,9 @@
 		return -1;
 	}
 
+   wpa_hexdump(MSG_MSGDUMP, "PCKS #1: DigestInfo",
+               hdr.payload, hdr.length);
+
 	pos = hdr.payload;
 	end = pos + hdr.length;
 
@@ -261,6 +264,8 @@
 		os_free(decrypted);
 		return -1;
 	}
+   wpa_hexdump(MSG_MSGDUMP, "PKCS #1: DigestAlgorithmIdentifier",
+               hdr.payload, hdr.length);
 	da_end = hdr.payload + hdr.length;
 
 	if (asn1_get_oid(hdr.payload, hdr.length, &oid, &next)) {
@@ -269,6 +274,23 @@
 		os_free(decrypted);
 		return -1;
 	}
+   wpa_hexdump(MSG_MSGDUMP, "PKCS #1: Digest algorithm parameters",
+               next, da_end - next);
+
+   /*
+    * RFC 5754: The correct encoding for the SHA2 algorithms would be to
+    * omit the parameters, but there are implementations that encode these
+    * as a NULL element. Allow these two cases and reject everything else.
+    */
+   if (da_end > next &&
+       (asn1_get_next(next, da_end - next, &hdr) < 0 ||
+        !asn1_is_null(&hdr) ||
+        hdr.payload + hdr.length != da_end)) {
+         wpa_printf(MSG_DEBUG,
+                    "PKCS #1: Unexpected digest algorithm parameters");
+         os_free(decrypted);
+         return -1;
+   }
 
 	if (!asn1_oid_equal(&oid, hash_alg)) {
 		char txt[100], txt2[100];
diff -aruN old/src/tls/x509v3.c new/src/tls/x509v3.c
--- old/src/tls/x509v3.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/tls/x509v3.c	2021-12-30 13:43:43.644807855 +0000
@@ -1834,6 +1834,7 @@
 		os_free(data);
 		return -1;
 	}
+   wpa_hexdump(MSG_MSGDUMP, "X509: DigestInfo", hdr.payload, hdr.length);
 
 	pos = hdr.payload;
 	end = pos + hdr.length;
@@ -1855,6 +1856,8 @@
 		os_free(data);
 		return -1;
 	}
+   wpa_hexdump(MSG_MSGDUMP, "X509: DigestAlgorithmIdentifier",
+               hdr.payload, hdr.length);
 	da_end = hdr.payload + hdr.length;
 
 	if (asn1_get_oid(hdr.payload, hdr.length, &oid, &next)) {
@@ -1863,6 +1866,24 @@
 		return -1;
 	}
 
+   wpa_hexdump(MSG_MSGDUMP, "X509: Digest algorithm parameters",
+               next, da_end - next);
+
+   /*
+    * RFC 5754: The correct encoding for the SHA2 algorithms would be to
+    * omit the parameters, but there are implementations that encode these
+    * as a NULL element. Allow these two cases and reject everything else.
+    */
+   if (da_end > next &&
+       (asn1_get_next(next, da_end - next, &hdr) < 0 ||
+        !asn1_is_null(&hdr) ||
+        hdr.payload + hdr.length != da_end)) {
+      wpa_printf(MSG_DEBUG,
+                 "X509: Unexpected digest algorithm parameters");
+      os_free(data);
+      return -1;
+   }
+
 	if (x509_sha1_oid(&oid)) {
 		if (signature->oid.oid[6] != 5 /* sha-1WithRSAEncryption */) {
 			wpa_printf(MSG_DEBUG, "X509: digestAlgorithm SHA1 "
diff -aruN old/src/wps/wps_er.c new/src/wps/wps_er.c
--- old/src/wps/wps_er.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/wps/wps_er.c	2021-12-30 13:43:43.644807855 +0000
@@ -1298,7 +1298,7 @@
 			   "with %s", filter);
 	}
 	if (get_netif_info(er->ifname, &er->ip_addr, &er->ip_addr_text,
-			   er->mac_addr)) {
+			   NULL, er->mac_addr)) {
 		wpa_printf(MSG_INFO, "WPS UPnP: Could not get IP/MAC address "
 			   "for %s. Does it have IP address?", er->ifname);
 		wps_er_deinit(er, NULL, NULL);
diff -aruN old/src/wps/wps_upnp.c new/src/wps/wps_upnp.c
--- old/src/wps/wps_upnp.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/wps/wps_upnp.c	2021-12-30 13:43:43.644807855 +0000
@@ -302,6 +302,12 @@
 	}
 }
 
+static int local_network_addr(struct upnp_wps_device_sm *sm,
+                              struct sockaddr_in *addr)
+{
+   return (addr->sin_addr.s_addr & sm->netmask.s_addr) ==
+          (sm->ip_addr & sm->netmask.s_addr);
+}
 
 /* subscr_addr_add_url -- add address(es) for one url to subscription */
 static void subscr_addr_add_url(struct subscription *s, const char *url,
@@ -320,9 +326,16 @@
 	int rerr;
 	size_t host_len, path_len;
 
-	/* url MUST begin with http: */
-	if (url_len < 7 || os_strncasecmp(url, "http://", 7))
+	/* 
+    * URL MUST begin with a HTTP scheme. In addition, limit the length of
+    * the URL to 700 characters which is around the limit that was 
+    * implicitly enforced for more than 10 years due to a bug in
+    * generating the event messages.
+    */
+   if (url_len < 7 || os_strncasecmp(url, "http://", 7) || url_len > 700) {
+      wpa_printf(MSG_DEBUG, "WPS UPnP: Reject an unacceptable URL");
 		goto fail;
+   }
 	url += 7;
 	url_len -= 7;
 
@@ -381,6 +394,7 @@
 
 	for (rp = result; rp; rp = rp->ai_next) {
 		struct subscr_addr *a;
+      struct sockaddr_in *addr = (struct sockaddr_in *) rp->ai_addr;`
 
 		/* Limit no. of address to avoid denial of service attack */
 		if (dl_list_len(&s->addr_list) >= MAX_ADDR_PER_SUBSCRIPTION) {
@@ -389,6 +403,13 @@
 			break;
 		}
 
+      if (!local_network_addr(s->sm, addr)) {
+         wpa_printf(MSG_INFO,
+                    "WPS UPnP: Ignore a delivery URL that points to another network %s",
+                    inet_ntoa(addr->sin_addr));
+         continue;
+      }
+
 		a = os_zalloc(sizeof(*a) + alloc_len);
 		if (a == NULL)
 			break;
@@ -889,11 +910,12 @@
  * @net_if: Selected network interface name
  * @ip_addr: Buffer for returning IP address in network byte order
  * @ip_addr_text: Buffer for returning a pointer to allocated IP address text
+ * @netmask: Buffer for returning netmask or %NULL if not needed
  * @mac: Buffer for returning MAC address
  * Returns: 0 on success, -1 on failure
  */
 int get_netif_info(const char *net_if, unsigned *ip_addr, char **ip_addr_text,
-		   u8 mac[ETH_ALEN])
+		   struct in_addr *netmask, u8 mac[ETH_ALEN])
 {
 	struct ifreq req;
 	int sock = -1;
@@ -919,6 +941,19 @@
 	in_addr.s_addr = *ip_addr;
 	os_snprintf(*ip_addr_text, 16, "%s", inet_ntoa(in_addr));
 
+   if (netmask) {
+      os_memset(&req, 0, sizeof(req));
+      os_strlcpy(req.ifr_name, net_if, sizeof(req.ifr_name));
+      if (ioctl(sock, SIOCGIFNETMASK, &req) < 0) {
+         wpa_printf(MSG_ERROR,
+               "WPS UPnP: SIOCGIFNETMASK failed: %d (%s)",
+               errno, strerror(errno));
+         goto fail;
+      }
+      addr = (struct sockaddr_in *) &req.ifr_netmask;
+      netmask->s_addr = addr->sin_addr.s_addr;
+   }
+
 #ifdef __linux__
 	os_strlcpy(req.ifr_name, net_if, sizeof(req.ifr_name));
 	if (ioctl(sock, SIOCGIFHWADDR, &req) < 0) {
@@ -1025,11 +1060,15 @@
 
 	/* Determine which IP and mac address we're using */
 	if (get_netif_info(net_if, &sm->ip_addr, &sm->ip_addr_text,
-			   sm->mac_addr)) {
+			   &sm->netmask, sm->mac_addr)) {
 		wpa_printf(MSG_INFO, "WPS UPnP: Could not get IP/MAC address "
 			   "for %s. Does it have IP address?", net_if);
 		goto fail;
 	}
+   wpa_printf(MSG_DEBUG, "WPS UPnP: Local IP address %s netmask %s hwaddr "
+              MACSTR,
+              sm->ip_addr_text, inet_ntoa(sm->netmask),
+              MAC2STR(sm->mac_addr));
 
 	/* Listen for incoming TCP connections so that others
 	 * can fetch our "xml files" from us.
diff -aruN old/src/wps/wps_upnp_event.c new/src/wps/wps_upnp_event.c
--- old/src/wps/wps_upnp_event.c	2019-08-07 14:25:25.000000000 +0100
+++ new/src/wps/wps_upnp_event.c	2021-12-30 13:43:43.644807855 +0000
@@ -147,7 +147,8 @@
 	struct wpabuf *buf;
 	char *b;
 
-	buf = wpabuf_alloc(1000 + wpabuf_len(e->data));
+	buf = wpabuf_alloc(1000 + os_strlen(e->addr->path) + 
+                      wpabuf_len(e->data));
 	if (buf == NULL)
 		return NULL;
 	wpabuf_printf(buf, "NOTIFY %s HTTP/1.1\r\n", e->addr->path);
@@ -293,7 +294,7 @@
 
 	buf = event_build_message(e);
 	if (buf == NULL) {
-		event_retry(e, 0);
+		event_addr_failure(e);
 		return -1;
 	}
 
@@ -301,7 +302,7 @@
 					 event_http_cb, e);
 	if (e->http_event == NULL) {
 		wpabuf_free(buf);
-		event_retry(e, 0);
+		event_addr_failure(e);
 		return -1;
 	}
 
diff -aruN old/src/wps/wps_upnp_i.h new/src/wps/wps_upnp_i.h
--- old/src/wps/wps_upnp_i.h	2019-08-07 14:25:25.000000000 +0100
+++ new/src/wps/wps_upnp_i.h	2021-12-30 13:43:43.644807855 +0000
@@ -128,6 +128,7 @@
 	u8 mac_addr[ETH_ALEN]; /* mac addr of network i.f. we use */
 	char *ip_addr_text; /* IP address of network i.f. we use */
 	unsigned ip_addr; /* IP address of network i.f. we use (host order) */
+   struct in_addr netmask;
 	int multicast_sd; /* send multicast messages over this socket */
 	int ssdp_sd; /* receive discovery UPD packets on socket */
 	int ssdp_sd_registered; /* nonzero if we must unregister */
@@ -158,7 +159,7 @@
 					const u8 uuid[UUID_LEN]);
 void subscr_addr_delete(struct subscr_addr *a);
 int get_netif_info(const char *net_if, unsigned *ip_addr, char **ip_addr_text,
-		   u8 mac[ETH_ALEN]);
+		   struct in_addr *netmask, u8 mac[ETH_ALEN]);
 
 /* wps_upnp_ssdp.c */
 void msearchreply_state_machine_stop(struct advertisement_state_machine *a);
diff -aruN old/wpa_supplicant/ctrl_iface.h new/wpa_supplicant/ctrl_iface.h
--- old/wpa_supplicant/ctrl_iface.h	2019-08-07 14:25:25.000000000 +0100
+++ new/wpa_supplicant/ctrl_iface.h	2021-12-30 13:43:43.644807855 +0000
@@ -66,14 +66,17 @@
 
 /**
  * wpa_supplicant_ctrl_iface_deinit - Deinitialize control interface
+ * @wpa_s: Pointer to wpa_supplicant data
  * @priv: Pointer to private data from wpa_supplicant_ctrl_iface_init()
  *
  * Deinitialize the control interface that was initialized with
- * wpa_supplicant_ctrl_iface_init().
+ * wpa_supplicant_ctrl_iface_init() and any data related to the wpa_s instance.
+ * @priv may be %NULL if the control interface has not yet been initialized.
  *
  * Required to be implemented in each control interface backend.
  */
-void wpa_supplicant_ctrl_iface_deinit(struct ctrl_iface_priv *priv);
+void wpa_supplicant_ctrl_iface_deinit(struct wpa_supplicant *wpa_s,
+                                      struct ctrl_iface_priv *priv);
 
 /**
  * wpa_supplicant_ctrl_iface_wait - Wait for ctrl_iface monitor
@@ -124,7 +127,8 @@
 }
 
 static inline void
-wpa_supplicant_ctrl_iface_deinit(struct ctrl_iface_priv *priv)
+wpa_supplicant_ctrl_iface_deinit(struct wpa_supplicant *wpa_s,
+                                 struct ctrl_iface_priv *priv)
 {
 }
 
diff -aruN old/wpa_supplicant/ctrl_iface_named_pipe.c new/wpa_supplicant/ctrl_iface_named_pipe.c
--- old/wpa_supplicant/ctrl_iface_named_pipe.c	2019-08-07 14:25:25.000000000 +0100
+++ new/wpa_supplicant/ctrl_iface_named_pipe.c	2021-12-30 13:43:43.648141121 +0000
@@ -462,8 +462,11 @@
 }
 
 
-void wpa_supplicant_ctrl_iface_deinit(struct ctrl_iface_priv *priv)
+void wpa_supplicant_ctrl_iface_deinit(struct wpa_supplicant *wpa_s,
+                                      struct ctrl_iface_priv *priv)
 {
+   if (!priv)
+      return;
 	while (priv->ctrl_dst)
 		ctrl_close_pipe(priv->ctrl_dst);
 	if (priv->sec_attr_set)
diff -aruN old/wpa_supplicant/ctrl_iface_udp.c new/wpa_supplicant/ctrl_iface_udp.c
--- old/wpa_supplicant/ctrl_iface_udp.c	2019-08-07 14:25:25.000000000 +0100
+++ new/wpa_supplicant/ctrl_iface_udp.c	2021-12-30 13:43:43.648141121 +0000
@@ -473,8 +473,12 @@
 }
 
 
-void wpa_supplicant_ctrl_iface_deinit(struct ctrl_iface_priv *priv)
+void wpa_supplicant_ctrl_iface_deinit(struct wpa_supplicant *wpa_s,
+                                      struct ctrl_iface_priv *priv)
 {
+   if (!priv)
+      return;
+
 	if (priv->sock > -1) {
 		eloop_unregister_read_sock(priv->sock);
 		if (priv->ctrl_dst) {
diff -aruN old/wpa_supplicant/ctrl_iface_unix.c new/wpa_supplicant/ctrl_iface_unix.c
--- old/wpa_supplicant/ctrl_iface_unix.c	2019-08-07 14:25:25.000000000 +0100
+++ new/wpa_supplicant/ctrl_iface_unix.c	2021-12-30 13:43:43.648141121 +0000
@@ -789,13 +789,53 @@
 	return priv->sock;
 }
 
+static void
+wpas_global_ctrl_iface_flush_queued_msg(struct wpa_global *global,
+                                        struct wpa_supplicant *wpa_s)
+{
+   struct ctrl_iface_global_priv *gpriv;
+   struct ctrl_iface_msg *msg, *prev_msg;
+   unsigned int count = 0;
+
+   if (!global || !global->ctrl_iface)
+      return;
+
+   gpriv = global->ctrl_iface;
+   dl_list_for_each_safe(msg, prev_msg, &gpriv->msg_queue,
+                         struct ctrl_iface_msg, list) {
+      if (msg->wpa_s == wpa_s) {
+         count++;
+         dl_list_del(&msg->list);
+         os_free(msg);
+      }
+   }
+
+   if (count) {
+      wpa_printf(MSG_DEBUG,
+                 "CTRL: Dropped %u pending message(s) for interface that is being removed",
+                 count);
+   }
+}
 
-void wpa_supplicant_ctrl_iface_deinit(struct ctrl_iface_priv *priv)
+void wpa_supplicant_ctrl_iface_deinit(struct wpa_supplicant *wpa_s,
+                                      struct ctrl_iface_priv *priv)
 {
 	struct wpa_ctrl_dst *dst, *prev;
 	struct ctrl_iface_msg *msg, *prev_msg;
 	struct ctrl_iface_global_priv *gpriv;
 
+   if (!priv) {
+      /*
+       * Control interface has not yet been initialized, so there is
+       * nothing to deinitialize here. However, there might be a
+       * pending message for this interface, so get rid of any such
+       * entry before completing interface removal.
+       */
+      wpas_global_ctrl_iface_flush_queued_msg(wpa_s->global, wpa_s);
+      eloop_cancel_timeout(wpas_ctrl_msg_queue_timeout, wpa_s, NULL);
+      return;
+   }
+
 	if (priv->sock > -1) {
 		char *fname;
 		char *buf, *dir = NULL;
@@ -867,6 +907,7 @@
 			}
 		}
 	}
+   wpas_global_ctrl_iface_flush_queued_msg(wpa_s->global, wpa_s);
 	eloop_cancel_timeout(wpas_ctrl_msg_queue_timeout, priv->wpa_s, NULL);
 	os_free(priv);
 }
diff -aruN old/wpa_supplicant/eapol_test.c new/wpa_supplicant/eapol_test.c
--- old/wpa_supplicant/eapol_test.c	2019-08-07 14:25:25.000000000 +0100
+++ new/wpa_supplicant/eapol_test.c	2021-12-30 13:43:43.648141121 +0000
@@ -674,10 +674,8 @@
 	os_free(e->radius_conf);
 	e->radius_conf = NULL;
 	scard_deinit(wpa_s->scard);
-	if (wpa_s->ctrl_iface) {
-		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
-		wpa_s->ctrl_iface = NULL;
-	}
+	wpa_supplicant_ctrl_iface_deinit(wpa_s, wpa_s->ctrl_iface);
+   wpa_s->ctrl_iface = NULL;
 
 	ext_password_deinit(wpa_s->ext_pw);
 	wpa_s->ext_pw = NULL;
diff -aruN old/wpa_supplicant/preauth_test.c new/wpa_supplicant/preauth_test.c
--- old/wpa_supplicant/preauth_test.c	2019-08-07 14:25:25.000000000 +0100
+++ new/wpa_supplicant/preauth_test.c	2021-12-30 13:43:43.648141121 +0000
@@ -184,10 +184,8 @@
 	pmksa_candidate_free(wpa_s->wpa);
 	wpa_sm_deinit(wpa_s->wpa);
 	scard_deinit(wpa_s->scard);
-	if (wpa_s->ctrl_iface) {
-		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
-		wpa_s->ctrl_iface = NULL;
-	}
+	wpa_supplicant_ctrl_iface_deinit(wpa_s, wpa_s->ctrl_iface);
+   wpa_s->ctrl_iface = NULL;
 	wpa_config_free(wpa_s->conf);
 }
 
diff -aruN old/wpa_supplicant/wpa_supplicant.c new/wpa_supplicant/wpa_supplicant.c
--- old/wpa_supplicant/wpa_supplicant.c	2019-08-07 14:25:25.000000000 +0100
+++ new/wpa_supplicant/wpa_supplicant.c	2021-12-30 13:43:43.648141121 +0000
@@ -1073,8 +1073,8 @@
 		    os_strcmp(conf->ctrl_interface,
 			      wpa_s->conf->ctrl_interface) != 0);
 
-	if (reconf_ctrl && wpa_s->ctrl_iface) {
-		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
+	if (reconf_ctrl) {
+		wpa_supplicant_ctrl_iface_deinit(wpa_s, wpa_s->ctrl_iface);
 		wpa_s->ctrl_iface = NULL;
 	}
 
@@ -6031,10 +6031,8 @@
 	if (terminate)
 		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_TERMINATING);
 
-	if (wpa_s->ctrl_iface) {
-		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
-		wpa_s->ctrl_iface = NULL;
-	}
+   wpa_supplicant_ctrl_iface_deinit(wpa_s, wpa_s->ctrl_iface);
+   wpa_s->ctrl_iface = NULL;
 
 #ifdef CONFIG_MESH
 	if (wpa_s->ifmsh) {
