diff -aruN old/docs/BOOT_LOADER_INTERFACE.md new/docs/BOOT_LOADER_INTERFACE.md
--- old/docs/BOOT_LOADER_INTERFACE.md	2021-07-07 18:41:29.000000000 +0100
+++ new/docs/BOOT_LOADER_INTERFACE.md	2021-11-19 17:19:28.000000000 +0000
@@ -76,10 +76,10 @@
   * `1 << 6` → The boot loader supports passing a random seed to the OS.
 
 * The EFI variable `LoaderRandomSeed` contains a binary random seed if set. It
-  is set by the boot loader to pass an entropy seed read from the ESP partition
-  to the OS. The system manager then credits this seed to the kernel's entropy
-  pool. It is the responsibility of the boot loader to ensure the quality and
-  integrity of the random seed.
+  is set by the boot loader to pass an entropy seed read from the ESP to the OS.
+  The system manager then credits this seed to the kernel's entropy pool. It is
+  the responsibility of the boot loader to ensure the quality and integrity of
+  the random seed.
 
 * The EFI variable `LoaderSystemToken` contains binary random data,
   persistently set by the OS installer. Boot loaders that support passing
diff -aruN old/docs/BOOT_LOADER_SPECIFICATION.md new/docs/BOOT_LOADER_SPECIFICATION.md
--- old/docs/BOOT_LOADER_SPECIFICATION.md	2021-07-07 18:41:29.000000000 +0100
+++ new/docs/BOOT_LOADER_SPECIFICATION.md	2021-11-19 17:19:28.000000000 +0000
@@ -61,8 +61,8 @@
 * On disks with GPT (GUID Partition Table)
   * If the OS is installed on a disk with GPT, and an Extended Boot Loader Partition or XBOOTLDR partition for short, i.e. a partition with GPT type GUID of `bc13c2ff-59e6-4262-a352-b275fd6f7172`, already exists, it should be used as `$BOOT`.
   * Otherwise, if the OS is installed on a disk with GPT, and an EFI System Partition or ESP for short, i.e. a partition with GPT type UID of `c12a7328-f81f-11d2-ba4b-00a0c93ec93b`) already exists and is large enough (let's say 250MB) and otherwise qualifies, it should be used as `$BOOT`.
-  * Otherwise, if the OS is installed on a disk with GPT, and if the ESP partition already exists but is too small, a new suitably sized (let's say 500MB) XBOOTLDR partition shall be created and used as `$BOOT`.
-  * Otherwise, if the OS is installed on a disk with GPT, and no ESP partition exists yet, a new suitably sized (let's say 500MB) ESP should be created and used as `$BOOT`.
+  * Otherwise, if the OS is installed on a disk with GPT, and if the ESP already exists but is too small, a new suitably sized (let's say 500MB) XBOOTLDR partition shall be created and used as `$BOOT`.
+  * Otherwise, if the OS is installed on a disk with GPT, and no ESP exists yet, a new suitably sized (let's say 500MB) ESP should be created and used as `$BOOT`.
 
 This placeholder file system shall be determined during _installation time_, and an fstab entry may be created. It should be mounted to either `/boot/` or `/efi/`. Additional locations like `/boot/efi/`, with `/boot/` being a separate file system, might be supported by implementations. This is not recommended because the mounting of `$BOOT` is then dependent on and requires the mounting of the intermediate file system.
 
diff -aruN old/docs/CODING_STYLE.md new/docs/CODING_STYLE.md
--- old/docs/CODING_STYLE.md	2021-07-07 18:41:29.000000000 +0100
+++ new/docs/CODING_STYLE.md	2021-11-19 17:19:28.000000000 +0000
@@ -287,7 +287,7 @@
   with a more brutal `assert()`. We are more forgiving to public users than for
   ourselves! Note that `assert()` and `assert_return()` really only should be
   used for detecting programming errors, not for runtime errors. `assert()` and
-  `assert_return()` by usage of `_likely_()` inform the compiler that he should
+  `assert_return()` by usage of `_likely_()` inform the compiler that it should
   not expect these checks to fail, and they inform fellow programmers about the
   expected validity and range of parameters.
 
diff -aruN old/docs/PORTABLE_SERVICES.md new/docs/PORTABLE_SERVICES.md
--- old/docs/PORTABLE_SERVICES.md	2021-07-07 18:41:29.000000000 +0100
+++ new/docs/PORTABLE_SERVICES.md	2021-11-19 17:19:28.000000000 +0000
@@ -86,7 +86,7 @@
 `foobar_0.7.23.raw`, then attaching the services to the host is as easy as:
 
 ```
-# /usr/lib/systemd/portablectl attach foobar_0.7.23.raw
+# portablectl attach foobar_0.7.23.raw
 ```
 
 This command does the following:
@@ -268,7 +268,7 @@
 simple as:
 
 ```
-# /usr/lib/systemd/portablectl attach foobar_0.7.23.raw
+# portablectl attach foobar_0.7.23.raw
 # systemctl enable --now foobar@instancea.service
 # systemctl enable --now foobar@instanceb.service
 …
diff -aruN old/docs/PREDICTABLE_INTERFACE_NAMES.md new/docs/PREDICTABLE_INTERFACE_NAMES.md
--- old/docs/PREDICTABLE_INTERFACE_NAMES.md	2021-07-07 18:41:29.000000000 +0100
+++ new/docs/PREDICTABLE_INTERFACE_NAMES.md	2021-11-19 17:19:28.000000000 +0000
@@ -53,7 +53,7 @@
 * The same on all distributions that adopted systemd/udev
 * It's easy to opt out of the scheme (see below)
 
-Does this have any drawbacks? Yes, it does. Previously it was practically guaranteed that hosts equipped with a single ethernet card only had a single `eth0` interface. With this new scheme in place, an administrator now has to check first what the local interface name is before he can invoke commands on it where previously he had a good chance that `eth0` was the right name.
+Does this have any drawbacks? Yes, it does. Previously it was practically guaranteed that hosts equipped with a single ethernet card only had a single `eth0` interface. With this new scheme in place, an administrator now has to check first what the local interface name is before they can invoke commands on it, where previously they had a good chance that `eth0` was the right name.
 
 
 ## I don't like this, how do I disable this?
diff -aruN old/.github/workflows/build_test.yml new/.github/workflows/build_test.yml
--- old/.github/workflows/build_test.yml	2021-07-07 18:41:29.000000000 +0100
+++ new/.github/workflows/build_test.yml	2021-11-19 17:19:28.000000000 +0000
@@ -14,6 +14,9 @@
 jobs:
   build:
     runs-on: ubuntu-20.04
+    concurrency:
+      group: ${{ github.workflow }}-${{ matrix.env.COMPILER }}-${{ matrix.env.COMPILER_VERSION }}-${{ github.ref }}
+      cancel-in-progress: true
     strategy:
       fail-fast: false
       matrix:
diff -aruN old/.github/workflows/cifuzz.yml new/.github/workflows/cifuzz.yml
--- old/.github/workflows/cifuzz.yml	2021-07-07 18:41:29.000000000 +0100
+++ new/.github/workflows/cifuzz.yml	2021-11-19 17:19:28.000000000 +0000
@@ -16,32 +16,35 @@
     branches:
       - main
 jobs:
- Fuzzing:
-   runs-on: ubuntu-latest
-   if: github.repository == 'systemd/systemd'
-   strategy:
-     fail-fast: false
-     matrix:
-       sanitizer: [address, undefined, memory]
-   steps:
-   - name: Build Fuzzers (${{ matrix.sanitizer }})
-     id: build
-     uses: google/oss-fuzz/infra/cifuzz/actions/build_fuzzers@master
-     with:
-       oss-fuzz-project-name: 'systemd'
-       dry-run: false
-       allowed-broken-targets-percentage: 0
-       sanitizer: ${{ matrix.sanitizer }}
-   - name: Run Fuzzers (${{ matrix.sanitizer }})
-     uses: google/oss-fuzz/infra/cifuzz/actions/run_fuzzers@master
-     with:
-       oss-fuzz-project-name: 'systemd'
-       fuzz-seconds: 600
-       dry-run: false
-       sanitizer: ${{ matrix.sanitizer }}
-   - name: Upload Crash
-     uses: actions/upload-artifact@v1
-     if: failure() && steps.build.outcome == 'success'
-     with:
-       name: ${{ matrix.sanitizer }}-artifacts
-       path: ./out/artifacts
+  Fuzzing:
+    runs-on: ubuntu-latest
+    if: github.repository == 'systemd/systemd'
+    concurrency:
+      group: ${{ github.workflow }}-${{ matrix.sanitizer }}-${{ github.ref }}
+      cancel-in-progress: true
+    strategy:
+      fail-fast: false
+      matrix:
+        sanitizer: [address, undefined, memory]
+    steps:
+      - name: Build Fuzzers (${{ matrix.sanitizer }})
+        id: build
+        uses: google/oss-fuzz/infra/cifuzz/actions/build_fuzzers@master
+        with:
+          oss-fuzz-project-name: 'systemd'
+          dry-run: false
+          allowed-broken-targets-percentage: 0
+          sanitizer: ${{ matrix.sanitizer }}
+      - name: Run Fuzzers (${{ matrix.sanitizer }})
+        uses: google/oss-fuzz/infra/cifuzz/actions/run_fuzzers@master
+        with:
+          oss-fuzz-project-name: 'systemd'
+          fuzz-seconds: 600
+          dry-run: false
+          sanitizer: ${{ matrix.sanitizer }}
+      - name: Upload Crash
+        uses: actions/upload-artifact@v1
+        if: failure() && steps.build.outcome == 'success'
+        with:
+          name: ${{ matrix.sanitizer }}-artifacts
+          path: ./out/artifacts
diff -aruN old/.github/workflows/mkosi.yml new/.github/workflows/mkosi.yml
--- old/.github/workflows/mkosi.yml	2021-07-07 18:41:29.000000000 +0100
+++ new/.github/workflows/mkosi.yml	2021-11-19 17:19:28.000000000 +0000
@@ -6,13 +6,18 @@
   push:
     branches:
       - main
+      - v[0-9]+-stable
   pull_request:
     branches:
       - main
+      - v[0-9]+-stable
 
 jobs:
   ci:
     runs-on: ubuntu-20.04
+    concurrency:
+      group: ${{ github.workflow }}-${{ matrix.distro }}-${{ github.ref }}
+      cancel-in-progress: true
     strategy:
       fail-fast: false
       matrix:
diff -aruN old/.github/workflows/unit_tests.yml new/.github/workflows/unit_tests.yml
--- old/.github/workflows/unit_tests.yml	2021-07-07 18:41:29.000000000 +0100
+++ new/.github/workflows/unit_tests.yml	2021-11-19 17:19:28.000000000 +0000
@@ -6,10 +6,14 @@
   pull_request:
     branches:
       - main
+      - v[0-9]+-stable
 
 jobs:
   build:
     runs-on: ubuntu-20.04
+    concurrency:
+      group: ${{ github.workflow }}-${{ matrix.run_phase }}-${{ github.ref }}
+      cancel-in-progress: true
     strategy:
       fail-fast: false
       matrix:
diff -aruN old/hwdb.d/60-keyboard.hwdb new/hwdb.d/60-keyboard.hwdb
--- old/hwdb.d/60-keyboard.hwdb	2021-07-07 18:41:29.000000000 +0100
+++ new/hwdb.d/60-keyboard.hwdb	2021-11-19 17:19:28.000000000 +0000
@@ -1303,7 +1303,6 @@
 # Keymaps MSI Prestige And MSI Modern FnKeys and Special keys
 evdev:atkbd:dmi:bvn*:bvr*:bd*:svnMicro-Star*:pn*Prestige*:*
 evdev:atkbd:dmi:bvn*:bvr*:bd*:svnMicro-Star*:pn*Modern*:*
- KEYBOARD_KEY_56=backslash                              # Secondary backslash key
  KEYBOARD_KEY_f1=f20                                    # Fn+F5 Micmute
  KEYBOARD_KEY_76=f21                                    # Fn+F4 Toggle touchpad, sends meta+ctrl+toggle
  KEYBOARD_KEY_91=prog1                                  # Fn+F7 Creation Center, sometime F7
diff -aruN old/hwdb.d/60-sensor.hwdb new/hwdb.d/60-sensor.hwdb
--- old/hwdb.d/60-sensor.hwdb	2021-07-07 18:41:29.000000000 +0100
+++ new/hwdb.d/60-sensor.hwdb	2021-11-19 17:19:28.000000000 +0000
@@ -226,8 +226,9 @@
 # Chuwi HiBook does not have its product name filled, so we
 # match the entire dmi-alias, assuming that the use of a BOSC0200 +
 # bios-version + bios-date combo is unique
-sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd05/07/2016:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnHampoo:rnCherryTrailCR:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
-sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd05/28/2016:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnHampoo:rnCherryTrailCR:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd05/07/2016:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnHampoo:rnCherryTrailCR:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd05/28/2016:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnHampoo:rnCherryTrailCR:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
  ACCEL_MOUNT_MATRIX=1, 0, 0; 0, -1, 0; 0, 0, 1
 
 # Chuwi HiBook Pro (CWI526)
@@ -237,7 +238,8 @@
 # Chuwi CoreBook
 # Chuwi CoreBook does not have its product name filled, so we
 # match the entire dmi-alias
-sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvrY13D_KB133.103:bd06/01/2018:svnHampoo:pnDefaultstring:pvrV100:rvnHampoo:rnY13D_KB133:rvrV100:cvnDefaultstring:ct9:cvrDefaultstring:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvrY13D_KB133.103:bd06/01/2018:*svnHampoo:pnDefaultstring:pvrV100:rvnHampoo:rnY13D_KB133:rvrV100:cvnDefaultstring:ct9:cvrDefaultstring:*
  ACCEL_MOUNT_MATRIX=-1, 0, 0; 0, 1, 0; 0, 0, 1
 
 #########################################
@@ -394,13 +396,14 @@
 # and no other devices have both board_name *and* product_name set to
 # "Default string". So combined with the sensor modalias and BIOS date this
 # should be unique enough to identify the GPDwin
-sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd10/25/2016:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
-sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd11/18/2016:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
-sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd12/23/2016:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
-sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd12/26/2016:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
-sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd02/21/2017:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
-sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd03/20/2017:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
-sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd05/25/2017:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd10/25/2016:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd11/18/2016:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd12/23/2016:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd12/26/2016:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd02/21/2017:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd03/20/2017:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.11:bd05/25/2017:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnAMICorporation:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
  ACCEL_LOCATION=base
 
 #########################################
@@ -674,7 +677,8 @@
  ACCEL_MOUNT_MATRIX=0, -1, 0; -1, 0, 0; 0, 0, 1
 
 # Onda v975w, generic DMI strings, match entire dmi modalias inc. bios-date
-sensor:modalias:acpi:SMO8500*:dmi:bvnAmericanMegatrendsInc.:bvr5.6.5:bd07/25/2014:svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:SMO8500*:dmi:bvnAmericanMegatrendsInc.:bvr5.6.5:bd07/25/2014:*svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
  ACCEL_MOUNT_MATRIX=0, -1, 0; -1, 0, 0; 0, 0, 1
 
 #########################################
@@ -683,7 +687,8 @@
 
 # One-netbook OneMix 2s
 # OneMix 2s has no product name filled, matching entire dmi-alias
-sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvr5.12:bd10/26/2018:br5.12:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnDefaultstring:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvr5.12:bd10/26/2018:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnDefaultstring:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
  ACCEL_MOUNT_MATRIX=0, 1, 0; 1, 0, 0; 0, 0, 1
 
 # One-netbook OneMix 3 Pro
@@ -692,7 +697,8 @@
 
 # One-netbook OneMix 3s
 # OneMix 3s has no product name filled, matching entire dmi-alias
-sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvr5.12:bd07/17/2019:br5.12:svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnDefaultstring:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:BOSC0200*:dmi:bvnAmericanMegatrendsInc.:bvr5.12:bd07/17/2019:*svnDefaultstring:pnDefaultstring:pvrDefaultstring:rvnDefaultstring:rnDefaultstring:rvrDefaultstring:cvnDefaultstring:ct3:cvrDefaultstring:*
  ACCEL_MOUNT_MATRIX=-1, 0, 0; 0, 1, 0; 0, 0, 1
 
 #########################################
@@ -724,8 +730,9 @@
 # The Point of View TAB-P800W does not have its product name filled, so we
 # match the entire dmi-alias, assuming that the use of a BMA250E +
 # bios-version + bios-date combo is unique
-sensor:modalias:acpi:BMA250E*:dmi:bvnAmericanMegatrendsInc.:bvr3BAIR1013:bd08/22/2014:svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
-sensor:modalias:acpi:BMA250E*:dmi:bvnAmericanMegatrendsInc.:bvr3BAIR1014:bd10/24/2014:svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:BMA250E*:dmi:bvnAmericanMegatrendsInc.:bvr3BAIR1013:bd08/22/2014:*svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
+sensor:modalias:acpi:BMA250E*:dmi:bvnAmericanMegatrendsInc.:bvr3BAIR1014:bd10/24/2014:*svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
  ACCEL_MOUNT_MATRIX=0, 1, 0; 1, 0, 0; 0, 0, 1
 
 # Point of View TAB-P1005W-232 (v2.0)
@@ -803,7 +810,8 @@
  ACCEL_MOUNT_MATRIX=1, 0, 0; 0, -1, 0; 0, 0, 1
 
 # Teclast X98 Plus I (A5C6), generic DMI strings, match entire dmi modalias inc. bios-date
-sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.011:bd11/03/2015:svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnCherryTrailCR:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:KIOX000A*:dmi:bvnAmericanMegatrendsInc.:bvr5.011:bd11/03/2015:*svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnCherryTrailCR:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
  ACCEL_MOUNT_MATRIX=0, 1, 0; 1, 0, 0; 0, 0, 1
 
 # Teclast X98 Plus II
@@ -815,7 +823,8 @@
 #########################################
 
 # Thundersoft TST168 tablet, generic DMI strings, match entire dmi modalias inc. bios-date
-sensor:modalias:acpi:BMA250E*:dmi:bvnAmericanMegatrendsInc.:bvr5.6.5:bd04/15/2014:svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:BMA250E*:dmi:bvnAmericanMegatrendsInc.:bvr5.6.5:bd04/15/2014:*svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
  ACCEL_MOUNT_MATRIX=-1, 0, 0; 0, 1, 0; 0, 0, 1
 
 #########################################
@@ -883,7 +892,8 @@
 # The Winpad A15 does not have its product name filled, so we
 # match the entire dmi-alias, assuming that the use of a SMO8500 +
 # bios-version + bios-date combo is unique
-sensor:modalias:acpi:SMO8500*:dmi:bvnAmericanMegatrendsInc.:bvr5.6.5:bd11/20/2014:br5.6:svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
+# '*' in ":*svn" is there because kernels >= 5.8 have inserted a br field there
+sensor:modalias:acpi:SMO8500*:dmi:bvnAmericanMegatrendsInc.:bvr5.6.5:bd11/20/2014:*svnTobefilledbyO.E.M.:pnTobefilledbyO.E.M.:pvrTobefilledbyO.E.M.:rvnAMICorporation:rnAptioCRB:rvrTobefilledbyO.E.M.:cvnToBeFilledByO.E.M.:ct3:cvrToBeFilledByO.E.M.:*
  ACCEL_MOUNT_MATRIX=0, -1, 0; 1, 0, 0; 0, 0, -1
 
 #########################################
diff -aruN old/man/bootctl.xml new/man/bootctl.xml
--- old/man/bootctl.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/bootctl.xml	2021-11-19 17:19:28.000000000 +0000
@@ -240,8 +240,8 @@
       <varlistentry>
         <term><option>--make-machine-id-directory=yes|no|auto</option></term>
         <listitem><para>Control creation and deletion of the top-level machine ID directory on the file
-        system containing boot loader entries (i.e. beneath the file system returned by
-        <option>--print-boot-path</option> above) during <option>install</option> and
+        system containing boot loader entries (i.e. beneath the file system returned by the
+        <option>--print-boot-path</option> option, see above) during <option>install</option> and
         <option>remove</option>, respectively.  <literal>auto</literal> is equivalent to
         <literal>yes</literal> if <filename>/etc/machine-id</filename> resides on a filesystem other than
         tmpfs and <literal>no</literal> otherwise (in the latter case the machine ID is likely transient and
diff -aruN old/man/coredump.conf.xml new/man/coredump.conf.xml
--- old/man/coredump.conf.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/coredump.conf.xml	2021-11-19 17:19:28.000000000 +0000
@@ -83,12 +83,9 @@
       <varlistentry>
         <term><varname>ProcessSizeMax=</varname></term>
 
-        <listitem><para>The maximum size in bytes of a core
-        which will be processed. Core dumps exceeding this size
-        may be stored, but the backtrace will not be generated.
-        Like other sizes in this same config file, the usual
-        suffixes to the base of 1024 are allowed (B, K, M,
-        G, T, P, and E.)</para>
+        <listitem><para>The maximum size in bytes of a core which will be processed. Core dumps exceeding
+        this size may be stored, but the backtrace will not be generated.  Like other sizes in this same
+        config file, the usual suffixes to the base of 1024 are allowed (B, K, M, G, T, P, and E).</para>
 
         <para>Setting <varname>Storage=none</varname> and <varname>ProcessSizeMax=0</varname>
         disables all coredump handling except for a log entry.</para>
@@ -99,9 +96,8 @@
         <term><varname>ExternalSizeMax=</varname></term>
         <term><varname>JournalSizeMax=</varname></term>
 
-        <listitem><para>The maximum (compressed or uncompressed) size in bytes of a
-        core to be saved. Unit suffixes are allowed just as in
-        <option>ProcessSizeMax=</option></para></listitem>.
+        <listitem><para>The maximum (compressed or uncompressed) size in bytes of a core to be saved. Unit
+        suffixes are allowed just as in <option>ProcessSizeMax=</option>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
@@ -120,9 +116,8 @@
         by core dumps might temporarily exceed these limits while
         core dumps are processed. Note that old core dumps are also
         removed based on time via
-        <citerefentry><refentrytitle>systemd-tmpfiles</refentrytitle><manvolnum>8</manvolnum></citerefentry>. Set
-        either value to 0 to turn off size-based
-        clean-up.</para></listitem>
+        <citerefentry><refentrytitle>systemd-tmpfiles</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
+        Set either value to 0 to turn off size-based cleanup.</para></listitem>
       </varlistentry>
     </variablelist>
 
diff -aruN old/man/coredumpctl.xml new/man/coredumpctl.xml
--- old/man/coredumpctl.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/coredumpctl.xml	2021-11-19 17:19:28.000000000 +0000
@@ -162,7 +162,7 @@
         <term><option>-1</option></term>
 
         <listitem><para>Show information of the most recent core dump only, instead of listing all known core
-        dumps. (Equivalent to <option>--reverse -n 1</option></para></listitem>
+        dumps. Equivalent to <option>--reverse -n 1</option>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
diff -aruN old/man/nss-myhostname.xml new/man/nss-myhostname.xml
--- old/man/nss-myhostname.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/nss-myhostname.xml	2021-11-19 17:19:28.000000000 +0000
@@ -73,13 +73,17 @@
     <para>To activate the NSS modules, add <literal>myhostname</literal> to the line starting with
     <literal>hosts:</literal> in <filename>/etc/nsswitch.conf</filename>.</para>
 
-    <para>It is recommended to place <literal>myhostname</literal> either between <literal>resolve</literal>
-    and "traditional" modules like <literal>dns</literal>, or after them. In the first version, well-known
-    names like <literal>localhost</literal> and the machine hostname are given higher priority than the
-    external configuration. This is recommended when the external DNS servers and network are not absolutely
-    trusted. In the second version, external configuration is given higher priority and
-    <command>nss-myhostname</command> only provides a fallback mechanism. This might be suitable in closely
-    controlled networks, for example on a company LAN.</para>
+    <para>It is recommended to place <literal>myhostname</literal> after <literal>file</literal> and before <literal>dns</literal>.
+    This resolves well-known hostnames like <literal>localhost</literal>
+    and the machine hostnames locally. It is consistent with the behaviour
+    of <command>nss-resolve</command>, and still allows overriding via
+    <filename>/etc/hosts</filename>.</para>
+
+    <para>Please keep in mind that <command>nss-myhostname</command> (and <command>nss-resolve</command>) also resolve
+    in the other direction — from locally attached IP adresses to
+    hostnames. If you rely on that lookup being provided by DNS, you might
+    want to order things differently.
+    </para>
   </refsect1>
 
   <refsect1>
@@ -95,10 +99,7 @@
 gshadow:        files systemd
 
 
-# Either (untrusted network, see above):
 hosts:          mymachines resolve [!UNAVAIL=return] files <command>myhostname</command> dns
-# Or (only trusted networks):
-hosts:          mymachines resolve [!UNAVAIL=return] files dns <command>myhostname</command>
 networks:       files
 
 protocols:      db files
diff -aruN old/man/nss-resolve.xml new/man/nss-resolve.xml
--- old/man/nss-resolve.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/nss-resolve.xml	2021-11-19 17:19:28.000000000 +0000
@@ -52,6 +52,16 @@
     it is still recommended (see examples below) to keep <command>nss-myhostname</command> configured in
     <filename>/etc/nsswitch.conf</filename>, to keep those names resolveable if
     <command>systemd-resolved</command> is not running.</para>
+
+    <para>Please keep in mind that <command>nss-myhostname</command> (and <command>nss-resolve</command>) also resolve
+    in the other direction — from locally attached IP adresses to
+    hostnames. If you rely on that lookup being provided by DNS, you might
+    want to order things differently.
+    </para>
+
+    <para>Communication between <command>nss-resolve</command> and
+    <filename>systemd-resolved.service</filename> takes place via the
+    <filename>/run/systemd/resolve/io.systemd.Resolve</filename> <constant>AF_UNIX</constant> socket.</para>
   </refsect1>
 
   <refsect1>
diff -aruN old/man/nss-systemd.xml new/man/nss-systemd.xml
--- old/man/nss-systemd.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/nss-systemd.xml	2021-11-19 17:19:28.000000000 +0000
@@ -67,7 +67,7 @@
 
     <para>This is a simple mechanism to provide static user and group records via JSON drop-in files. Such
     user records should be defined in the format described by the <ulink
-    url="https://systemd.io/USER_RECORD">JSON User Record</ulink> specification and be placed in one of the
+    url="https://systemd.io/USER_RECORD">JSON User Records</ulink> specification and be placed in one of the
     aforementioned directories under a file name composed of the user name suffixed with
     <filename>.user</filename>, with a world-readable access mode. A symlink named after the user record's
     UID formatted in decimal and suffixed with <filename>.user</filename> pointing to the primary record file
diff -aruN old/man/org.freedesktop.systemd1.xml new/man/org.freedesktop.systemd1.xml
--- old/man/org.freedesktop.systemd1.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/org.freedesktop.systemd1.xml	2021-11-19 17:19:28.000000000 +0000
@@ -1706,12 +1706,12 @@
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b DefaultDependencies = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly s OnSuccesJobMode = '...';
+      readonly s OnSuccessJobMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s OnFailureJobMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b IgnoreOnIsolate = ...;
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
+      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b NeedDaemonReload = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as Markers = ['...', ...];
@@ -1815,7 +1815,7 @@
 
     <!--property CanFreeze is not documented!-->
 
-    <!--property OnSuccesJobMode is not documented!-->
+    <!--property OnSuccessJobMode is not documented!-->
 
     <!--property OnFailureJobMode is not documented!-->
 
@@ -2019,7 +2019,7 @@
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultDependencies"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="OnSuccesJobMode"/>
+    <variablelist class="dbus-property" generated="True" extra-ref="OnSuccessJobMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="OnFailureJobMode"/>
 
diff -aruN old/man/os-release.xml new/man/os-release.xml
--- old/man/os-release.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/os-release.xml	2021-11-19 17:19:28.000000000 +0000
@@ -373,7 +373,7 @@
 
           <listitem><para>A lower-case string (mostly numeric, no spaces or other characters outside of 0–9,
           a–z, ".", "_" and "-") identifying the operating system extensions support level, to indicate which
-          extension images are supported. See:
+          extension images are supported. See
           <citerefentry><refentrytitle>systemd-sysext</refentrytitle><manvolnum>8</manvolnum></citerefentry>)
           for more information.</para>
 
diff -aruN old/man/pam_systemd.xml new/man/pam_systemd.xml
--- old/man/pam_systemd.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/pam_systemd.xml	2021-11-19 17:19:28.000000000 +0000
@@ -33,7 +33,7 @@
     and hence the systemd control group hierarchy.</para>
 
     <para>The module also applies various resource management and runtime parameters to the new session, as
-    configured in the <ulink url="https://systemd.io/USER_RECORD">JSON User Record</ulink> of the user, when
+    configured in the <ulink url="https://systemd.io/USER_RECORD">JSON User Records</ulink> of the user, when
     one is defined.</para>
 
     <para>On login, this module — in conjunction with <filename>systemd-logind.service</filename> — ensures the
diff -aruN old/man/path-documents.c new/man/path-documents.c
--- old/man/path-documents.c	2021-07-07 18:41:29.000000000 +0100
+++ new/man/path-documents.c	2021-11-19 17:19:28.000000000 +0000
@@ -1,9 +1,17 @@
 #include <stdio.h>
+#include <stdlib.h>
 #include <sd-path.h>
 
 int main(void) {
+  int r;
   char *t;
 
-  sd_path_lookup(SD_PATH_USER_DOCUMENTS, NULL, &t);
+  r = sd_path_lookup(SD_PATH_USER_DOCUMENTS, NULL, &t);
+  if (r < 0)
+    return EXIT_FAILURE;
+
   printf("~/Documents: %s\n", t);
+  free(t);
+
+  return EXIT_SUCCESS;
 }
diff -aruN old/man/repart.d.xml new/man/repart.d.xml
--- old/man/repart.d.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/repart.d.xml	2021-11-19 17:19:28.000000000 +0000
@@ -434,8 +434,8 @@
         <para>If the special value <literal>auto</literal> is specified, the source to copy from is
         automatically picked up from the running system (or the image specified with
         <option>--image=</option> — if used). A partition that matches both the configured partition type (as
-        declared with <varname>Type=</varname> above), and the currently mounted directory appropriate for
-        that partition type is determined. For example, if the partition type is set to
+        declared with <varname>Type=</varname> described above), and the currently mounted directory
+        appropriate for that partition type is determined. For example, if the partition type is set to
         <literal>root</literal> the partition backing the root directory (<filename>/</filename>) is used as
         source to copy from — if its partition type is set to <literal>root</literal> as well. If the
         declared type is <literal>usr</literal> the partition backing <filename>/usr/</filename> is used as
@@ -511,7 +511,7 @@
       <varlistentry>
         <term><varname>MakeDirectories=</varname></term>
 
-        <listitem><para>akes one or more absolute paths, separated by whitespace, each declaring a directory
+        <listitem><para>Takes one or more absolute paths, separated by whitespace, each declaring a directory
         to create within the new file system. Behaviour is similar to <varname>CopyFiles=</varname>, but
         instead of copying in a set of files this just creates the specified directories with the default
         mode of 0755 owned by the root user and group, plus all their parent directories (with the same
@@ -546,10 +546,10 @@
         are copied in or the file system configured with <varname>Format=</varname> is created.</para>
 
         <para>The LUKS2 UUID is automatically derived from the partition UUID in a stable fashion. If
-        <literal>key-file</literal> or <literal>key-file+tpm2</literal> is used a key is added to the LUKS2
-        superblock, configurable with the <option>--key-file=</option> switch to
+        <literal>key-file</literal> or <literal>key-file+tpm2</literal> is used, a key is added to the LUKS2
+        superblock, configurable with the <option>--key-file=</option> option to
         <command>systemd-repart</command>. If <literal>tpm2</literal> or <literal>key-file+tpm2</literal> is
-        used a key is added to the LUKS2 superblock that is enrolled to the local TPM2 chip, as configured
+        used, a key is added to the LUKS2 superblock that is enrolled to the local TPM2 chip, as configured
         with the <option>--tpm2-device=</option> and <option>--tpm2-pcrs=</option> options to
         <command>systemd-repart</command>.</para>
 
@@ -605,7 +605,7 @@
         has no effect on explicit mounts, such as those done via <citerefentry
         project='man-pages'><refentrytitle>mount</refentrytitle><manvolnum>8</manvolnum></citerefentry> or
         <citerefentry
-        project='man-pages'><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry></para>
+        project='man-pages'><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
 
         <para>If both bit 50 and 59 are set for a partition (i.e. the partition is marked both read-only and
         marked for file system growing) the latter is typically without effect: the read-only flag takes
diff -aruN old/man/sd_bus_add_object.xml new/man/sd_bus_add_object.xml
--- old/man/sd_bus_add_object.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/sd_bus_add_object.xml	2021-11-19 17:19:28.000000000 +0000
@@ -508,7 +508,7 @@
         <varlistentry>
           <term><constant>SD_BUS_VTABLE_METHOD_NO_REPLY</constant></term>
 
-          <listitem><para>Mark his vtable entry as a method that will not return a reply using the
+          <listitem><para>Mark this vtable entry as a method that will not return a reply using the
           <constant>org.freedesktop.DBus.Method.NoReply</constant> annotation in introspection data.
           </para></listitem>
         </varlistentry>
diff -aruN old/man/sd_bus_set_property.xml new/man/sd_bus_set_property.xml
--- old/man/sd_bus_set_property.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/sd_bus_set_property.xml	2021-11-19 17:19:28.000000000 +0000
@@ -39,7 +39,6 @@
         <paramdef>const char *<parameter>interface</parameter></paramdef>
         <paramdef>const char *<parameter>member</parameter></paramdef>
         <paramdef>sd_bus_error *<parameter>ret_error</parameter></paramdef>
-        <paramdef>sd_bus_message **<parameter>reply</parameter></paramdef>
         <paramdef>const char *<parameter>type</parameter></paramdef>
         <paramdef>...</paramdef>
       </funcprototype>
@@ -52,7 +51,6 @@
         <paramdef>const char *<parameter>interface</parameter></paramdef>
         <paramdef>const char *<parameter>member</parameter></paramdef>
         <paramdef>sd_bus_error *<parameter>ret_error</parameter></paramdef>
-        <paramdef>sd_bus_message **<parameter>reply</parameter></paramdef>
         <paramdef>const char *<parameter>type</parameter></paramdef>
         <paramdef>va_list <parameter>ap</parameter></paramdef>
       </funcprototype>
@@ -115,10 +113,9 @@
     <citerefentry><refentrytitle>sd_bus_call_method</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
     </para>
 
-    <para><function>sd_bus_set_property()</function> sets a D-Bus property. On success, the response
-    is stored in <parameter>reply</parameter>. If setting the property fails or an internal error
-    occurs, an error is returned and an extended description of the error is optionally stored in
-    <parameter>ret_error</parameter> if it is not <constant>NULL</constant>.
+    <para><function>sd_bus_set_property()</function> sets a D-Bus property. If setting the property
+    fails or an internal error occurs, an error is returned and an extended description of the error
+    is optionally stored in <parameter>ret_error</parameter> if it is not <constant>NULL</constant>.
     <parameter>type</parameter> and the arguments that follow it describe the new value of the
     property and must follow the format described in
     <citerefentry><refentrytitle>sd_bus_message_append</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
diff -aruN old/man/sd_listen_fds.xml new/man/sd_listen_fds.xml
--- old/man/sd_listen_fds.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/sd_listen_fds.xml	2021-11-19 17:19:28.000000000 +0000
@@ -45,14 +45,24 @@
   <refsect1>
     <title>Description</title>
 
-    <para><function>sd_listen_fds()</function> may be invoked by a
-    daemon to check for file descriptors passed by the service manager as
-    part of the socket-based activation logic. It returns the number
-    of received file descriptors. If no file descriptors have been
-    received, zero is returned. The first file descriptor may be found
-    at file descriptor number 3
-    (i.e. <constant>SD_LISTEN_FDS_START</constant>), the remaining
-    descriptors follow at 4, 5, 6, …, if any.</para>
+    <para><function>sd_listen_fds()</function> may be invoked by a daemon to check for file descriptors
+    passed by the service manager as part of the socket-based activation logic. It returns the number of
+    received file descriptors. If no file descriptors have been received, zero is returned. The first file
+    descriptor may be found at file descriptor number 3 (i.e. <constant>SD_LISTEN_FDS_START</constant>), the
+    remaining descriptors follow at 4, 5, 6, …, if any.</para>
+
+    <para>The file descriptors passed this way may be closed at will by the processes receiving them: it's up
+    to the processes themselves to close them after use or whether to leave them open until the process exits
+    (in which case the kernel closes them automatically). Note that the file descriptors received by daemons
+    are duplicates of the file descriptors the service manager originally allocated and bound and of which it
+    continously keeps a copy (except if <varname>Accept=yes</varname> is used). This means any socket option
+    changes and other changes made to the sockets will visible to the service manager too. Most importanly
+    this means it's generally not a good idea to invoke <citerefentry
+    project='man-pages'><refentrytitle>shutdown</refentrytitle><manvolnum>2</manvolnum></citerefentry> on
+    such sockets, since it will shut down communication on the file descriptor the service manager holds for
+    the same socket, too. Also note that if a daemon is restarted (and its associated sockets are not) it
+    will receive file descriptors to the very same sockets as the earlier invocations, thus all socket
+    options applied then will still apply.</para>
 
     <para>If a daemon receives more than one file descriptor, they will be passed in the same order as
     configured in the systemd socket unit file (see
diff -aruN old/man/systemctl.xml new/man/systemctl.xml
--- old/man/systemctl.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemctl.xml	2021-11-19 17:19:28.000000000 +0000
@@ -65,6 +65,13 @@
             that are shown are additionally filtered by <option>--type=</option> and <option>--state=</option> if those
             options are specified.</para>
 
+            <para>Note that this command does not show unit templates, but only instances of unit
+            templates. Units templates that aren't instantiated are not runnable, and will thus never show up
+            in the output of this command. Specifically this means that <filename>foo@.service</filename>
+            will never be shown in this list — unless instantiated, e.g. as
+            <filename>foo@bar.service</filename>. Use <command>list-unit-files</command> (see below) for
+            listing installed unit template files.</para>
+
             <para>Produces output similar to
             <programlisting>  UNIT                         LOAD   ACTIVE SUB     DESCRIPTION
   sys-module-fuse.device       loaded active plugged /sys/module/fuse
@@ -81,11 +88,11 @@
 SUB    = The low-level unit activation state, values depend on unit type.
 
 123 loaded units listed. Pass --all to see loaded but inactive units, too.
-To show all installed unit files use 'systemctl list-unit-files'.
-            </programlisting>
-            The header and the last unit of a given type are underlined if the
-            terminal supports that. A colored dot is shown next to services which
-            were masked, not found, or otherwise failed.</para>
+To show all installed unit files use 'systemctl list-unit-files'.</programlisting></para>
+
+            <para>The header and the last unit of a given type are underlined if the terminal supports
+            that. A colored dot is shown next to services which were masked, not found, or otherwise
+            failed.</para>
 
             <para>The LOAD column shows the load state, one of <constant>loaded</constant>,
             <constant>not-found</constant>, <constant>bad-setting</constant>, <constant>error</constant>,
@@ -552,38 +559,62 @@
         </varlistentry>
 
         <varlistentry>
-          <term><command>bind</command> <replaceable>UNIT</replaceable> <replaceable>PATH</replaceable> [<replaceable>PATH</replaceable>]</term>
+          <term>
+            <command>bind</command>
+            <replaceable>UNIT</replaceable>
+            <replaceable>PATH</replaceable>
+            [<replaceable>PATH</replaceable>]
+          </term>
 
-          <listitem><para>Bind mounts a file or directory from the host into the specified unit's view. The first path
-          argument is the source file or directory on the host, the second path argument is the destination file or
-          directory in the unit's view. When the latter is omitted, the destination path in the unit's view is the same as
-          the source path on the host. When combined with the <option>--read-only</option> switch, a ready-only bind
-          mount is created. When combined with the <option>--mkdir</option> switch, the destination path is first created
-          before the mount is applied. Note that this option is currently only supported for units that run within a mount
-          namespace (e.g.: with <option>RootImage=</option>, <option>PrivateMounts=</option>, etc.). This command supports bind
-          mounting directories, regular files, device nodes, <constant>AF_UNIX</constant> socket nodes, as well as FIFOs.
-          The bind mount is ephemeral, and it is undone as soon as the current unit process exists.
-          Note that the namespace mentioned here, where the bind mount will be added to, is the one where the main service
-          process runs, as other processes run in distinct namespaces (e.g.: <option>ExecReload=</option>,
-          <option>ExecStartPre=</option>, etc.) </para></listitem>
+          <listitem><para>Bind-mounts a file or directory from the host into the specified unit's mount
+          namespace. The first path argument is the source file or directory on the host, the second path
+          argument is the destination file or directory in the unit's mount namespace. When the latter is
+          omitted, the destination path in the unit's mount namespace is the same as the source path on the
+          host. When combined with the <option>--read-only</option> switch, a ready-only bind mount is
+          created. When combined with the <option>--mkdir</option> switch, the destination path is first
+          created before the mount is applied.</para>
+
+          <para>Note that this option is currently only supported for units that run within a mount namespace
+          (e.g.: with <option>RootImage=</option>, <option>PrivateMounts=</option>, etc.). This command
+          supports bind-mounting directories, regular files, device nodes, <constant>AF_UNIX</constant>
+          socket nodes, as well as FIFOs.  The bind mount is ephemeral, and it is undone as soon as the
+          current unit process exists. Note that the namespace mentioned here, where the bind mount will be
+          added to, is the one where the main service process runs. Other processes (those exececuted by
+          <option>ExecReload=</option>, <option>ExecStartPre=</option>, etc.) run in distinct namespaces.
+          </para></listitem>
         </varlistentry>
 
         <varlistentry>
-          <term><command>mount-image</command> <replaceable>UNIT</replaceable> <replaceable>IMAGE</replaceable> [<replaceable>PATH</replaceable> [<replaceable>PARTITION_NAME</replaceable>:<replaceable>MOUNT_OPTIONS</replaceable>]]</term>
-
-          <listitem><para>Mounts an image from the host into the specified unit's view. The first path argument is the source
-          image on the host, the second path argument is the destination directory in the unit's view (ie: inside
-          <option>RootImage=</option>/<option>RootDirectory=</option>). Any following argument is interpreted as a
-          colon-separated tuple of partition name and comma-separated list of mount options for that partition. The format is the
-          same as the service <option>MountImages=</option> setting. When combined with the <option>--read-only</option> switch, a
-          ready-only mount is created. When combined with the <option>--mkdir</option> switch, the destination path is first
-          created before the mount is applied. Note that this option is currently only supported for units that run within a mount
-          namespace (e.g.: with <option>RootImage=</option>, <option>PrivateMounts=</option>, etc.).
-          Note that the namespace mentioned here, where the image mount will be added to, is the one where the main service
-          process runs, as other processes run in distinct namespaces (e.g.: <option>ExecReload=</option>,
-          <option>ExecStartPre=</option>, etc.). Example:
+          <term>
+            <command>mount-image</command>
+            <replaceable>UNIT</replaceable>
+            <replaceable>IMAGE</replaceable>
+            [<replaceable>PATH</replaceable>
+            [<replaceable>PARTITION_NAME</replaceable>:<replaceable>MOUNT_OPTIONS</replaceable>]]
+          </term>
+
+          <listitem><para>Mounts an image from the host into the specified unit's mount namespace. The first
+          path argument is the source image on the host, the second path argument is the destination
+          directory in the unit's mount namespace (i.e. inside
+          <option>RootImage=</option>/<option>RootDirectory=</option>). The following argument, if any, is
+          interpreted as a colon-separated tuple of partition name and comma-separated list of mount options
+          for that partition. The format is the same as the service <option>MountImages=</option>
+          setting. When combined with the <option>--read-only</option> switch, a ready-only mount is
+          created. When combined with the <option>--mkdir</option> switch, the destination path is first
+          created before the mount is applied.</para>
+
+          <para>Note that this option is currently only supported for units that run within a mount namespace
+          (i.e. with <option>RootImage=</option>, <option>PrivateMounts=</option>, etc.). Note that the
+          namespace mentioned here where the image mount will be added to, is the one where the main service
+          process runs. Note that the namespace mentioned here, where the bind mount will be
+          added to, is the one where the main service process runs. Other processes (those exececuted by
+          <option>ExecReload=</option>, <option>ExecStartPre=</option>, etc.) run in distinct namespaces.
+          </para>
+
+          <para>Example:
           <programlisting>systemctl mount-image foo.service /tmp/img.raw /var/lib/image root:ro,nosuid</programlisting>
-          <programlisting>systemctl mount-image --mkdir bar.service /tmp/img.raw /var/lib/baz/img</programlisting></para></listitem>
+          <programlisting>systemctl mount-image --mkdir bar.service /tmp/img.raw /var/lib/baz/img</programlisting>
+          </para></listitem>
         </varlistentry>
 
         <varlistentry>
@@ -670,10 +701,13 @@
           <term><command>list-unit-files</command> <optional><replaceable>PATTERN…</replaceable></optional></term>
 
           <listitem>
-            <para>List unit files installed on the system, in combination with their enablement state (as reported by
-            <command>is-enabled</command>). If one or more <replaceable>PATTERN</replaceable>s are specified, only unit
-            files whose name matches one of them are shown (patterns matching unit file system paths are not
-            supported).</para>
+            <para>List unit files installed on the system, in combination with their enablement state (as
+            reported by <command>is-enabled</command>). If one or more <replaceable>PATTERN</replaceable>s
+            are specified, only unit files whose name matches one of them are shown (patterns matching unit
+            file system paths are not supported).</para>
+
+            <para>Unlike <command>list-units</command> this command will list template units in addition to
+            explicitly instantiated units.</para>
           </listitem>
         </varlistentry>
 
@@ -1626,8 +1660,8 @@
           completion is implemented for property names.</para>
 
           <para>For the manager itself,
-          <command>systemctl show</command> will show all available
-          properties. Those properties are documented in
+          <command>systemctl show</command>
+          will show all available properties, most of which are derived or closely match the options described in
           <citerefentry><refentrytitle>systemd-system.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
           </para>
 
@@ -2185,9 +2219,9 @@
         <term><option>--lines=</option></term>
 
         <listitem>
-          <para>When used with <command>status</command>, controls the number of journal lines to show, counting from
-          the most recent ones. Takes a positive integer argument, or 0 to disable journal output. Defaults to
-          10.</para>
+          <para>When used with <command>status</command>, controls the number of journal lines to show,
+          counting from the most recent ones. Takes a positive integer argument, or 0 to disable journal
+          output. Defaults to 10.</para>
         </listitem>
       </varlistentry>
 
@@ -2208,8 +2242,9 @@
         <term><option>--firmware-setup</option></term>
 
         <listitem>
-          <para>When used with the <command>reboot</command> command, indicate to the system's firmware to reboot into
-          the firmware setup interface. Note that this functionality is not available on all systems.</para>
+          <para>When used with the <command>reboot</command> command, indicate to the system's firmware to
+          reboot into the firmware setup interface. Note that this functionality is not available on all
+          systems.</para>
         </listitem>
       </varlistentry>
 
@@ -2217,10 +2252,10 @@
         <term><option>--boot-loader-menu=</option></term>
 
         <listitem>
-          <para>When used with the <command>reboot</command> command, indicate to the system's boot loader to show the
-          boot loader menu on the following boot. Takes a time value as parameter — indicating the menu timeout. Pass
-          zero in order to disable the menu timeout. Note that not all boot loaders support this
-          functionality.</para>
+          <para>When used with the <command>reboot</command> command, indicate to the system's boot loader to
+          show the boot loader menu on the following boot. Takes a time value as parameter — indicating the
+          menu timeout. Pass zero in order to disable the menu timeout. Note that not all boot loaders
+          support this functionality.</para>
         </listitem>
       </varlistentry>
 
@@ -2228,10 +2263,10 @@
         <term><option>--boot-loader-entry=</option></term>
 
         <listitem>
-          <para>When used with the <command>reboot</command> command, indicate to the system's boot loader to boot into
-          a specific boot loader entry on the following boot. Takes a boot loader entry identifier as argument, or
-          <literal>help</literal> in order to list available entries. Note that not all boot loaders support this
-          functionality.</para>
+          <para>When used with the <command>reboot</command> command, indicate to the system's boot loader to
+          boot into a specific boot loader entry on the following boot. Takes a boot loader entry identifier
+          as argument, or <literal>help</literal> in order to list available entries. Note that not all boot
+          loaders support this functionality.</para>
         </listitem>
       </varlistentry>
 
diff -aruN old/man/systemd-boot.xml new/man/systemd-boot.xml
--- old/man/systemd-boot.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-boot.xml	2021-11-19 17:19:28.000000000 +0000
@@ -73,8 +73,8 @@
       <citerefentry><refentrytitle>systemctl</refentrytitle><manvolnum>1</manvolnum></citerefentry> for
       details.</para></listitem>
 
-      <listitem><para>An EFI variable set by the boot loader informs the OS about the ESP partition used
-      during boot. This is then used to automatically mount the correct ESP partition to
+      <listitem><para>An EFI variable set by the boot loader informs the OS about the EFI System Partition used
+      during boot. This is then used to automatically mount the correct EFI System Partition to
       <filename>/efi/</filename> or <filename>/boot/</filename> during OS runtime. See
       <citerefentry><refentrytitle>systemd-gpt-auto-generator</refentrytitle><manvolnum>8</manvolnum></citerefentry>
       for details.</para></listitem>
@@ -294,7 +294,7 @@
     <title>EFI Variables</title>
 
     <para>The following EFI variables are defined, set and read by <command>systemd-boot</command>, under the vendor
-    UUID <literal>4a67b082-0a4c-41cf-b6c7-440b29bb8c4</literal>, for communication between the OS and the boot
+    UUID <literal>4a67b082-0a4c-41cf-b6c7-440b29bb8c4f</literal>, for communication between the OS and the boot
     loader:</para>
 
     <variablelist class='efi-variables'>
diff -aruN old/man/systemd-cryptenroll.xml new/man/systemd-cryptenroll.xml
--- old/man/systemd-cryptenroll.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-cryptenroll.xml	2021-11-19 17:19:28.000000000 +0000
@@ -59,6 +59,23 @@
   </refsect1>
 
   <refsect1>
+    <title>Limitations</title>
+
+    <para>Note that currently when enrolling a new key of one of the five supported types listed above, it is
+    required to first provide a passphrase or recovery key (i.e. one of the latter two key types). For
+    example, it's currently not possible to unlock a device with a FIDO2 key in order to enroll a new FIDO2
+    key. Instead, in order to enroll a new FIDO2 key, it is necessary to provide an already enrolled regular
+    passphrase or recovery key. Thus, if in future key roll-over is desired it's generally recommended to
+    combine TPM2, FIDO2, PKCS#11 key enrollment with enrolling a regular passphrase or recovery key.</para>
+
+    <para>Also note that support for enrolling multiple FIDO2 tokens is currently not too useful, as while
+    unlocking <command>systemd-cryptsetup</command> cannot identify which token is currently plugged in and
+    thus does not know which authentication request to send to the device. This limitation does not apply to
+    tokens enrolled via PKCS#11 — because tokens of this type may be identified immediately, before
+    authentication.</para>
+  </refsect1>
+
+  <refsect1>
     <title>Options</title>
 
     <para>The following options are understood:</para>
@@ -84,7 +101,7 @@
         <term><option>--pkcs11-token-uri=</option><replaceable>URI</replaceable></term>
 
         <listitem><para>Enroll a PKCS#11 security token or smartcard (e.g. a YubiKey). Expects a PKCS#11
-        smart card URI referring to the token. Alternatively the special value <literal>auto</literal> may
+        smartcard URI referring to the token. Alternatively the special value <literal>auto</literal> may
         be specified, in order to automatically determine the URI of a currently plugged in security token
         (of which there must be exactly one). The special value <literal>list</literal> may be used to
         enumerate all suitable PKCS#11 tokens currently plugged in. The security token must contain an RSA
diff -aruN old/man/systemd.exec.xml new/man/systemd.exec.xml
--- old/man/systemd.exec.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.exec.xml	2021-11-19 17:19:28.000000000 +0000
@@ -241,7 +241,7 @@
         <para>This option is supported only for disk images that contain a single file system, without an
         enveloping partition table. Images that contain a GPT partition table should instead include both
         root file system and matching Verity data in the same image, implementing the <ulink
-        url="https://systemd.io/DISCOVERABLE_PARTITIONS">Discoverable Partition Specification</ulink>.</para>
+        url="https://systemd.io/DISCOVERABLE_PARTITIONS">Discoverable Partitions Specification</ulink>.</para>
 
         <xi:include href="system-only.xml" xpointer="singular"/></listitem>
       </varlistentry>
@@ -402,14 +402,15 @@
         <term><varname>ExtensionImages=</varname></term>
 
         <listitem><para>This setting is similar to <varname>MountImages=</varname> in that it mounts a file
-        system hierarchy from a block device node or loopback file, but instead of providing a destination path,
-        an overlay will be set up. This option expects a whitespace separated list of mount definitions. Each
-        definition consists of a source path, optionally followed by a colon and a list of mount options.</para>
+        system hierarchy from a block device node or loopback file, but instead of providing a destination
+        path, an overlay will be set up. This option expects a whitespace separated list of mount
+        definitions. Each definition consists of a source path, optionally followed by a colon and a list of
+        mount options.</para>
 
         <para>A read-only OverlayFS will be set up on top of <filename>/usr/</filename> and
-        <filename>/opt/</filename> hierarchies from the root. The order in which the images are listed
-        will determine the order in which the overlay is laid down: images specified first to last will result
-        in overlayfs layers bottom to top.</para>
+        <filename>/opt/</filename> hierarchies. The order in which the images are listed will determine the
+        order in which the overlay is laid down: images specified first to last will result in overlayfs
+        layers bottom to top.</para>
 
         <para>Mount options may be defined as a single comma-separated list of options, in which case they
         will be implicitly applied to the root partition on the image, or a series of colon-separated tuples
@@ -2304,7 +2305,7 @@
 
         <listitem><para>Sets environment variables for executed processes. Each line is unquoted using the
         rules described in "Quoting" section in
-        <citerefentry><refentrytitle>systemd.syntax</refentrytitle><manvolnum>5</manvolnum></citerefentry>
+        <citerefentry><refentrytitle>systemd.syntax</refentrytitle><manvolnum>7</manvolnum></citerefentry>
         and becomes a list of variable assignments. If you need to assign a value containing spaces or the
         equals sign to a variable, put quotes around the whole assignment. Variable expansion is not
         performed inside the strings and the <literal>$</literal> character has no special meaning. Specifier
diff -aruN old/man/systemd-firstboot.xml new/man/systemd-firstboot.xml
--- old/man/systemd-firstboot.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-firstboot.xml	2021-11-19 17:19:28.000000000 +0000
@@ -307,7 +307,7 @@
       <varlistentry>
         <term><literal>passwd.shell.root</literal></term>
 
-        <listitem><para>Specifies the shell binary to use for the specified account when creating it.
+        <listitem><para>Specifies the shell binary to use for the specified account.
         Equivalent to the credential of the same name defined for the
         <citerefentry><refentrytitle>systemd-sysusers.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>
         service.</para></listitem>
diff -aruN old/man/systemd.link.xml new/man/systemd.link.xml
--- old/man/systemd.link.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.link.xml	2021-11-19 17:19:28.000000000 +0000
@@ -457,7 +457,7 @@
         <term><varname>MTUBytes=</varname></term>
         <listitem>
           <para>The maximum transmission unit in bytes to set for the
-          device. The usual suffixes K, M, G, are supported and are
+          device. The usual suffixes K, M, G are supported and are
           understood to the base of 1024.</para>
         </listitem>
       </varlistentry>
@@ -465,7 +465,7 @@
         <term><varname>BitsPerSecond=</varname></term>
         <listitem>
           <para>The speed to set for the device, the value is rounded
-          down to the nearest Mbps. The usual suffixes K, M, G, are
+          down to the nearest Mbps. The usual suffixes K, M, G are
           supported and are understood to the base of 1000.</para>
         </listitem>
       </varlistentry>
@@ -662,49 +662,49 @@
       <varlistentry>
         <term><varname>ReceiveChecksumOffload=</varname></term>
         <listitem>
-          <para>Takes a boolean. If set to true, the hardware offload for checksumming of ingress
+          <para>Takes a boolean. If set to true, hardware offload for checksumming of ingress
           network packets is enabled. When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>TransmitChecksumOffload=</varname></term>
         <listitem>
-          <para>Takes a boolean. If set to true, the hardware offload for checksumming of egress
+          <para>Takes a boolean. If set to true, hardware offload for checksumming of egress
           network packets is enabled. When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>TCPSegmentationOffload=</varname></term>
         <listitem>
-          <para>Takes a boolean. If set to true, the TCP Segmentation Offload (TSO) is enabled.
+          <para>Takes a boolean. If set to true, TCP Segmentation Offload (TSO) is enabled.
           When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
        <varlistentry>
       <term><varname>TCP6SegmentationOffload=</varname></term>
         <listitem>
-          <para>Takes a boolean. If set to true, the TCP6 Segmentation Offload (tx-tcp6-segmentation) is enabled.
+          <para>Takes a boolean. If set to true, TCP6 Segmentation Offload (tx-tcp6-segmentation) is enabled.
           When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>GenericSegmentationOffload=</varname></term>
         <listitem>
-          <para>Takes a boolean. If set to true, the Generic Segmentation Offload (GSO) is enabled.
+          <para>Takes a boolean. If set to true, Generic Segmentation Offload (GSO) is enabled.
           When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>GenericReceiveOffload=</varname></term>
         <listitem>
-          <para>Takes a boolean. If set to true, the Generic Receive Offload (GRO) is enabled.
+          <para>Takes a boolean. If set to true, Generic Receive Offload (GRO) is enabled.
           When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>LargeReceiveOffload=</varname></term>
         <listitem>
-          <para>Takes a boolean. If set to true, the Large Receive Offload (LRO) is enabled.
+          <para>Takes a boolean. If set to true, Large Receive Offload (LRO) is enabled.
           When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
@@ -763,7 +763,7 @@
       <varlistentry>
         <term><varname>RxFlowControl=</varname></term>
         <listitem>
-          <para>Takes a boolean. When set, enables the receive flow control, also known as the ethernet
+          <para>Takes a boolean. When set, enables receive flow control, also known as the ethernet
           receive PAUSE message (generate and send ethernet PAUSE frames). When unset, the kernel's
           default will be used.</para>
         </listitem>
@@ -771,7 +771,7 @@
       <varlistentry>
         <term><varname>TxFlowControl=</varname></term>
         <listitem>
-          <para>Takes a boolean. When set, enables the transmit flow control, also known as the ethernet
+          <para>Takes a boolean. When set, enables transmit flow control, also known as the ethernet
           transmit PAUSE message (respond to received ethernet PAUSE frames). When unset, the kernel's
           default will be used.</para>
         </listitem>
@@ -779,7 +779,7 @@
       <varlistentry>
         <term><varname>AutoNegotiationFlowControl=</varname></term>
         <listitem>
-          <para>Takes a boolean. When set, the auto negotiation enables the interface to exchange state
+          <para>Takes a boolean. When set, auto negotiation enables the interface to exchange state
           advertisements with the connected peer so that the two devices can agree on the ethernet
           PAUSE configuration. When unset, the kernel's default will be used.</para>
         </listitem>
@@ -788,7 +788,7 @@
         <term><varname>GenericSegmentOffloadMaxBytes=</varname></term>
         <listitem>
           <para>Specifies the maximum size of a Generic Segment Offload (GSO) packet the
-          device should accept. The usual suffixes K, M, G, are supported and are
+          device should accept. The usual suffixes K, M, G are supported and are
           understood to the base of 1024. An unsigned integer in the range 1…65536.
           Defaults to unset.</para>
         </listitem>
@@ -796,8 +796,8 @@
       <varlistentry>
         <term><varname>GenericSegmentOffloadMaxSegments=</varname></term>
         <listitem>
-          <para>Specifies the maximum number of a Generic Segment Offload (GSO) segments the device should
-          accept.  An unsigned integer in the range 1…65535. Defaults to unset.</para>
+          <para>Specifies the maximum number of Generic Segment Offload (GSO) segments the device should
+          accept. An unsigned integer in the range 1…65535. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
diff -aruN old/man/systemd-machine-id-setup.xml new/man/systemd-machine-id-setup.xml
--- old/man/systemd-machine-id-setup.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-machine-id-setup.xml	2021-11-19 17:19:28.000000000 +0000
@@ -90,7 +90,7 @@
 
       <varlistentry>
         <term><option>--image=<replaceable>path</replaceable></option></term>
-        <listitem><para>Takes a path to a device node or refular file as argument. This is similar to
+        <listitem><para>Takes a path to a device node or regular file as argument. This is similar to
         <option>--root=</option> as described above, but operates on a disk image instead of a directory
         tree.</para></listitem>
       </varlistentry>
diff -aruN old/man/systemd.netdev.xml new/man/systemd.netdev.xml
--- old/man/systemd.netdev.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.netdev.xml	2021-11-19 17:19:28.000000000 +0000
@@ -390,7 +390,7 @@
         <term><varname>DefaultPVID=</varname></term>
         <listitem>
           <para>This specifies the default port VLAN ID of a newly attached bridge port.
-          Set this to an integer in the range 1–4094 or <literal>none</literal> to disable the PVID.</para>
+          Set this to an integer in the range 1…4094 or <literal>none</literal> to disable the PVID.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
@@ -460,7 +460,7 @@
       <varlistentry>
         <term><varname>Id=</varname></term>
         <listitem>
-          <para>The VLAN ID to use. An integer in the range 0–4094.
+          <para>The VLAN ID to use. An integer in the range 0…4094.
           This setting is compulsory.</para>
         </listitem>
       </varlistentry>
@@ -654,7 +654,7 @@
         <term><varname>TTL=</varname></term>
         <listitem>
           <para>A fixed Time To Live N on Virtual eXtensible Local Area Network packets.
-          Takes <literal>inherit</literal> or a number in the range 0–255. 0 is a special
+          Takes <literal>inherit</literal> or a number in the range 0…255. 0 is a special
           value meaning inherit the inner protocol's TTL value. <literal>inherit</literal>
           means that it will inherit the outer protocol's TTL value.</para>
         </listitem>
@@ -913,7 +913,7 @@
       <varlistentry>
         <term><varname>TunnelId=</varname></term>
         <listitem>
-          <para>Specifies the tunnel identifier. Takes an number in the range 1–4294967295. The value used
+          <para>Specifies the tunnel identifier. Takes an number in the range 1…4294967295. The value used
           must match the <literal>PeerTunnelId=</literal> value being used at the peer. This setting is
           compulsory.</para>
         </listitem>
@@ -1002,7 +1002,7 @@
       <varlistentry>
         <term><varname>SessionId=</varname></term>
         <listitem>
-          <para>Specifies the session identifier. Takes an number in the range 1–4294967295. The value used
+          <para>Specifies the session identifier. Takes an number in the range 1…4294967295. The value used
           must match the <literal>SessionId=</literal> value being used at the peer. This setting is
           compulsory.</para>
         </listitem>
@@ -1010,7 +1010,7 @@
       <varlistentry>
         <term><varname>PeerSessionId=</varname></term>
         <listitem>
-          <para>Specifies the peer session identifier. Takes an number in the range 1–4294967295.
+          <para>Specifies the peer session identifier. Takes an number in the range 1…4294967295.
           The value used must match the <literal>PeerSessionId=</literal> value being used at the peer.
           This setting is compulsory.</para>
         </listitem>
@@ -1234,7 +1234,7 @@
         <term><varname>TTL=</varname></term>
         <listitem>
           <para>A fixed Time To Live N on tunneled packets. N is a
-          number in the range 1–255. 0 is a special value meaning that
+          number in the range 1…255. 0 is a special value meaning that
           packets inherit the TTL value. The default value for IPv4
           tunnels is 0 (inherit). The default value for IPv6 tunnels is
           64.</para>
@@ -1256,7 +1256,7 @@
           It is only used for IPv6 tunnels.
           A flow label of zero is used to indicate packets that have
           not been labeled.
-          It can be configured to a value in the range 0–0xFFFFF, or be
+          It can be configured to a value in the range 0…0xFFFFF, or be
           set to <literal>inherit</literal>, in which case the original flowlabel is used.</para>
         </listitem>
       </varlistentry>
@@ -1673,15 +1673,15 @@
           <para>Sets a comma-separated list of IP (v4 or v6) addresses with CIDR masks
           from which this peer is allowed to send incoming traffic and to
           which outgoing traffic for this peer is directed.</para>
+
           <para>The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
           and ::/0 may be specified for matching all IPv6 addresses.</para>
-          <para>Note that this only affects "routing inside the network interface itself",
-          as in, which wireguard peer packets with a specific destination address are sent to,
-          and what source addresses are accepted from which peer.</para>
-          <para>To cause packets to be sent via wireguard in first place, a route needs
-          to be added, as well - either in the <literal>[Routes]</literal> section on the
-          <literal>.network</literal> matching the wireguard interface, or outside of networkd.
-          </para>
+
+          <para>Note that this only affects <emphasis>routing inside the network interface itself</emphasis>,
+          i.e. the packets that pass through the tunnel itself. To cause packets to be sent via the tunnel in
+          the first place, an appropriate route needs to be added as well — either in the
+          <literal>[Routes]</literal> section on the <literal>.network</literal> matching the wireguard
+          interface, or externally to <filename>systemd-networkd</filename>.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
@@ -1823,7 +1823,7 @@
         <term><varname>AdUserPortKey=</varname></term>
         <listitem>
           <para>Specifies the 802.3ad user defined portion of the port key. Takes a number in the range
-          0–1023.</para>
+          0…1023.</para>
         </listitem>
       </varlistentry>
 
@@ -2036,9 +2036,9 @@
 
   <refsect1>
     <title>[BatmanAdvanced] Section Options</title>
-    <para>The [BatmanAdvanced] section only applies for
-    netdevs of kind <literal>batadv</literal> and accepts the
-    following keys:</para>
+
+    <para>The [BatmanAdvanced] section only applies for netdevs of kind <literal>batadv</literal> and accepts
+    the following keys:</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
diff -aruN old/man/systemd.network.xml new/man/systemd.network.xml
--- old/man/systemd.network.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.network.xml	2021-11-19 17:19:28.000000000 +0000
@@ -132,6 +132,7 @@
         <xi:include href="systemd.link.xml" xpointer="kernel-command-line" />
         <xi:include href="systemd.link.xml" xpointer="kernel-version" />
         <xi:include href="systemd.link.xml" xpointer="architecture" />
+        <xi:include href="systemd.link.xml" xpointer="firmware" />
       </variablelist>
 
   </refsect1>
@@ -999,14 +1000,6 @@
         </listitem>
       </varlistentry>
       <varlistentry>
-        <term><varname>Xfrm=</varname></term>
-        <listitem>
-          <para>The name of the xfrm to create on the link. See
-            <citerefentry><refentrytitle>systemd.netdev</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
-            This option may be specified more than once.</para>
-        </listitem>
-      </varlistentry>
-      <varlistentry>
         <term><varname>KeepConfiguration=</varname></term>
         <listitem>
           <para>Takes a boolean or one of <literal>static</literal>, <literal>dhcp-on-stop</literal>,
@@ -1246,7 +1239,9 @@
           <term><varname>Priority=</varname></term>
           <listitem>
             <para>Specifies the priority of this rule. <varname>Priority=</varname> is an unsigned
-            integer. Higher number means lower priority, and rules get processed in order of increasing number.</para>
+            integer in the range 0…4294967295. Higher number means lower priority, and rules get
+            processed in order of increasing number. Defaults to unset, and the kernel will pick
+            a value dynamically.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
@@ -1431,7 +1426,7 @@
           <term><varname>Metric=</varname></term>
           <listitem>
             <para>The metric of the route. Takes an unsigned integer in the range 0…4294967295.
-            Defaluts to unset, and the kernel's default will be used.</para>
+            Defaults to unset, and the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
@@ -1623,9 +1618,10 @@
           <term><varname>SendHostname=</varname></term>
           <listitem>
             <para>When true (the default), the machine's hostname (or the value specified with
-            <varname>Hostname=</varname> below) will be sent to the DHCP server. Note that the hostname must
-            consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a
-            valid DNS domain name. Otherwise, the hostname is not sent even if this option is true.</para>
+            <varname>Hostname=</varname>, described below) will be sent to the DHCP server. Note that the
+            hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be
+            formatted as a valid DNS domain name. Otherwise, the hostname is not sent even if this option is
+            true.</para>
           </listitem>
         </varlistentry>
 
@@ -1919,8 +1915,8 @@
           <term><varname>FallbackLeaseLifetimeSec=</varname></term>
           <listitem>
             <para>Allows to set DHCPv4 lease lifetime when DHCPv4 server does not send the lease lifetime.
-            Takes one of <literal>forever</literal> or <literal>infinity</literal> means that the address
-            never expires. Defaults to unset.</para>
+            Takes one of <literal>forever</literal> or <literal>infinity</literal>. The latter means that the
+            address never expires. Defaults to unset.</para>
           </listitem>
         </varlistentry>
 
@@ -2347,9 +2343,9 @@
       <varlistentry>
         <term><varname>ServerAddress=</varname></term>
         <listitem><para>Specifies server address for the DHCP server. Takes an IPv4 address with prefix
-        length, e.g., <literal>192.168.0.1/24</literal>. This setting may be useful when the link which
-        DHCP server running on has multiple static addresses. When unset, one of static addresses in
-        the link will be automatically selected. Defaults to unset.</para></listitem>
+        length, for example <literal>192.168.0.1/24</literal>. This setting may be useful when the link on
+        which the DHCP server is running has multiple static addresses. When unset, one of static addresses
+        in the link will be automatically selected. Defaults to unset.</para></listitem>
       </varlistentry>
 
       <varlistentry>
@@ -2529,23 +2525,22 @@
 
   <refsect1>
     <title>[DHCPServerStaticLease] Section Options</title>
-    <para>The <literal>[DHCPServerStaticLease]</literal> section configures a static DHCP lease to
-    assign a pre-set IPv4 address to a specific device based on its MAC address. This section can be
-    specified multiple times.</para>
+    <para>The <literal>[DHCPServerStaticLease]</literal> section configures a static DHCP lease to assign a
+    fixed IPv4 address to a specific device based on its MAC address. This section can be specified multiple
+    times.</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>MACAddress=</varname></term>
 
-        <listitem><para>The hardware address of a device which should be assigned IPv4 address
-        specified in <varname>Address=</varname>. This key is mandatory.</para></listitem>
+        <listitem><para>The hardware address of a device to match. This key is mandatory.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Address=</varname></term>
 
-        <listitem><para>IPv4 address that should be assigned to a device with a hardware address
-        specified in <varname>MACAddress=</varname>. This key is mandatory.</para></listitem>
+        <listitem><para>The IPv4 address that should be assigned to the device that was matched with
+        <varname>MACAddress=</varname>. This key is mandatory.</para></listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
diff -aruN old/man/systemd-nspawn.xml new/man/systemd-nspawn.xml
--- old/man/systemd-nspawn.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-nspawn.xml	2021-11-19 17:19:28.000000000 +0000
@@ -1375,12 +1375,12 @@
         </orderedlist>
 
         <para>The combination of the three operations above ensures that it is possible to log into the
-        host's user account inside the container as if it was local to the container. The user is only mapped
-        transiently, while the container is running and the mapping itself does not result in persistent
-        changes to the container (except maybe for generated log messages at login time, and similar). Note
-        that in particular the UID/GID assignment in the container is not made persistently. If the user is
-        mapped transiently, it is best to not allow the user to make persistent changes to the container. If
-        the user leaves files or directories owned by the user, and those UIDs/GIDs are recycled during later
+        container using the same account information as on the host. The user is only mapped transiently,
+        while the container is running, and the mapping itself does not result in persistent changes to the
+        container (except maybe for log messages generated at login time, and similar). Note that in
+        particular the UID/GID assignment in the container is not made persistently. If the user is mapped
+        transiently, it is best to not allow the user to make persistent changes to the container. If the
+        user leaves files or directories owned by the user, and those UIDs/GIDs are reused during later
         container invocations (possibly with a different <option>--bind-user=</option> mapping), those files
         and directories will be accessible to the "new" user.</para>
 
@@ -1581,9 +1581,9 @@
         -b</programlisting>
 
         <para>The above command line will invoke the specified image file <filename>image.raw</filename> in
-        volatile mode, i.e with an empty <filename>/etc/</filename> and <filename>/var/</filename>, so that
-        the container's payload recognizes this as first boot condition, and will invoke
-        <filename>systemd-firstboot.service</filename>, which then read the two passed credentials to
+        volatile mode, i.e. with empty <filename>/etc/</filename> and <filename>/var/</filename>.  The
+        container payload will recognize this as a first boot, and will invoke
+        <filename>systemd-firstboot.service</filename>, which then reads the two passed credentials to
         configure the system's initial locale and root password.</para>
         </listitem>
         </varlistentry>
diff -aruN old/man/systemd.nspawn.xml new/man/systemd.nspawn.xml
--- old/man/systemd.nspawn.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.nspawn.xml	2021-11-19 17:19:28.000000000 +0000
@@ -202,7 +202,7 @@
         capabilities (see
         <citerefentry project='man-pages'><refentrytitle>capabilities</refentrytitle><manvolnum>7</manvolnum></citerefentry>
         for details). The <varname>AmbientCapability=</varname> setting
-        specifies capability which will be passed to to started program
+        specifies capability which will be passed to the started program
         in the inheritable and ambient capability sets. This will grant
         these capabilities to this process. This setting correspond to
         the <option>--ambient-capability=</option> command line switch.
diff -aruN old/man/systemd-portabled.service.xml new/man/systemd-portabled.service.xml
--- old/man/systemd-portabled.service.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-portabled.service.xml	2021-11-19 17:19:28.000000000 +0000
@@ -35,8 +35,8 @@
     <para>Most of <command>systemd-portabled</command>'s functionality is accessible through the
     <citerefentry><refentrytitle>portablectl</refentrytitle><manvolnum>1</manvolnum></citerefentry> command.</para>
 
-    <para>See the <ulink url="https://systemd.io/PORTABLE_SERVICES">Portable
-    Services Documentation</ulink> for details about the concepts this service implements.</para>
+    <para>See <ulink url="https://systemd.io/PORTABLE_SERVICES">Portable Services</ulink> for details about
+    the concepts this service implements.</para>
   </refsect1>
 
   <refsect1>
diff -aruN old/man/systemd.preset.xml new/man/systemd.preset.xml
--- old/man/systemd.preset.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.preset.xml	2021-11-19 17:19:28.000000000 +0000
@@ -207,7 +207,7 @@
       <citerefentry><refentrytitle>systemd-delta</refentrytitle><manvolnum>1</manvolnum></citerefentry>
     </para>
 
-    <para><citerefentry><refentrytitle>daemon</refentrytitle><manvolnum>8</manvolnum></citerefentry>
+    <para><citerefentry><refentrytitle>daemon</refentrytitle><manvolnum>7</manvolnum></citerefentry>
     has a discussion of packaging scriptlets.</para>
 
     <para>Fedora page introducing the use of presets:
diff -aruN old/man/systemd-resolved.service.xml new/man/systemd-resolved.service.xml
--- old/man/systemd-resolved.service.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-resolved.service.xml	2021-11-19 17:19:28.000000000 +0000
@@ -144,7 +144,7 @@
       turn. Additionally, lookup of single-label names via unicast DNS may be enabled with the
       <varname>ResolveUnicastSingleLabel=yes</varname> setting. The details of which servers are queried and
       how the final reply is chosen are described below. Note that this means that address queries for
-      single-label names are never sent out to remote DNS servers by default, and resoulution is only
+      single-label names are never sent out to remote DNS servers by default, and resolution is only
       possible if search domains are defined.</para></listitem>
 
       <listitem><para>Multi-label names with the domain suffix <literal>.local</literal> are resolved using
@@ -275,7 +275,7 @@
       fragility in both directions: a valid global name could be obscured by a local name, and resolution of
       a relative local name could suddenly break when a new top-level domain is created, or when a new
       subdomain of a top-level domain in registered. Resolving any given name as either relative or absolute
-      avoids this ambiguity.)</para></footnote></para></listitem>
+      avoids this ambiguity.</para></footnote></para></listitem>
 
       <listitem><para>This resolver has a notion of the special <literal>.local</literal> domain used for
       MulticastDNS, and will not route queries with that suffix to unicast DNS servers unless explicitly
diff -aruN old/man/systemd.service.xml new/man/systemd.service.xml
--- old/man/systemd.service.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.service.xml	2021-11-19 17:19:28.000000000 +0000
@@ -1134,7 +1134,7 @@
     <literal>\;</literal>.</para>
 
     <para>Each command line is unquoted using the rules described in "Quoting" section in
-    <citerefentry><refentrytitle>systemd.syntax</refentrytitle><manvolnum>5</manvolnum></citerefentry>. The
+    <citerefentry><refentrytitle>systemd.syntax</refentrytitle><manvolnum>7</manvolnum></citerefentry>. The
     first item becomes the command to execute, and the subsequent items the arguments.</para>
 
     <para>This syntax is inspired by shell syntax, but only the meta-characters and expansions
diff -aruN old/man/systemd-sysext.xml new/man/systemd-sysext.xml
--- old/man/systemd-sysext.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-sysext.xml	2021-11-19 17:19:28.000000000 +0000
@@ -46,7 +46,7 @@
     operating system tree. When one or more system extension images are activated, their
     <filename>/usr/</filename> and <filename>/opt/</filename> hierarchies are combined via
     <literal>overlayfs</literal> with the same hierarchies of the host OS, and the host
-    <filename>/usr/</filename> and <filename>/opt</filename> overmounted with it ("merging"). When they are
+    <filename>/usr/</filename> and <filename>/opt/</filename> overmounted with it ("merging"). When they are
     deactivated, the mount point is disassembled — again revealing the unmodified original host version of
     the hierarchy ("unmerging"). Merging thus makes the extension's resources suddenly appear below the
     <filename>/usr/</filename> and <filename>/opt/</filename> hierarchies as if they were included in the
@@ -71,7 +71,7 @@
     <orderedlist>
       <listitem><para>Plain directories or btrfs subvolumes containing the OS tree</para></listitem>
       <listitem><para>Disk images with a GPT disk label, following the <ulink
-      url="https://systemd.io/DISCOVERABLE_PARTITIONS">Discoverable Partition Specification</ulink></para></listitem>
+      url="https://systemd.io/DISCOVERABLE_PARTITIONS">Discoverable Partitions Specification</ulink></para></listitem>
       <listitem><para>Disk images lacking a partition table, with a naked Linux file system (e.g. squashfs or ext4)</para></listitem>
     </orderedlist>
 
@@ -127,13 +127,15 @@
     <title>Uses</title>
 
     <para>The primary use case for system images are immutable environments where debugging and development
-    tools shall optionally be made available, but not included in the immutable base OS image itself
-    (e.g. <filename>strace</filename> and <filename>gdb</filename> shall be an optionally installable
-    addition in order to make debugging/development easier). System extension images should not be
-    misunderstood as a generic software packaging framework, as no dependency scheme is available: system
-    extensions should carry all files they need themselves, except for those already shipped in the
-    underlying host system image. Typically, system extension images are built at the same time as the base
-    OS image — within the same build system.</para>
+    tools shall optionally be made available, but not included in the immutable base OS image itself (e.g.
+    <citerefentry project='man-pages'><refentrytitle>strace</refentrytitle><manvolnum>1</manvolnum></citerefentry>
+    and
+    <citerefentry project='man-pages'><refentrytitle>gdb</refentrytitle><manvolnum>1</manvolnum></citerefentry>
+    shall be an optionally installable addition in order to make debugging/development easier). System
+    extension images should not be misunderstood as a generic software packaging framework, as no dependency
+    scheme is available: system extensions should carry all files they need themselves, except for those
+    already shipped in the underlying host system image. Typically, system extension images are built at the
+    same time as the base OS image — within the same build system.</para>
 
     <para>Another use case for the system extension concept is temporarily overriding OS supplied resources
     with newer ones, for example to install a locally compiled development version of some low-level
diff -aruN old/man/systemd-system.conf.xml new/man/systemd-system.conf.xml
--- old/man/systemd-system.conf.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-system.conf.xml	2021-11-19 17:19:28.000000000 +0000
@@ -262,7 +262,7 @@
         names in status messages (e.g. <literal>systemd-journald.service</literal>), instead of the longer
         and more informative descriptions set with <varname>Description=</varname> (e.g. <literal>Journal
         Logging Service</literal>). If <option>combined</option>, the system manager will use both unit names
-        and descriptions in status messages (e.g. <literal>systemdmd-jouranld.service - Journal Logging
+        and descriptions in status messages (e.g. <literal>systemd-journald.service - Journal Logging
         Service</literal>).</para>
 
         <para>See
diff -aruN old/man/systemd.unit.xml new/man/systemd.unit.xml
--- old/man/systemd.unit.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.unit.xml	2021-11-19 17:19:28.000000000 +0000
@@ -1535,7 +1535,7 @@
         <varlistentry>
           <term><varname>ConditionControlGroupController=</varname></term>
 
-          <listitem><para>Check whether given cgroup controllers (eg. <literal>cpu</literal>) are available
+          <listitem><para>Check whether given cgroup controllers (e.g. <literal>cpu</literal>) are available
           for use on the system or whether the legacy v1 cgroup or the modern v2 cgroup hierarchy is used.
           </para>
 
diff -aruN old/man/systemd-userdbd.service.xml new/man/systemd-userdbd.service.xml
--- old/man/systemd-userdbd.service.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-userdbd.service.xml	2021-11-19 17:19:28.000000000 +0000
@@ -34,14 +34,14 @@
     JSON user/group records from classic UNIX/glibc NSS user/group records in order to provide full backwards
     compatibility. It may also pick up statically defined JSON user/group records from drop-in files in
     <filename>/etc/userdb/</filename>, <filename>/run/userdb/</filename>,
-    <filename>/run/host/userdb/</filename> and <filename>/use/lib/userdb/</filename>.</para>
+    <filename>/run/host/userdb/</filename> and <filename>/usr/lib/userdb/</filename>.</para>
 
     <para>Most of <command>systemd-userdbd</command>'s functionality is accessible through the
     <citerefentry><refentrytitle>userdbctl</refentrytitle><manvolnum>1</manvolnum></citerefentry>
     command.</para>
 
     <para>The user and group records this service provides access to follow the <ulink
-    url="https://systemd.io/USER_RECORD">JSON User Record</ulink> and <ulink
+    url="https://systemd.io/USER_RECORD">JSON User Records</ulink> and <ulink
     url="https://systemd.io/GROUP_RECORD">JSON Group Record</ulink> definitions. This service implements the
     <ulink url="https://systemd.io/USER_GROUP_API">User/Group Record Lookup API via Varlink</ulink>, and
     multiplexes access other services implementing this API, too. It is thus both server and client of this
diff -aruN old/man/systemd-veritysetup-generator.xml new/man/systemd-veritysetup-generator.xml
--- old/man/systemd-veritysetup-generator.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-veritysetup-generator.xml	2021-11-19 17:19:28.000000000 +0000
@@ -17,7 +17,7 @@
 
   <refnamediv>
     <refname>systemd-veritysetup-generator</refname>
-    <refpurpose>Unit generator for integrity protected block devices</refpurpose>
+    <refpurpose>Unit generator for verity protected block devices</refpurpose>
   </refnamediv>
 
   <refsynopsisdiv>
@@ -28,7 +28,7 @@
     <title>Description</title>
 
     <para><filename>systemd-veritysetup-generator</filename> is a generator that translates kernel command line options
-    configuring integrity-protected block devices (verity) into native systemd units early at boot and when
+    configuring verity protected block devices into native systemd units early at boot and when
     configuration of the system manager is reloaded. This will create
     <citerefentry><refentrytitle>systemd-veritysetup@.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>
     units as necessary.</para>
@@ -66,7 +66,7 @@
         data devices to use are automatically derived from the specified hash value. Specifically, the data partition
         device is looked for under a GPT partition UUID derived from the first 128bit of the root hash, the hash
         partition device is looked for under a GPT partition UUID derived from the last 128bit of the root hash. Hence
-        it is usually sufficient to specify the root hash to boot from an integrity protected root file system, as
+        it is usually sufficient to specify the root hash to boot from a verity protected root file system, as
         device paths are automatically determined from it — as long as the partition table is properly set up.</para>
         </listitem>
       </varlistentry>
@@ -76,7 +76,7 @@
         <term><varname>systemd.verity_root_hash=</varname></term>
 
         <listitem><para>These two settings take block device paths as arguments and may be used to explicitly
-        configure the data partition and hash partition to use for setting up the integrity protection for the root file
+        configure the data partition and hash partition to use for setting up the verity protection for the root file
         system. If not specified, these paths are automatically derived from the <varname>roothash=</varname> argument
         (see above).</para></listitem>
       </varlistentry>
diff -aruN old/man/systemd-veritysetup@.service.xml new/man/systemd-veritysetup@.service.xml
--- old/man/systemd-veritysetup@.service.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd-veritysetup@.service.xml	2021-11-19 17:19:28.000000000 +0000
@@ -18,7 +18,7 @@
   <refnamediv>
     <refname>systemd-veritysetup@.service</refname>
     <refname>systemd-veritysetup</refname>
-    <refpurpose>Disk integrity protection logic</refpurpose>
+    <refpurpose>Disk verity protection logic</refpurpose>
   </refnamediv>
 
   <refsynopsisdiv>
@@ -29,13 +29,60 @@
   <refsect1>
     <title>Description</title>
 
-    <para><filename>systemd-veritysetup@.service</filename> is a service responsible for setting up integrity
-    protection (verity) block devices. It should be instantiated for each device that requires integrity
+    <para><filename>systemd-veritysetup@.service</filename> is a service responsible for setting up verity
+    protection block devices. It should be instantiated for each device that requires verity
     protection.</para>
 
     <para>At early boot and when the system manager configuration is reloaded kernel command line configuration for
-    integrity protected block devices is translated into <filename>systemd-veritysetup@.service</filename> units by
+    verity protected block devices is translated into <filename>systemd-veritysetup@.service</filename> units by
     <citerefentry><refentrytitle>systemd-veritysetup-generator</refentrytitle><manvolnum>8</manvolnum></citerefentry>.</para>
+
+    <para><filename>systemd-veritysetup@.service</filename> calls <command>systemd-veritysetup</command>.</para>
+  </refsect1>
+
+  <refsect1>
+    <title>Commands</title>
+
+    <para>The following commands are understood by <command>systemd-veritysetup</command>:</para>
+
+    <variablelist>
+      <varlistentry>
+        <term>
+          <option>attach</option>
+          <replaceable>volume</replaceable>
+          <replaceable>datadevice</replaceable>
+          <replaceable>hashdevice</replaceable>
+          <replaceable>roothash</replaceable>
+          [<replaceable>option</replaceable>...]
+        </term>
+
+        <listitem><para>Create a block device <replaceable>volume</replaceable> using
+        <replaceable>datadevice</replaceable> and <replaceable>hashdevice</replaceable> as the backing
+        devices. <replaceable>roothash</replaceable> forms the root of the tree of hashes stored on
+        <replaceable>hashdevice</replaceable>. See
+        <ulink url="https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html">
+          Kernel dm-verity</ulink> documentation for details.
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>
+          <option>detach</option>
+          <replaceable>volume</replaceable>
+        </term>
+
+        <listitem><para>Detach (destroy) the block device
+        <replaceable>volume</replaceable>.</para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>
+          <option>help</option>
+        </term>
+
+        <listitem><para>Print short information about command syntax.</para></listitem>
+      </varlistentry>
+    </variablelist>
   </refsect1>
 
   <refsect1>
diff -aruN old/man/systemd.xml new/man/systemd.xml
--- old/man/systemd.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/systemd.xml	2021-11-19 17:19:28.000000000 +0000
@@ -74,8 +74,8 @@
     configuration files, whose syntax and basic set of options is
     described in
     <citerefentry><refentrytitle>systemd.unit</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
-    however some are created automatically from other configuration,
-    dynamically from system state or programmatically at runtime.
+    however some are created automatically from other configuration
+    files, dynamically from system state or programmatically at runtime.
     Units may be "active" (meaning started, bound, plugged in, …,
     depending on the unit type, see below), or "inactive" (meaning
     stopped, unbound, unplugged, …), as well as in the process of
diff -aruN old/man/timedatectl.xml new/man/timedatectl.xml
--- old/man/timedatectl.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/timedatectl.xml	2021-11-19 17:19:28.000000000 +0000
@@ -126,8 +126,9 @@
         <listitem><para>Takes a boolean argument. Controls whether network time synchronization is active and
         enabled (if available). If the argument is true, this enables and starts the first existing network
         synchronization service. If the argument is false, then this disables and stops the known network
-        synchronization services. The way that the list of services is built is described below.</para>
-        </listitem>
+        synchronization services. The way that the list of services is built is described in
+        <citerefentry><refentrytitle>systemd-timedated.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
+        </para></listitem>
       </varlistentry>
 
     </variablelist>
diff -aruN old/man/tmpfiles.d.xml new/man/tmpfiles.d.xml
--- old/man/tmpfiles.d.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/tmpfiles.d.xml	2021-11-19 17:19:28.000000000 +0000
@@ -550,6 +550,7 @@
 
     <refsect2>
       <title>Age</title>
+
       <para>The date field, when set, is used to decide what files to
       delete when cleaning. If a file or directory is older than the
       current time minus the age field, it is deleted. The field
@@ -582,10 +583,9 @@
       and <varname>X</varname>. If omitted or set to
       <literal>-</literal>, no automatic clean-up is done.</para>
 
-      <para>If the age field starts with a tilde character
-      <literal>~</literal>, the clean-up is only applied to files and
-      directories one level inside the directory specified, but not
-      the files and directories immediately inside it.</para>
+      <para>If the age field starts with a tilde character <literal>~</literal>, clean-up is only applied to
+      files and directories one level inside the directory specified, but not the files and directories
+      immediately inside it.</para>
 
       <para>The age of a file system entry is determined from its last
       modification timestamp (mtime), its last access timestamp (atime),
@@ -595,30 +595,25 @@
       the age field. To restrict the deletion based on particular type
       of file timestamps, the age-by argument can be used.</para>
 
-      <para>The age-by argument, when (optionally) specified along
-      with age will check if the file system entry has aged by the
-      type of file timestamp(s) provided. It can be specified by
-      prefixing the age argument with a set of file timestamp types
-      followed by a colon character <literal>:</literal>, i.e.,
-      <literal><replaceable>age-by</replaceable>:<replaceable>cleanup-age</replaceable></literal>.
-      The argument can be a set of:
-      <constant>a</constant> (<constant>A</constant> for directories),
-      <constant>b</constant> (<constant>B</constant> for directories),
-      <constant>c</constant> (<constant>C</constant> for directories; ignored by default), or
-      <constant>m</constant> (<constant>M</constant> for directories),
-      indicating access, creation, last status change, and last
-      modification times of a file system entry respectively. See
-      <citerefentry project='man-pages'><refentrytitle>statx</refentrytitle><manvolnum>2</manvolnum></citerefentry>
-      file timestamp fields for more details.</para>
-
-      <para>If unspecified, the age-by field defaults to
-      <constant>abcmABM</constant>,
-      i.e., by default all file timestamps are taken into consideration,
-      with the exception of the last status change timestamp (ctime) for
-      directories. This is because the aging logic itself will alter the
-      ctime whenever it deletes a file inside it. To ensure that running
-      the aging logic does not feed back into the next iteration of it,
-      ctime for directories is ignored by default.</para>
+      <para>The age-by argument overrides the timestamp types to be used for the age check. It can be
+      specified by prefixing the age argument with a sequence of characters to specify the timestamp types
+      and a colon (<literal>:</literal>):
+      <literal><replaceable>age-by</replaceable>...:<replaceable>cleanup-age</replaceable></literal>.  The
+      argument can consist of <constant>a</constant> (<constant>A</constant> for directories),
+      <constant>b</constant> (<constant>B</constant> for directories), <constant>c</constant>
+      (<constant>C</constant> for directories), or <constant>m</constant> (<constant>M</constant> for
+      directories). Those respectively indicate access, creation, last status change, and last modification
+      time of a file system entry. The lower-case letter signifies that the given timestamp type should be
+      considered for files, while the upper-case letter signifies that the given timestamp type should be
+      considered for directories. See <citerefentry
+      project='man-pages'><refentrytitle>statx</refentrytitle><manvolnum>2</manvolnum></citerefentry> file
+      timestamp fields for more details about timestamp types.</para>
+
+      <para>If not specified, the age-by field defaults to <constant>abcmABM</constant>, i.e. by default all
+      file timestamps are taken into consideration, with the exception of the last status change timestamp
+      (ctime) for directories. This is because the aging logic itself will alter the ctime whenever it
+      deletes a file inside it. To ensure that running the aging logic does not feed back into the next
+      iteration of itself, ctime for directories is ignored by default.</para>
 
       <para>For example:<programlisting>
 # Files created and modified, and directories accessed more than
diff -aruN old/man/userdbctl.xml new/man/userdbctl.xml
--- old/man/userdbctl.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/userdbctl.xml	2021-11-19 17:19:28.000000000 +0000
@@ -42,7 +42,7 @@
     url="https://systemd.io/USER_GROUP_API">User/Group Record Lookup API via Varlink</ulink>, and may also
     pick up drop-in JSON user and group records from <filename>/etc/userdb/</filename>,
     <filename>/run/userdb/</filename>, <filename>/run/host/userdb/</filename>,
-    <filename>/use/lib/userdb/</filename>.</para>
+    <filename>/usr/lib/userdb/</filename>.</para>
   </refsect1>
 
   <refsect1>
@@ -104,7 +104,7 @@
 
         <listitem><para>Controls whether to include user/group lookups in the output that are defined using
         drop-in files in <filename>/etc/userdb/</filename>, <filename>/run/userdb/</filename>,
-        <filename>/run/host/userdb/</filename>, <filename>/use/lib/userdb/</filename>. If
+        <filename>/run/host/userdb/</filename>, <filename>/usr/lib/userdb/</filename>. If
         <option>--with-dropin=no</option> is used these records are suppressed. If
         <option>--with-dropin=yes</option> is specified such users/groups are included in the output (which
         is the default).</para></listitem>
@@ -260,7 +260,7 @@
         <citerefentry><refentrytitle>systemd-userdbd.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>
         and picks up JSON user/group records from <filename>/etc/userdb/</filename>,
         <filename>/run/userdb/</filename>, <filename>/run/host/userdb/</filename>,
-        <filename>/use/lib/userdb/</filename>.</para></listitem>
+        <filename>/usr/lib/userdb/</filename>.</para></listitem>
       </varlistentry>
 
     </variablelist>
diff -aruN old/man/veritytab.xml new/man/veritytab.xml
--- old/man/veritytab.xml	2021-07-07 18:41:29.000000000 +0100
+++ new/man/veritytab.xml	2021-11-19 17:19:28.000000000 +0000
@@ -33,12 +33,12 @@
     <title>Description</title>
 
     <para>The <filename>/etc/veritytab</filename> file describes
-    verity integrity protected block devices that are set up during
+    verity protected block devices that are set up during
     system boot.</para>
 
     <para>Empty lines and lines starting with the <literal>#</literal>
     character are ignored. Each of the remaining lines describes one
-    verity integrity protected block device. Fields are delimited by
+    verity protected block device. Fields are delimited by
     white space.</para>
 
     <para>Each line is in the form<programlisting><replaceable>volume-name</replaceable> <replaceable>data-device</replaceable> <replaceable>hash-device</replaceable> <replaceable>roothash</replaceable> <replaceable>options</replaceable></programlisting>
@@ -65,7 +65,7 @@
         <term><option>restart-on-corruption</option></term>
         <term><option>panic-on-corruption</option></term>
 
-        <listitem><para>Defines what to do if data integrity problem is detected (data corruption). Without these
+        <listitem><para>Defines what to do if a data verity problem is detected (data corruption). Without these
         options kernel fails the IO operation with I/O error. With <literal>--ignore-corruption</literal> option the
         corruption is only logged. With <literal>--restart-on-corruption</literal> or
         <literal>--panic-on-corruption</literal> the kernel is restarted (panicked) immediately.
@@ -149,18 +149,18 @@
       <varlistentry>
         <term><option>x-initrd.attach</option></term>
 
-        <listitem><para>Setup this verity integrity protected block device in the initramfs, similarly to
+        <listitem><para>Setup this verity protected block device in the initramfs, similarly to
         <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>
         units marked with <option>x-initrd.mount</option>.</para>
 
         <para>Although it's not necessary to mark the mount entry for the root file system with
         <option>x-initrd.mount</option>, <option>x-initrd.attach</option> is still recommended with
-        the verity integrity protected block device containing the root file system as otherwise systemd
+        the verity protected block device containing the root file system as otherwise systemd
         will attempt to detach the device during the regular system shutdown while it's still in
         use. With this option the device will still be detached but later after the root file
         system is unmounted.</para>
 
-        <para>All other verity integrity protected block devices that contain file systems mounted in the
+        <para>All other verity protected block devices that contain file systems mounted in the
         initramfs should use this option.</para>
         </listitem>
       </varlistentry>
@@ -176,7 +176,7 @@
     <title>Examples</title>
     <example>
       <title>/etc/veritytab example</title>
-      <para>Set up two verity integrity protected block devices. One using device blocks, another using files.</para>
+      <para>Set up two verity protected block devices. One using device blocks, another using files.</para>
 
       <programlisting>usr  PARTUUID=783e45ae-7aa3-484a-beef-a80ff9c19cbb PARTUUID=21dc1dfe-4c33-8b48-98a9-918a22eb3e37 36e3f740ad502e2c25e2a23d9c7c17bf0fdad2300b7580842d4b7ec1fb0fa263 auto
 data /etc/data /etc/hash a5ee4b42f70ae1f46a08a7c92c2e0a20672ad2f514792730f5d49d7606ab8fdf auto
diff -aruN old/meson.build new/meson.build
--- old/meson.build	2021-07-07 18:41:29.000000000 +0100
+++ new/meson.build	2021-11-19 17:19:28.000000000 +0000
@@ -35,7 +35,7 @@
 
 want_ossfuzz = get_option('oss-fuzz')
 want_libfuzzer = get_option('llvm-fuzz')
-if want_ossfuzz + want_libfuzzer > 1
+if want_ossfuzz and want_libfuzzer
         error('only one of oss-fuzz or llvm-fuzz can be specified')
 endif
 
@@ -2493,8 +2493,9 @@
 
 if conf.get('ENABLE_LOCALED') == 1
         if conf.get('HAVE_XKBCOMMON') == 1
-                # logind will load libxkbcommon.so dynamically on its own
-                deps = [libdl]
+                # logind will load libxkbcommon.so dynamically on its own, but we still
+                # need to specify where the headers are
+                deps = [libdl, libxkbcommon.partial_dependency(compile_args: true)]
         else
                 deps = []
         endif
diff -aruN old/meson_options.txt new/meson_options.txt
--- old/meson_options.txt	2021-07-07 18:41:29.000000000 +0100
+++ new/meson_options.txt	2021-11-19 17:19:28.000000000 +0000
@@ -197,7 +197,7 @@
        choices : ['legacy', 'hybrid', 'unified'], value : 'unified',
        description : 'default cgroup hierarchy')
 option('default-net-naming-scheme', type : 'combo',
-       choices : ['latest', 'v238', 'v239', 'v240'],
+       choices : ['latest', 'v238', 'v239', 'v240', 'v241', 'v243', 'v245', 'v247', 'v249'],
        description : 'default net.naming-scheme= value')
 option('status-unit-format-default', type : 'combo',
        choices : ['description', 'name', 'combined'],
diff -aruN old/.mkosi/mkosi.opensuse new/.mkosi/mkosi.opensuse
--- old/.mkosi/mkosi.opensuse	2021-07-07 18:41:29.000000000 +0100
+++ new/.mkosi/mkosi.opensuse	2021-11-19 17:19:28.000000000 +0000
@@ -36,7 +36,7 @@
         pcre-devel
         python3
         python3-lxml
-        python3-jinja2
+        python3-Jinja2
         qrencode-devel
         system-user-nobody
         systemd-sysvinit
@@ -60,6 +60,7 @@
         libapparmor1
         libcrypt1
         libcryptsetup12
+        libgcrypt20
         libkmod2
         liblz4-1
         libmount1
diff -aruN old/NEWS new/NEWS
--- old/NEWS	2021-07-07 18:41:29.000000000 +0100
+++ new/NEWS	2021-11-19 17:19:28.000000000 +0000
@@ -3867,6 +3867,9 @@
 
           Consult the kernel documentation for details on this sysctl:
           https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt
+          
+        * The v239 change to turn on "net.ipv4.tcp_ecn" by default has been
+          reverted.
 
         * CPUAccounting=yes no longer enables the CPU controller when using
           kernel 4.15+ and the unified cgroup hierarchy, as required accounting
diff -aruN old/.semaphore/semaphore.yml new/.semaphore/semaphore.yml
--- old/.semaphore/semaphore.yml	2021-07-07 18:41:29.000000000 +0100
+++ new/.semaphore/semaphore.yml	2021-11-19 17:19:28.000000000 +0000
@@ -25,3 +25,8 @@
             - checkout --use-cache
             - .semaphore/semaphore-runner.sh SETUP
             - .semaphore/semaphore-runner.sh RUN
+          env_vars:
+            # Pin the debian systemd repo to a specific revision, to work around
+            # missing systemd/systemd#20056 in pre-v250 stable branches
+            - name: BRANCH
+              value: e138f8573a14f8f094bd6c9582bc26ed62c1347f
diff -aruN old/shell-completion/zsh/_systemd-run new/shell-completion/zsh/_systemd-run
--- old/shell-completion/zsh/_systemd-run	2021-07-07 18:41:29.000000000 +0100
+++ new/shell-completion/zsh/_systemd-run	2021-11-19 17:19:28.000000000 +0000
@@ -77,4 +77,5 @@
     '--version[Show package version]' \
     '--wait=[Wait until service stopped again]' \
     '--working-directory=[Run with the specified working directory]' \
-    '*::command:_command'
+    '(-):command: _command_names -e' \
+    '*::arguments:_normal'
diff -aruN old/shell-completion/zsh/_udevadm new/shell-completion/zsh/_udevadm
--- old/shell-completion/zsh/_udevadm	2021-07-07 18:41:29.000000000 +0100
+++ new/shell-completion/zsh/_udevadm	2021-11-19 17:19:28.000000000 +0000
@@ -23,7 +23,7 @@
         '--dry-run[Do not actually trigger the event.]' \
         '--quiet[Suppress error logging in triggering events.]' \
         '--type=[Trigger a specific type of devices.]:types:(devices subsystems failed)' \
-        '--action=[Type of event to be triggered.]:actions:(add change remove)' \
+        '--action=[Type of event to be triggered.]:actions:(add change remove move online offline bind unbind)' \
         '--subsystem-match=[Trigger events for devices which belong to a matching subsystem.]' \
         '--subsystem-nomatch=[Do not trigger events for devices which belong to a matching subsystem.]' \
         '--attr-match=attribute=[Trigger events for devices with a matching sysfs attribute.]' \
@@ -74,7 +74,7 @@
 (( $+functions[_udevadm_test] )) ||
 _udevadm_test(){
     _arguments \
-        '--action=[The action string.]:actions:(add change remove)' \
+        '--action=[The action string.]:actions:(add change remove move online offline bind unbind)' \
         '--subsystem=[The subsystem string.]' \
         '--help[Print help text.]' \
         '*::devpath:_files -P /sys/ -W /sys'
diff -aruN old/src/analyze/analyze-security.c new/src/analyze/analyze-security.c
--- old/src/analyze/analyze-security.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/analyze/analyze-security.c	2021-11-19 17:19:28.000000000 +0000
@@ -1910,7 +1910,7 @@
         if (streq(member, "IPIngressFilterPath"))
                 info->ip_filters_custom_ingress = !strv_isempty(l);
         else if (streq(member, "IPEgressFilterPath"))
-                info->ip_filters_custom_ingress = !strv_isempty(l);
+                info->ip_filters_custom_egress = !strv_isempty(l);
 
         return 0;
 }
diff -aruN old/src/basic/env-util.c new/src/basic/env-util.c
--- old/src/basic/env-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/env-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -577,6 +577,7 @@
 
                                 word = e+1;
                                 state = WORD;
+                                nest--;
                         } else if (*e == ':') {
                                 if (flags & REPLACE_ENV_ALLOW_EXTENDED) {
                                         len = e - word - 2;
diff -aruN old/src/basic/ether-addr-util.c new/src/basic/ether-addr-util.c
--- old/src/basic/ether-addr-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/ether-addr-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -7,6 +7,7 @@
 #include <sys/types.h>
 
 #include "ether-addr-util.h"
+#include "hexdecoct.h"
 #include "macro.h"
 #include "string-util.h"
 
@@ -15,12 +16,13 @@
         assert(buffer);
         assert(addr->length <= HW_ADDR_MAX_SIZE);
 
-        for (size_t i = 0; i < addr->length; i++) {
-                sprintf(&buffer[3*i], "%02"PRIx8, addr->bytes[i]);
-                if (i < addr->length - 1)
-                        buffer[3*i + 2] = ':';
+        for (size_t i = 0, j = 0; i < addr->length; i++) {
+                buffer[j++] = hexchar(addr->bytes[i] >> 4);
+                buffer[j++] = hexchar(addr->bytes[i] & 0x0f);
+                buffer[j++] = ':';
         }
 
+        buffer[addr->length > 0 ? addr->length * 3 - 1 : 0] = '\0';
         return buffer;
 }
 
diff -aruN old/src/basic/fileio.c new/src/basic/fileio.c
--- old/src/basic/fileio.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/fileio.c	2021-11-19 17:19:28.000000000 +0000
@@ -30,14 +30,16 @@
 /* The maximum size of the file we'll read in one go in read_full_file() (64M). */
 #define READ_FULL_BYTES_MAX (64U*1024U*1024U - 1U)
 
-/* The maximum size of virtual files we'll read in one go in read_virtual_file() (4M). Note that this limit
- * is different (and much lower) than the READ_FULL_BYTES_MAX limit. This reflects the fact that we use
- * different strategies for reading virtual and regular files: virtual files are generally size constrained:
- * there we allocate the full buffer size in advance. Regular files OTOH can be much larger, and here we grow
- * the allocations exponentially in a loop. In glibc large allocations are immediately backed by mmap()
- * making them relatively slow (measurably so). Thus, when allocating the full buffer in advance the large
- * limit is a problem. When allocating piecemeal it's not. Hence pick two distinct limits. */
-#define READ_VIRTUAL_BYTES_MAX (4U*1024U*1024U - 1U)
+/* The maximum size of virtual files (i.e. procfs, sysfs, and other virtual "API" files) we'll read in one go
+ * in read_virtual_file(). Note that this limit is different (and much lower) than the READ_FULL_BYTES_MAX
+ * limit. This reflects the fact that we use different strategies for reading virtual and regular files:
+ * virtual files we generally have to read in a single read() syscall since the kernel doesn't support
+ * continuation read()s for them. Thankfully they are somewhat size constrained. Thus we can allocate the
+ * full potential buffer in advance. Regular files OTOH can be much larger, and there we grow the allocations
+ * exponentially in a loop. We use a size limit of 4M-2 because 4M-1 is the maximum buffer that /proc/sys/
+ * allows us to read() (larger reads will fail with ENOMEM), and we want to read one extra byte so that we
+ * can detect EOFs. */
+#define READ_VIRTUAL_BYTES_MAX (4U*1024U*1024U - 2U)
 
 int fopen_unlocked(const char *path, const char *options, FILE **ret) {
         assert(ret);
@@ -393,7 +395,7 @@
          * contents* may be returned. (Though the read is still done using one syscall.) Returns 0 on
          * partial success, 1 if untruncated contents were read. */
 
-        fd = open(filename, O_RDONLY|O_CLOEXEC);
+        fd = open(filename, O_RDONLY|O_NOCTTY|O_CLOEXEC);
         if (fd < 0)
                 return -errno;
 
@@ -431,6 +433,11 @@
                         }
 
                         n_retries--;
+                } else if (n_retries > 1) {
+                        /* Files in /proc are generally smaller than the page size so let's start with a page size
+                         * buffer from malloc and only use the max buffer on the final try. */
+                        size = MIN3(page_size() - 1, READ_VIRTUAL_BYTES_MAX, max_size);
+                        n_retries = 1;
                 } else {
                         size = MIN(READ_VIRTUAL_BYTES_MAX, max_size);
                         n_retries = 0;
@@ -463,9 +470,14 @@
                 if (n <= size)
                         break;
 
-                /* If a maximum size is specified and we already read as much, no need to try again */
-                if (max_size != SIZE_MAX && n >= max_size) {
-                        n = max_size;
+                /* If a maximum size is specified and we already read more we know the file is larger, and
+                 * can handle this as truncation case. Note that if the size of what we read equals the
+                 * maximum size then this doesn't mean truncation, the file might or might not end on that
+                 * byte. We need to rerun the loop in that case, with a larger buffer size, so that we read
+                 * at least one more byte to be able to distinguish EOF from truncation. */
+                if (max_size != SIZE_MAX && n > max_size) {
+                        n = size; /* Make sure we never use more than what we sized the buffer for (so that
+                                   * we have one free byte in it for the trailing NUL we add below).*/
                         truncated = true;
                         break;
                 }
diff -aruN old/src/basic/fileio.h new/src/basic/fileio.h
--- old/src/basic/fileio.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/fileio.h	2021-11-19 17:19:28.000000000 +0000
@@ -2,11 +2,11 @@
 #pragma once
 
 #include <dirent.h>
+#include <fcntl.h>
 #include <stdbool.h>
 #include <stddef.h>
 #include <stdio.h>
 #include <sys/stat.h>
-#include <sys/fcntl.h>
 #include <sys/types.h>
 
 #include "macro.h"
diff -aruN old/src/basic/linux/if_arp.h new/src/basic/linux/if_arp.h
--- old/src/basic/linux/if_arp.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/linux/if_arp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,164 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Global definitions for the ARP (RFC 826) protocol.
- *
- * Version:	@(#)if_arp.h	1.0.1	04/16/93
- *
- * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
- *		Portions taken from the KA9Q/NOS (v2.00m PA0GRI) source.
- *		Ross Biro
- *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *		Florian La Roche,
- *		Jonathan Layes <layes@loran.com>
- *		Arnaldo Carvalho de Melo <acme@conectiva.com.br> ARPHRD_HWX25
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-#ifndef _UAPI_LINUX_IF_ARP_H
-#define _UAPI_LINUX_IF_ARP_H
-
-#include <linux/netdevice.h>
-
-/* ARP protocol HARDWARE identifiers. */
-#define ARPHRD_NETROM	0		/* from KA9Q: NET/ROM pseudo	*/
-#define ARPHRD_ETHER 	1		/* Ethernet 10Mbps		*/
-#define	ARPHRD_EETHER	2		/* Experimental Ethernet	*/
-#define	ARPHRD_AX25	3		/* AX.25 Level 2		*/
-#define	ARPHRD_PRONET	4		/* PROnet token ring		*/
-#define	ARPHRD_CHAOS	5		/* Chaosnet			*/
-#define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB	*/
-#define	ARPHRD_ARCNET	7		/* ARCnet			*/
-#define	ARPHRD_APPLETLK	8		/* APPLEtalk			*/
-#define ARPHRD_DLCI	15		/* Frame Relay DLCI		*/
-#define ARPHRD_ATM	19		/* ATM 				*/
-#define ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id)	*/
-#define	ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734	*/
-#define ARPHRD_EUI64	27		/* EUI-64                       */
-#define ARPHRD_INFINIBAND 32		/* InfiniBand			*/
-
-/* Dummy types for non ARP hardware */
-#define ARPHRD_SLIP	256
-#define ARPHRD_CSLIP	257
-#define ARPHRD_SLIP6	258
-#define ARPHRD_CSLIP6	259
-#define ARPHRD_RSRVD	260		/* Notional KISS type 		*/
-#define ARPHRD_ADAPT	264
-#define ARPHRD_ROSE	270
-#define ARPHRD_X25	271		/* CCITT X.25			*/
-#define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
-#define ARPHRD_CAN	280		/* Controller Area Network      */
-#define ARPHRD_PPP	512
-#define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
-#define ARPHRD_HDLC	ARPHRD_CISCO
-#define ARPHRD_LAPB	516		/* LAPB				*/
-#define ARPHRD_DDCMP    517		/* Digital's DDCMP protocol     */
-#define ARPHRD_RAWHDLC	518		/* Raw HDLC			*/
-#define ARPHRD_RAWIP    519		/* Raw IP                       */
-
-#define ARPHRD_TUNNEL	768		/* IPIP tunnel			*/
-#define ARPHRD_TUNNEL6	769		/* IP6IP6 tunnel       		*/
-#define ARPHRD_FRAD	770             /* Frame Relay Access Device    */
-#define ARPHRD_SKIP	771		/* SKIP vif			*/
-#define ARPHRD_LOOPBACK	772		/* Loopback device		*/
-#define ARPHRD_LOCALTLK 773		/* Localtalk device		*/
-#define ARPHRD_FDDI	774		/* Fiber Distributed Data Interface */
-#define ARPHRD_BIF      775             /* AP1000 BIF                   */
-#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4	*/
-#define ARPHRD_IPDDP	777		/* IP over DDP tunneller	*/
-#define ARPHRD_IPGRE	778		/* GRE over IP			*/
-#define ARPHRD_PIMREG	779		/* PIMSM register interface	*/
-#define ARPHRD_HIPPI	780		/* High Performance Parallel Interface */
-#define ARPHRD_ASH	781		/* Nexus 64Mbps Ash		*/
-#define ARPHRD_ECONET	782		/* Acorn Econet			*/
-#define ARPHRD_IRDA 	783		/* Linux-IrDA			*/
-/* ARP works differently on different FC media .. so  */
-#define ARPHRD_FCPP	784		/* Point to point fibrechannel	*/
-#define ARPHRD_FCAL	785		/* Fibrechannel arbitrated loop */
-#define ARPHRD_FCPL	786		/* Fibrechannel public loop	*/
-#define ARPHRD_FCFABRIC	787		/* Fibrechannel fabric		*/
-	/* 787->799 reserved for fibrechannel media types */
-#define ARPHRD_IEEE802_TR 800		/* Magic type ident for TR	*/
-#define ARPHRD_IEEE80211 801		/* IEEE 802.11			*/
-#define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header  */
-#define ARPHRD_IEEE80211_RADIOTAP 803	/* IEEE 802.11 + radiotap header */
-#define ARPHRD_IEEE802154	  804
-#define ARPHRD_IEEE802154_MONITOR 805	/* IEEE 802.15.4 network monitor */
-
-#define ARPHRD_PHONET	820		/* PhoNet media type		*/
-#define ARPHRD_PHONET_PIPE 821		/* PhoNet pipe header		*/
-#define ARPHRD_CAIF	822		/* CAIF media type		*/
-#define ARPHRD_IP6GRE	823		/* GRE over IPv6		*/
-#define ARPHRD_NETLINK	824		/* Netlink header		*/
-#define ARPHRD_6LOWPAN	825		/* IPv6 over LoWPAN             */
-#define ARPHRD_VSOCKMON	826		/* Vsock monitor header		*/
-
-#define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
-#define ARPHRD_NONE	  0xFFFE	/* zero header length */
-
-/* ARP protocol opcodes. */
-#define	ARPOP_REQUEST	1		/* ARP request			*/
-#define	ARPOP_REPLY	2		/* ARP reply			*/
-#define	ARPOP_RREQUEST	3		/* RARP request			*/
-#define	ARPOP_RREPLY	4		/* RARP reply			*/
-#define	ARPOP_InREQUEST	8		/* InARP request		*/
-#define	ARPOP_InREPLY	9		/* InARP reply			*/
-#define	ARPOP_NAK	10		/* (ATM)ARP NAK			*/
-
-
-/* ARP ioctl request. */
-struct arpreq {
-	struct sockaddr	arp_pa;		/* protocol address		 */
-	struct sockaddr	arp_ha;		/* hardware address		 */
-	int		arp_flags;	/* flags			 */
-	struct sockaddr arp_netmask;    /* netmask (only for proxy arps) */
-	char		arp_dev[IFNAMSIZ];
-};
-
-struct arpreq_old {
-	struct sockaddr	arp_pa;		/* protocol address		 */
-	struct sockaddr	arp_ha;		/* hardware address		 */
-	int		arp_flags;	/* flags			 */
-	struct sockaddr	arp_netmask;    /* netmask (only for proxy arps) */
-};
-
-/* ARP Flag values. */
-#define ATF_COM		0x02		/* completed entry (ha valid)	*/
-#define	ATF_PERM	0x04		/* permanent entry		*/
-#define	ATF_PUBL	0x08		/* publish entry		*/
-#define	ATF_USETRAILERS	0x10		/* has requested trailers	*/
-#define ATF_NETMASK     0x20            /* want to use a netmask (only
-					   for proxy entries) */
-#define ATF_DONTPUB	0x40		/* don't answer this addresses	*/
-
-/*
- *	This structure defines an ethernet arp header.
- */
-
-struct arphdr {
-	__be16		ar_hrd;		/* format of hardware address	*/
-	__be16		ar_pro;		/* format of protocol address	*/
-	unsigned char	ar_hln;		/* length of hardware address	*/
-	unsigned char	ar_pln;		/* length of protocol address	*/
-	__be16		ar_op;		/* ARP opcode (command)		*/
-
-#if 0
-	 /*
-	  *	 Ethernet looks like this : This bit is variable sized however...
-	  */
-	unsigned char		ar_sha[ETH_ALEN];	/* sender hardware address	*/
-	unsigned char		ar_sip[4];		/* sender IP address		*/
-	unsigned char		ar_tha[ETH_ALEN];	/* target hardware address	*/
-	unsigned char		ar_tip[4];		/* target IP address		*/
-#endif
-
-};
-
-
-#endif /* _UAPI_LINUX_IF_ARP_H */
diff -aruN old/src/basic/meson.build new/src/basic/meson.build
--- old/src/basic/meson.build	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/meson.build	2021-11-19 17:19:28.000000000 +0000
@@ -88,7 +88,6 @@
         linux/hdlc/ioctl.h
         linux/if.h
         linux/if_addr.h
-        linux/if_arp.h
         linux/if_bonding.h
         linux/if_bridge.h
         linux/if_ether.h
diff -aruN old/src/basic/mountpoint-util.c new/src/basic/mountpoint-util.c
--- old/src/basic/mountpoint-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/mountpoint-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -157,6 +157,19 @@
         return filename_is_valid(copied);
 }
 
+static bool is_name_to_handle_at_fatal_error(int err) {
+        /* name_to_handle_at() can return "acceptable" errors that are due to the context. For
+         * example the kernel does not support name_to_handle_at() at all (ENOSYS), or the syscall
+         * was blocked (EACCES/EPERM; maybe through seccomp, because we are running inside of a
+         * container), or the mount point is not triggered yet (EOVERFLOW, think nfs4), or some
+         * general name_to_handle_at() flakiness (EINVAL). However other errors are not supposed to
+         * happen and therefore are considered fatal ones. */
+
+        assert(err < 0);
+
+        return !IN_SET(err, -EOPNOTSUPP, -ENOSYS, -EACCES, -EPERM, -EOVERFLOW, -EINVAL);
+}
+
 int fd_is_mount_point(int fd, const char *filename, int flags) {
         _cleanup_free_ struct file_handle *h = NULL, *h_parent = NULL;
         int mount_id = -1, mount_id_parent = -1;
@@ -206,39 +219,40 @@
                 return false; /* symlinks are never mount points */
 
         r = name_to_handle_at_loop(fd, filename, &h, &mount_id, flags);
-        if (IN_SET(r, -ENOSYS, -EACCES, -EPERM, -EOVERFLOW, -EINVAL))
-                /* This kernel does not support name_to_handle_at() at all (ENOSYS), or the syscall was blocked
-                 * (EACCES/EPERM; maybe through seccomp, because we are running inside of a container?), or the mount
-                 * point is not triggered yet (EOVERFLOW, think nfs4), or some general name_to_handle_at() flakiness
-                 * (EINVAL): fall back to simpler logic. */
-                goto fallback_fdinfo;
-        else if (r == -EOPNOTSUPP)
-                /* This kernel or file system does not support name_to_handle_at(), hence let's see if the upper fs
-                 * supports it (in which case it is a mount point), otherwise fall back to the traditional stat()
-                 * logic */
+        if (r < 0) {
+                if (is_name_to_handle_at_fatal_error(r))
+                        return r;
+                if (r != -EOPNOTSUPP)
+                        goto fallback_fdinfo;
+
+                /* This kernel or file system does not support name_to_handle_at(), hence let's see
+                 * if the upper fs supports it (in which case it is a mount point), otherwise fall
+                 * back to the traditional stat() logic */
                 nosupp = true;
-        else if (r < 0)
-                return r;
+        }
 
         r = name_to_handle_at_loop(fd, "", &h_parent, &mount_id_parent, AT_EMPTY_PATH);
-        if (r == -EOPNOTSUPP) {
+        if (r < 0) {
+                if (is_name_to_handle_at_fatal_error(r))
+                        return r;
+                if (r != -EOPNOTSUPP)
+                        goto fallback_fdinfo;
                 if (nosupp)
-                        /* Neither parent nor child do name_to_handle_at()?  We have no choice but to fall back. */
+                        /* Both the parent and the directory can't do name_to_handle_at() */
                         goto fallback_fdinfo;
-                else
-                        /* The parent can't do name_to_handle_at() but the directory we are interested in can?  If so,
-                         * it must be a mount point. */
-                        return 1;
-        } else if (r < 0)
-                return r;
 
-        /* The parent can do name_to_handle_at() but the directory we are interested in can't? If so, it must
-         * be a mount point. */
+                /* The parent can't do name_to_handle_at() but the directory we are
+                 * interested in can?  If so, it must be a mount point. */
+                return 1;
+        }
+
+        /* The parent can do name_to_handle_at() but the directory we are interested in can't? If
+         * so, it must be a mount point. */
         if (nosupp)
                 return 1;
 
-        /* If the file handle for the directory we are interested in and its parent are identical, we assume
-         * this is the root directory, which is a mount point. */
+        /* If the file handle for the directory we are interested in and its parent are identical,
+         * we assume this is the root directory, which is a mount point. */
 
         if (h->handle_bytes == h_parent->handle_bytes &&
             h->handle_type == h_parent->handle_type &&
@@ -338,10 +352,10 @@
         }
 
         r = name_to_handle_at_loop(AT_FDCWD, path, NULL, ret, 0);
-        if (IN_SET(r, -EOPNOTSUPP, -ENOSYS, -EACCES, -EPERM, -EOVERFLOW, -EINVAL)) /* kernel/fs don't support this, or seccomp blocks access, or untriggered mount, or name_to_handle_at() is flaky */
-                return fd_fdinfo_mnt_id(AT_FDCWD, path, 0, ret);
+        if (r == 0 || is_name_to_handle_at_fatal_error(r))
+                return r;
 
-        return r;
+        return fd_fdinfo_mnt_id(AT_FDCWD, path, 0, ret);
 }
 
 bool fstype_is_network(const char *fstype) {
@@ -410,6 +424,7 @@
         return STR_IN_SET(fstype,
                           "DM_verity_hash",
                           "iso9660",
+                          "erofs",
                           "squashfs");
 }
 
diff -aruN old/src/basic/path-util.c new/src/basic/path-util.c
--- old/src/basic/path-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/path-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -628,7 +628,11 @@
                 return r;
 
         r = access_fd(fd, X_OK);
-        if (r < 0)
+        if (r == -ENOSYS) {
+                /* /proc is not mounted. Fallback to access(). */
+                if (access(path, X_OK) < 0)
+                        return -errno;
+        } else if (r < 0)
                 return r;
 
         if (ret_fd)
diff -aruN old/src/basic/process-util.c new/src/basic/process-util.c
--- old/src/basic/process-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/process-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -858,8 +858,8 @@
 void sigkill_wait(pid_t pid) {
         assert(pid > 1);
 
-        if (kill(pid, SIGKILL) >= 0)
-                (void) wait_for_terminate(pid, NULL);
+        (void) kill(pid, SIGKILL);
+        (void) wait_for_terminate(pid, NULL);
 }
 
 void sigkill_waitp(pid_t *pid) {
@@ -876,8 +876,8 @@
 void sigterm_wait(pid_t pid) {
         assert(pid > 1);
 
-        if (kill_and_sigcont(pid, SIGTERM) >= 0)
-                (void) wait_for_terminate(pid, NULL);
+        (void) kill_and_sigcont(pid, SIGTERM);
+        (void) wait_for_terminate(pid, NULL);
 }
 
 int kill_and_sigcont(pid_t pid, int sig) {
diff -aruN old/src/basic/socket-util.h new/src/basic/socket-util.h
--- old/src/basic/socket-util.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/socket-util.h	2021-11-19 17:19:28.000000000 +0000
@@ -277,6 +277,28 @@
 int socket_bind_to_ifname(int fd, const char *ifname);
 int socket_bind_to_ifindex(int fd, int ifindex);
 
+/* Define a 64bit version of timeval/timespec in any case, even on 32bit userspace. */
+struct timeval_large {
+        uint64_t tvl_sec, tvl_usec;
+};
+struct timespec_large {
+        uint64_t tvl_sec, tvl_nsec;
+};
+
+/* glibc duplicates timespec/timeval on certain 32bit archs, once in 32bit and once in 64bit.
+ * See __convert_scm_timestamps() in glibc source code. Hence, we need additional buffer space for them
+ * to prevent from recvmsg_safe() returning -EXFULL. */
+#define CMSG_SPACE_TIMEVAL                                              \
+        ((sizeof(struct timeval) == sizeof(struct timeval_large)) ?     \
+         CMSG_SPACE(sizeof(struct timeval)) :                           \
+         CMSG_SPACE(sizeof(struct timeval)) +                           \
+         CMSG_SPACE(sizeof(struct timeval_large)))
+#define CMSG_SPACE_TIMESPEC                                             \
+        ((sizeof(struct timespec) == sizeof(struct timespec_large)) ?   \
+         CMSG_SPACE(sizeof(struct timespec)) :                          \
+         CMSG_SPACE(sizeof(struct timespec)) +                          \
+         CMSG_SPACE(sizeof(struct timespec_large)))
+
 ssize_t recvmsg_safe(int sockfd, struct msghdr *msg, int flags);
 
 int socket_get_family(int fd, int *ret);
diff -aruN old/src/basic/stat-util.c new/src/basic/stat-util.c
--- old/src/basic/stat-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/stat-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -79,7 +79,7 @@
         } else {
                 /* Note that DUPing is not enough, as the internal pointer
                  * would still be shared and moved by FOREACH_DIRENT. */
-                fd = fd_reopen(dir_fd, O_CLOEXEC);
+                fd = fd_reopen(dir_fd, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
                 if (fd < 0)
                         return fd;
         }
diff -aruN old/src/basic/unit-file.c new/src/basic/unit-file.c
--- old/src/basic/unit-file.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/unit-file.c	2021-11-19 17:19:28.000000000 +0000
@@ -284,7 +284,7 @@
                         continue;
                 }
 
-                FOREACH_DIRENT(de, d, log_warning_errno(errno, "Failed to read \"%s\", ignoring: %m", *dir)) {
+                FOREACH_DIRENT_ALL(de, d, log_warning_errno(errno, "Failed to read \"%s\", ignoring: %m", *dir)) {
                         char *filename;
                         _cleanup_free_ char *_filename_free = NULL, *simplified = NULL;
                         const char *suffix, *dst = NULL;
diff -aruN old/src/basic/unit-name.c new/src/basic/unit-name.c
--- old/src/basic/unit-name.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/unit-name.c	2021-11-19 17:19:28.000000000 +0000
@@ -378,12 +378,13 @@
 }
 
 int unit_name_path_escape(const char *f, char **ret) {
-        char *p, *s;
+        _cleanup_free_ char *p = NULL;
+        char *s;
 
         assert(f);
         assert(ret);
 
-        p = strdupa(f);
+        p = strdup(f);
         if (!p)
                 return -ENOMEM;
 
@@ -395,13 +396,9 @@
                 if (!path_is_normalized(p))
                         return -EINVAL;
 
-                /* Truncate trailing slashes */
+                /* Truncate trailing slashes and skip leading slashes */
                 delete_trailing_chars(p, "/");
-
-                /* Truncate leading slashes */
-                p = skip_leading_chars(p, "/");
-
-                s = unit_name_escape(p);
+                s = unit_name_escape(skip_leading_chars(p, "/"));
         }
         if (!s)
                 return -ENOMEM;
diff -aruN old/src/basic/virt.c new/src/basic/virt.c
--- old/src/basic/virt.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/basic/virt.c	2021-11-19 17:19:28.000000000 +0000
@@ -159,12 +159,13 @@
                 { "VMware",              VIRTUALIZATION_VMWARE    }, /* https://kb.vmware.com/s/article/1009458 */
                 { "VMW",                 VIRTUALIZATION_VMWARE    },
                 { "innotek GmbH",        VIRTUALIZATION_ORACLE    },
-                { "Oracle Corporation",  VIRTUALIZATION_ORACLE    },
+                { "VirtualBox",          VIRTUALIZATION_ORACLE    },
                 { "Xen",                 VIRTUALIZATION_XEN       },
                 { "Bochs",               VIRTUALIZATION_BOCHS     },
                 { "Parallels",           VIRTUALIZATION_PARALLELS },
                 /* https://wiki.freebsd.org/bhyve */
                 { "BHYVE",               VIRTUALIZATION_BHYVE     },
+                { "Microsoft",           VIRTUALIZATION_MICROSOFT },
         };
         int r;
 
@@ -235,8 +236,36 @@
 
         /* The DMI vendor tables in /sys/class/dmi/id don't help us distinguish between Amazon EC2
          * virtual machines and bare-metal instances, so we need to look at SMBIOS. */
-        if (r == VIRTUALIZATION_AMAZON && detect_vm_smbios() == SMBIOS_VM_BIT_UNSET)
-                return VIRTUALIZATION_NONE;
+        if (r == VIRTUALIZATION_AMAZON) {
+                switch (detect_vm_smbios()) {
+                case SMBIOS_VM_BIT_SET:
+                        return VIRTUALIZATION_AMAZON;
+                case SMBIOS_VM_BIT_UNSET:
+                        return VIRTUALIZATION_NONE;
+                case SMBIOS_VM_BIT_UNKNOWN: {
+                        /* The DMI information we are after is only accessible to the root user,
+                         * so we fallback to using the product name which is less restricted
+                         * to distinguish metal systems from virtualized instances */
+                        _cleanup_free_ char *s = NULL;
+
+                        r = read_full_virtual_file("/sys/class/dmi/id/product_name", &s, NULL);
+                        /* In EC2, virtualized is much more common than metal, so if for some reason
+                         * we fail to read the DMI data, assume we are virtualized. */
+                        if (r < 0) {
+                                log_debug_errno(r, "Can't read /sys/class/dmi/id/product_name,"
+                                                " assuming virtualized: %m");
+                                return VIRTUALIZATION_AMAZON;
+                        }
+                        if (endswith(truncate_nl(s), ".metal")) {
+                                log_debug("DMI product name ends with '.metal', assuming no virtualization");
+                                return VIRTUALIZATION_NONE;
+                        } else
+                                return VIRTUALIZATION_AMAZON;
+                }
+                default:
+                        assert_not_reached("Bad virtualization value");
+              }
+        }
 
         /* If we haven't identified a VM, but the firmware indicates that there is one, indicate as much. We
          * have no further information about what it is. */
diff -aruN old/src/binfmt/binfmt.c new/src/binfmt/binfmt.c
--- old/src/binfmt/binfmt.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/binfmt/binfmt.c	2021-11-19 17:19:28.000000000 +0000
@@ -189,7 +189,7 @@
 
         r = parse_argv(argc, argv);
         if (r <= 0)
-                return r < 0 ? EXIT_FAILURE : EXIT_SUCCESS;
+                return r;
 
         log_setup();
 
diff -aruN old/src/boot/bootctl.c new/src/boot/bootctl.c
--- old/src/boot/bootctl.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/bootctl.c	2021-11-19 17:19:28.000000000 +0000
@@ -711,7 +711,7 @@
         for (i = 0; i < n; i++)
                 if (i != options[i]) {
                         *id = i;
-                        return 1;
+                        return 0;
                 }
 
         /* use the next one */
@@ -1337,7 +1337,7 @@
                 sd_id128_t bootloader_esp_uuid;
                 bool have_bootloader_esp_uuid = efi_loader_get_device_part_uuid(&bootloader_esp_uuid) >= 0;
 
-                print_yes_no_line(false, have_bootloader_esp_uuid, "Boot loader sets ESP partition information");
+                print_yes_no_line(false, have_bootloader_esp_uuid, "Boot loader sets ESP information");
                 if (have_bootloader_esp_uuid && !sd_id128_equal(esp_uuid, bootloader_esp_uuid))
                         printf("WARNING: The boot loader reports a different ESP UUID than detected!\n");
 
diff -aruN old/src/boot/efi/boot.c new/src/boot/efi/boot.c
--- old/src/boot/efi/boot.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/boot.c	2021-11-19 17:19:28.000000000 +0000
@@ -134,7 +134,7 @@
                 uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, print);
                 uefi_call_wrapper(ST->ConOut->SetCursorPosition, 3, ST->ConOut, cursor, y_pos);
 
-                err = console_key_read(&key, TRUE);
+                err = console_key_read(&key, 0);
                 if (EFI_ERROR(err))
                         continue;
 
@@ -387,7 +387,7 @@
                 Print(L"OsIndicationsSupported: %d\n", indvar);
 
         Print(L"\n--- press key ---\n\n");
-        console_key_read(&key, TRUE);
+        console_key_read(&key, 0);
 
         Print(L"timeout:                %u\n", config->timeout_sec);
         if (config->timeout_sec_efivar >= 0)
@@ -432,7 +432,7 @@
                 Print(L"LoaderEntryDefault:     %s\n", defaultstr);
 
         Print(L"\n--- press key ---\n\n");
-        console_key_read(&key, TRUE);
+        console_key_read(&key, 0);
 
         for (UINTN i = 0; i < config->entry_count; i++) {
                 ConfigEntry *entry;
@@ -482,7 +482,7 @@
                               entry->path, entry->next_name);
 
                 Print(L"\n--- press key ---\n\n");
-                console_key_read(&key, TRUE);
+                console_key_read(&key, 0);
         }
 
         uefi_call_wrapper(ST->ConOut->ClearScreen, 1, ST->ConOut);
@@ -509,11 +509,10 @@
         UINTN y_max;
         CHAR16 *status;
         CHAR16 *clearline;
-        INTN timeout_remain;
+        UINTN timeout_remain = config->timeout_sec;
         INT16 idx;
         BOOLEAN exit = FALSE;
         BOOLEAN run = TRUE;
-        BOOLEAN wait = FALSE;
 
         graphics_mode(FALSE);
         uefi_call_wrapper(ST->ConIn->Reset, 2, ST->ConIn, FALSE);
@@ -527,7 +526,7 @@
                 err = console_set_mode(&config->console_mode, config->console_mode_change);
                 if (EFI_ERROR(err)) {
                         uefi_call_wrapper(ST->ConOut->ClearScreen, 1, ST->ConOut);
-                        Print(L"Error switching console mode to %ld: %r.\r", (UINT64)config->console_mode, err);
+                        log_error_stall(L"Error switching console mode to %lu: %r", (UINT64)config->console_mode, err);
                 }
         } else
                 uefi_call_wrapper(ST->ConOut->ClearScreen, 1, ST->ConOut);
@@ -538,12 +537,6 @@
                 y_max = 25;
         }
 
-        /* we check 10 times per second for a keystroke */
-        if (config->timeout_sec > 0)
-                timeout_remain = config->timeout_sec * 10;
-        else
-                timeout_remain = -1;
-
         idx_highlight = config->idx_default;
         idx_highlight_prev = 0;
 
@@ -643,7 +636,7 @@
 
                 if (timeout_remain > 0) {
                         FreePool(status);
-                        status = PoolPrint(L"Boot in %d sec.", (timeout_remain + 5) / 10);
+                        status = PoolPrint(L"Boot in %d s.", timeout_remain);
                 }
 
                 /* print status at last line of screen */
@@ -664,27 +657,18 @@
                         uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, clearline+1 + x + len);
                 }
 
-                err = console_key_read(&key, wait);
-                if (EFI_ERROR(err)) {
-                        /* timeout reached */
+                err = console_key_read(&key, timeout_remain > 0 ? 1000 * 1000 : 0);
+                if (err == EFI_TIMEOUT) {
+                        timeout_remain--;
                         if (timeout_remain == 0) {
                                 exit = TRUE;
                                 break;
                         }
 
-                        /* sleep and update status */
-                        if (timeout_remain > 0) {
-                                uefi_call_wrapper(BS->Stall, 1, 100 * 1000);
-                                timeout_remain--;
-                                continue;
-                        }
-
-                        /* timeout disabled, wait for next key */
-                        wait = TRUE;
+                        /* update status */
                         continue;
-                }
-
-                timeout_remain = -1;
+                } else
+                        timeout_remain = 0;
 
                 /* clear status after keystroke */
                 if (status) {
@@ -787,7 +771,7 @@
                                         config->timeout_sec_efivar,
                                         EFI_VARIABLE_NON_VOLATILE);
                                 if (config->timeout_sec_efivar > 0)
-                                        status = PoolPrint(L"Menu timeout set to %d sec.", config->timeout_sec_efivar);
+                                        status = PoolPrint(L"Menu timeout set to %d s.", config->timeout_sec_efivar);
                                 else
                                         status = StrDuplicate(L"Menu disabled. Hold down key at bootup to show menu.");
                         } else if (config->timeout_sec_efivar <= 0){
@@ -795,7 +779,7 @@
                                 efivar_set(
                                         LOADER_GUID, L"LoaderConfigTimeout", NULL, EFI_VARIABLE_NON_VOLATILE);
                                 if (config->timeout_sec_config > 0)
-                                        status = PoolPrint(L"Menu timeout of %d sec is defined by configuration file.",
+                                        status = PoolPrint(L"Menu timeout of %d s is defined by configuration file.",
                                                            config->timeout_sec_config);
                                 else
                                         status = StrDuplicate(L"Menu disabled. Hold down key at bootup to show menu.");
@@ -813,7 +797,7 @@
                                 config->timeout_sec_efivar,
                                 EFI_VARIABLE_NON_VOLATILE);
                         if (config->timeout_sec_efivar > 0)
-                                status = PoolPrint(L"Menu timeout set to %d sec.",
+                                status = PoolPrint(L"Menu timeout set to %d s.",
                                                    config->timeout_sec_efivar);
                         else
                                 status = StrDuplicate(L"Menu disabled. Hold down key at bootup to show menu.");
@@ -1221,8 +1205,7 @@
                         break;
 
                 if (r != EFI_BUFFER_TOO_SMALL || file_info_size * 2 < file_info_size) {
-                        Print(L"\nFailed to get file info for '%s': %r\n", old_path, r);
-                        uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
+                        log_error_stall(L"Failed to get file info for '%s': %r", old_path, r);
                         return;
                 }
 
@@ -1234,8 +1217,7 @@
         StrCpy(file_info->FileName, entry->next_name);
         r = uefi_call_wrapper(handle->SetInfo, 4, handle, &EfiFileInfoGuid, file_info_size, file_info);
         if (EFI_ERROR(r)) {
-                Print(L"\nFailed to rename '%s' to '%s', ignoring: %r\n", old_path, entry->next_name, r);
-                uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
+                log_error_stall(L"Failed to rename '%s' to '%s', ignoring: %r", old_path, entry->next_name, r);
                 return;
         }
 
@@ -1724,7 +1706,7 @@
         *entry = (ConfigEntry) {
                 .type = type,
                 .title = StrDuplicate(title),
-                .version = StrDuplicate(version),
+                .version = version ? StrDuplicate(version) : NULL,
                 .device = device,
                 .loader = StrDuplicate(loader),
                 .id = StrDuplicate(id),
@@ -2165,18 +2147,12 @@
         EFI_STATUS err;
 
         path = FileDevicePath(entry->device, entry->loader);
-        if (!path) {
-                Print(L"Error getting device path.");
-                uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-                return EFI_INVALID_PARAMETER;
-        }
+        if (!path)
+                return log_error_status_stall(EFI_INVALID_PARAMETER, L"Error getting device path.");
 
         err = uefi_call_wrapper(BS->LoadImage, 6, FALSE, parent_image, path, NULL, 0, &image);
-        if (EFI_ERROR(err)) {
-                Print(L"Error loading %s: %r", entry->loader, err);
-                uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-                return err;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Error loading %s: %r", entry->loader, err);
 
         if (config->options_edit)
                 options = config->options_edit;
@@ -2190,8 +2166,7 @@
                 err = uefi_call_wrapper(BS->OpenProtocol, 6, image, &LoadedImageProtocol, (VOID **)&loaded_image,
                                         parent_image, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
                 if (EFI_ERROR(err)) {
-                        Print(L"Error getting LoadedImageProtocol handle: %r", err);
-                        uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
+                        log_error_stall(L"Error getting LoadedImageProtocol handle: %r", err);
                         goto out_unload;
                 }
                 loaded_image->LoadOptions = options;
@@ -2202,10 +2177,8 @@
                 err = tpm_log_event(SD_TPM_PCR,
                                     (EFI_PHYSICAL_ADDRESS) (UINTN) loaded_image->LoadOptions,
                                     loaded_image->LoadOptionsSize, loaded_image->LoadOptions);
-                if (EFI_ERROR(err)) {
-                        Print(L"Unable to add image options measurement: %r", err);
-                        uefi_call_wrapper(BS->Stall, 1, 200 * 1000);
-                }
+                if (EFI_ERROR(err))
+                        log_error_stall(L"Unable to add image options measurement: %r", err);
 #endif
         }
 
@@ -2231,9 +2204,7 @@
                 return err;
 
         err = uefi_call_wrapper(RT->ResetSystem, 4, EfiResetCold, EFI_SUCCESS, 0, NULL);
-        Print(L"Error calling ResetSystem: %r", err);
-        uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-        return err;
+        return log_error_status_stall(err, L"Error calling ResetSystem: %r", err);
 }
 
 static VOID config_free(Config *config) {
@@ -2305,30 +2276,21 @@
 
         err = uefi_call_wrapper(BS->OpenProtocol, 6, image, &LoadedImageProtocol, (VOID **)&loaded_image,
                                 image, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
-        if (EFI_ERROR(err)) {
-                Print(L"Error getting a LoadedImageProtocol handle: %r", err);
-                uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-                return err;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Error getting a LoadedImageProtocol handle: %r", err);
 
         /* export the device path this image is started from */
         if (disk_get_part_uuid(loaded_image->DeviceHandle, uuid) == EFI_SUCCESS)
                 efivar_set(LOADER_GUID, L"LoaderDevicePartUUID", uuid, 0);
 
         root_dir = LibOpenRoot(loaded_image->DeviceHandle);
-        if (!root_dir) {
-                Print(L"Unable to open root directory.");
-                uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-                return EFI_LOAD_ERROR;
-        }
+        if (!root_dir)
+                return log_error_status_stall(EFI_LOAD_ERROR, L"Unable to open root directory.", EFI_LOAD_ERROR);
 
         if (secure_boot_enabled() && shim_loaded()) {
                 err = security_policy_install();
-                if (EFI_ERROR(err)) {
-                        Print(L"Error installing security policy: %r ", err);
-                        uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-                        return err;
-                }
+                if (EFI_ERROR(err))
+                        return log_error_status_stall(err, L"Error installing security policy: %r", err);
         }
 
         /* the filesystem path to this image, to prevent adding ourselves to the menu */
@@ -2367,8 +2329,7 @@
         }
 
         if (config.entry_count == 0) {
-                Print(L"No loader found. Configuration files in \\loader\\entries\\*.conf are needed.");
-                uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
+                log_error_stall(L"No loader found. Configuration files in \\loader\\entries\\*.conf are needed.");
                 goto out;
         }
 
@@ -2392,13 +2353,8 @@
         else {
                 UINT64 key;
 
-                err = console_key_read(&key, FALSE);
-
-                if (err == EFI_NOT_READY) {
-                        uefi_call_wrapper(BS->Stall, 1, 100 * 1000);
-                        err = console_key_read(&key, FALSE);
-                }
-
+                /* Block up to 100ms to give firmware time to get input working. */
+                err = console_key_read(&key, 100 * 1000);
                 if (!EFI_ERROR(err)) {
                         INT16 idx;
 
@@ -2440,8 +2396,7 @@
                 err = image_start(image, &config, entry);
                 if (EFI_ERROR(err)) {
                         graphics_mode(FALSE);
-                        Print(L"\nFailed to execute %s (%s): %r\n", entry->title, entry->loader, err);
-                        uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
+                        log_error_stall(L"Failed to execute %s (%s): %r", entry->title, entry->loader, err);
                         goto out;
                 }
 
diff -aruN old/src/boot/efi/console.c new/src/boot/efi/console.c
--- old/src/boot/efi/console.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/console.c	2021-11-19 17:19:28.000000000 +0000
@@ -11,61 +11,105 @@
 
 #define EFI_SIMPLE_TEXT_INPUT_EX_GUID &(EFI_GUID) EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL_GUID
 
-EFI_STATUS console_key_read(UINT64 *key, BOOLEAN wait) {
+static inline void EventClosep(EFI_EVENT *event) {
+        if (!*event)
+                return;
+
+        uefi_call_wrapper(BS->CloseEvent, 1, *event);
+}
+
+/*
+ * Reading input from the console sounds like an easy task to do, but thanks to broken
+ * firmware it is actually a nightmare.
+ *
+ * There is a ConIn and TextInputEx API for this. Ideally we want to use TextInputEx,
+ * because that gives us Ctrl/Alt/Shift key state information. Unfortunately, it is not
+ * always available and sometimes just non-functional.
+ *
+ * On the other hand we have ConIn, where some firmware likes to just freeze on us
+ * if we call ReadKeyStroke on it.
+ *
+ * Therefore, we use WaitForEvent on both ConIn and TextInputEx (if available) along
+ * with a timer event. The timer ensures there is no need to call into functions
+ * that might freeze on us, while still allowing us to show a timeout counter.
+ */
+EFI_STATUS console_key_read(UINT64 *key, UINT64 timeout_usec) {
         static EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *TextInputEx;
         static BOOLEAN checked;
         UINTN index;
         EFI_INPUT_KEY k;
         EFI_STATUS err;
+        _cleanup_(EventClosep) EFI_EVENT timer = NULL;
+        EFI_EVENT events[3] = { ST->ConIn->WaitForKey };
+        UINTN n_events = 1;
 
         if (!checked) {
                 err = LibLocateProtocol(EFI_SIMPLE_TEXT_INPUT_EX_GUID, (VOID **)&TextInputEx);
-                if (EFI_ERROR(err))
+                if (EFI_ERROR(err) ||
+                    uefi_call_wrapper(BS->CheckEvent, 1, TextInputEx->WaitForKeyEx) == EFI_INVALID_PARAMETER)
+                        /* If WaitForKeyEx fails here, the firmware pretends it talks this
+                         * protocol, but it really doesn't. */
                         TextInputEx = NULL;
+                else
+                        events[n_events++] = TextInputEx->WaitForKeyEx;
 
                 checked = TRUE;
         }
 
-        /* wait until key is pressed */
-        if (wait)
-                uefi_call_wrapper(BS->WaitForEvent, 3, 1, &ST->ConIn->WaitForKey, &index);
+        if (timeout_usec > 0) {
+                err = uefi_call_wrapper(BS->CreateEvent, 5, EVT_TIMER, 0, NULL, NULL, &timer);
+                if (EFI_ERROR(err))
+                        return log_error_status_stall(err, L"Error creating timer event: %r", err);
+
+                /* SetTimer expects 100ns units for some reason. */
+                err = uefi_call_wrapper(BS->SetTimer, 3, timer, TimerRelative, timeout_usec * 10);
+                if (EFI_ERROR(err))
+                        return log_error_status_stall(err, L"Error arming timer event: %r", err);
+
+                events[n_events++] = timer;
+        }
+
+        err = uefi_call_wrapper(BS->WaitForEvent, 3, n_events, events, &index);
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Error waiting for events: %r", err);
 
-        if (TextInputEx) {
+        if (timeout_usec > 0 && timer == events[index])
+                return EFI_TIMEOUT;
+
+        /* TextInputEx might be ready too even if ConIn got to signal first. */
+        if (TextInputEx && !EFI_ERROR(uefi_call_wrapper(BS->CheckEvent, 1, TextInputEx->WaitForKeyEx))) {
                 EFI_KEY_DATA keydata;
                 UINT64 keypress;
+                UINT32 shift = 0;
 
                 err = uefi_call_wrapper(TextInputEx->ReadKeyStrokeEx, 2, TextInputEx, &keydata);
-                if (!EFI_ERROR(err)) {
-                        UINT32 shift = 0;
+                if (EFI_ERROR(err))
+                        return err;
 
-                        /* do not distinguish between left and right keys */
-                        if (keydata.KeyState.KeyShiftState & EFI_SHIFT_STATE_VALID) {
-                                if (keydata.KeyState.KeyShiftState & (EFI_RIGHT_CONTROL_PRESSED|EFI_LEFT_CONTROL_PRESSED))
-                                        shift |= EFI_CONTROL_PRESSED;
-                                if (keydata.KeyState.KeyShiftState & (EFI_RIGHT_ALT_PRESSED|EFI_LEFT_ALT_PRESSED))
-                                        shift |= EFI_ALT_PRESSED;
-                        };
-
-                        /* 32 bit modifier keys + 16 bit scan code + 16 bit unicode */
-                        keypress = KEYPRESS(shift, keydata.Key.ScanCode, keydata.Key.UnicodeChar);
-                        if (keypress > 0) {
-                                *key = keypress;
-                                return 0;
-                        }
+                /* do not distinguish between left and right keys */
+                if (keydata.KeyState.KeyShiftState & EFI_SHIFT_STATE_VALID) {
+                        if (keydata.KeyState.KeyShiftState & (EFI_RIGHT_CONTROL_PRESSED|EFI_LEFT_CONTROL_PRESSED))
+                                shift |= EFI_CONTROL_PRESSED;
+                        if (keydata.KeyState.KeyShiftState & (EFI_RIGHT_ALT_PRESSED|EFI_LEFT_ALT_PRESSED))
+                                shift |= EFI_ALT_PRESSED;
+                };
+
+                /* 32 bit modifier keys + 16 bit scan code + 16 bit unicode */
+                keypress = KEYPRESS(shift, keydata.Key.ScanCode, keydata.Key.UnicodeChar);
+                if (keypress > 0) {
+                        *key = keypress;
+                        return EFI_SUCCESS;
                 }
+
+                return EFI_NOT_READY;
         }
 
-        /* fallback for firmware which does not support SimpleTextInputExProtocol
-         *
-         * This is also called in case ReadKeyStrokeEx did not return a key, because
-         * some broken firmwares offer SimpleTextInputExProtocol, but never actually
-         * handle any key. */
         err  = uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, &k);
         if (EFI_ERROR(err))
                 return err;
 
         *key = KEYPRESS(0, k.ScanCode, k.UnicodeChar);
-        return 0;
+        return EFI_SUCCESS;
 }
 
 static EFI_STATUS change_mode(UINTN mode) {
diff -aruN old/src/boot/efi/console.h new/src/boot/efi/console.h
--- old/src/boot/efi/console.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/console.h	2021-11-19 17:19:28.000000000 +0000
@@ -16,5 +16,5 @@
         CONSOLE_MODE_MAX,
 };
 
-EFI_STATUS console_key_read(UINT64 *key, BOOLEAN wait);
+EFI_STATUS console_key_read(UINT64 *key, UINT64 timeout_usec);
 EFI_STATUS console_set_mode(UINTN *mode, enum console_mode_change_type how);
diff -aruN old/src/boot/efi/linux.c new/src/boot/efi/linux.c
--- old/src/boot/efi/linux.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/linux.c	2021-11-19 17:19:28.000000000 +0000
@@ -25,7 +25,7 @@
         handover(image, ST, params);
 }
 
-EFI_STATUS linux_exec(EFI_HANDLE *image,
+EFI_STATUS linux_exec(EFI_HANDLE image,
                       CHAR8 *cmdline, UINTN cmdline_len,
                       UINTN linux_addr,
                       UINTN initrd_addr, UINTN initrd_size) {
diff -aruN old/src/boot/efi/linux.h new/src/boot/efi/linux.h
--- old/src/boot/efi/linux.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/linux.h	2021-11-19 17:19:28.000000000 +0000
@@ -83,7 +83,7 @@
         UINT8  _pad9[276];
 } __attribute__((packed));
 
-EFI_STATUS linux_exec(EFI_HANDLE *image,
+EFI_STATUS linux_exec(EFI_HANDLE image,
                       CHAR8 *cmdline, UINTN cmdline_size,
                       UINTN linux_addr,
                       UINTN initrd_addr, UINTN initrd_size);
diff -aruN old/src/boot/efi/random-seed.c new/src/boot/efi/random-seed.c
--- old/src/boot/efi/random-seed.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/random-seed.c	2021-11-19 17:19:28.000000000 +0000
@@ -35,10 +35,8 @@
                 return log_oom();
 
         err = uefi_call_wrapper(rng->GetRNG, 3, rng, NULL, size, data);
-        if (EFI_ERROR(err)) {
-                Print(L"Failed to acquire RNG data: %r\n", err);
-                return err;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Failed to acquire RNG data: %r", err);
 
         *ret = TAKE_PTR(data);
         return EFI_SUCCESS;
@@ -149,14 +147,12 @@
         err = efivar_get_raw(LOADER_GUID, L"LoaderSystemToken", &data, &size);
         if (EFI_ERROR(err)) {
                 if (err != EFI_NOT_FOUND)
-                        Print(L"Failed to read LoaderSystemToken EFI variable: %r", err);
+                        log_error_stall(L"Failed to read LoaderSystemToken EFI variable: %r", err);
                 return err;
         }
 
-        if (size <= 0) {
-                Print(L"System token too short, ignoring.");
-                return EFI_NOT_FOUND;
-        }
+        if (size <= 0)
+                return log_error_status_stall(EFI_NOT_FOUND, L"System token too short, ignoring.");
 
         *ret = TAKE_PTR(data);
         *ret_size = size;
@@ -209,8 +205,7 @@
                 sha256_finish_ctx(&hash, result);
 
                 if (CompareMem(result, array[i].hash, HASH_VALUE_SIZE) != 0) {
-                        Print(L"SHA256 failed validation.\n");
-                        uefi_call_wrapper(BS->Stall, 1, 120 * 1000 * 1000);
+                        log_error_stall(L"SHA256 failed validation.");
                         return;
                 }
         }
@@ -245,8 +240,8 @@
 
         err = uefi_call_wrapper(root_dir->Open, 5, root_dir, &handle, (CHAR16*) L"\\loader\\random-seed", EFI_FILE_MODE_READ|EFI_FILE_MODE_WRITE, 0ULL);
         if (EFI_ERROR(err)) {
-                if (err != EFI_NOT_FOUND)
-                        Print(L"Failed to open random seed file: %r\n", err);
+                if (err != EFI_NOT_FOUND && err != EFI_WRITE_PROTECTED)
+                        log_error_stall(L"Failed to open random seed file: %r", err);
                 return err;
         }
 
@@ -255,15 +250,11 @@
                 return log_oom();
 
         size = info->FileSize;
-        if (size < RANDOM_MAX_SIZE_MIN) {
-                Print(L"Random seed file is too short?\n");
-                return EFI_INVALID_PARAMETER;
-        }
+        if (size < RANDOM_MAX_SIZE_MIN)
+                return log_error_status_stall(EFI_INVALID_PARAMETER, L"Random seed file is too short.");
 
-        if (size > RANDOM_MAX_SIZE_MAX) {
-                Print(L"Random seed file is too large?\n");
-                return EFI_INVALID_PARAMETER;
-        }
+        if (size > RANDOM_MAX_SIZE_MAX)
+                return log_error_status_stall(EFI_INVALID_PARAMETER, L"Random seed file is too large.");
 
         seed = AllocatePool(size);
         if (!seed)
@@ -271,20 +262,14 @@
 
         rsize = size;
         err = uefi_call_wrapper(handle->Read, 3, handle, &rsize, seed);
-        if (EFI_ERROR(err)) {
-                Print(L"Failed to read random seed file: %r\n", err);
-                return err;
-        }
-        if (rsize != size) {
-                Print(L"Short read on random seed file\n");
-                return EFI_PROTOCOL_ERROR;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Failed to read random seed file: %r", err);
+        if (rsize != size)
+                return log_error_status_stall(EFI_PROTOCOL_ERROR, L"Short read on random seed file.");
 
         err = uefi_call_wrapper(handle->SetPosition, 2, handle, 0);
-        if (EFI_ERROR(err)) {
-                Print(L"Failed to seek to beginning of random seed file: %r\n", err);
-                return err;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Failed to seek to beginning of random seed file: %r", err);
 
         /* Request some random data from the UEFI RNG. We don't need this to work safely, but it's a good
          * idea to use it because it helps us for cases where users mistakenly include a random seed in
@@ -299,27 +284,19 @@
         /* Update the random seed on disk before we use it */
         wsize = size;
         err = uefi_call_wrapper(handle->Write, 3, handle, &wsize, new_seed);
-        if (EFI_ERROR(err)) {
-                Print(L"Failed to write random seed file: %r\n", err);
-                return err;
-        }
-        if (wsize != size) {
-                Print(L"Short write on random seed file\n");
-                return EFI_PROTOCOL_ERROR;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Failed to write random seed file: %r", err);
+        if (wsize != size)
+                return log_error_status_stall(EFI_PROTOCOL_ERROR, L"Short write on random seed file.");
 
         err = uefi_call_wrapper(handle->Flush, 1, handle);
-        if (EFI_ERROR(err)) {
-                Print(L"Failed to flush random seed file: %r\n");
-                return err;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Failed to flush random seed file: %r", err);
 
         /* We are good to go */
         err = efivar_set_raw(LOADER_GUID, L"LoaderRandomSeed", for_kernel, size, 0);
-        if (EFI_ERROR(err)) {
-                Print(L"Failed to write random seed to EFI variable: %r\n", err);
-                return err;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Failed to write random seed to EFI variable: %r", err);
 
         return EFI_SUCCESS;
 }
diff -aruN old/src/boot/efi/stub.c new/src/boot/efi/stub.c
--- old/src/boot/efi/stub.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/stub.c	2021-11-19 17:19:28.000000000 +0000
@@ -36,18 +36,12 @@
 
         err = uefi_call_wrapper(BS->OpenProtocol, 6, image, &LoadedImageProtocol, (VOID **)&loaded_image,
                                 image, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
-        if (EFI_ERROR(err)) {
-                Print(L"Error getting a LoadedImageProtocol handle: %r ", err);
-                uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-                return err;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Error getting a LoadedImageProtocol handle: %r", err);
 
         err = pe_memory_locate_sections(loaded_image->ImageBase, sections, addrs, offs, szs);
-        if (EFI_ERROR(err)) {
-                Print(L"Unable to locate embedded .linux section: %r ", err);
-                uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-                return err;
-        }
+        if (EFI_ERROR(err))
+                return log_error_status_stall(err, L"Unable to locate embedded .linux section: %r", err);
 
         if (szs[0] > 0)
                 cmdline = (CHAR8 *)(loaded_image->ImageBase) + addrs[0];
@@ -72,10 +66,8 @@
                 err = tpm_log_event(SD_TPM_PCR,
                                     (EFI_PHYSICAL_ADDRESS) (UINTN) loaded_image->LoadOptions,
                                     loaded_image->LoadOptionsSize, loaded_image->LoadOptions);
-                if (EFI_ERROR(err)) {
-                        Print(L"Unable to add image options measurement: %r", err);
-                        uefi_call_wrapper(BS->Stall, 1, 200 * 1000);
-                }
+                if (EFI_ERROR(err))
+                        log_error_stall(L"Unable to add image options measurement: %r", err);
 #endif
         }
 
@@ -126,7 +118,5 @@
                          (UINTN)loaded_image->ImageBase + addrs[2], szs[2]);
 
         graphics_mode(FALSE);
-        Print(L"Execution of embedded linux image failed: %r\n", err);
-        uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
-        return err;
+        return log_error_status_stall(err, L"Execution of embedded linux image failed: %r", err);
 }
diff -aruN old/src/boot/efi/util.c new/src/boot/efi/util.c
--- old/src/boot/efi/util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/util.c	2021-11-19 17:19:28.000000000 +0000
@@ -411,8 +411,21 @@
         return err;
 }
 
+VOID log_error_stall(const CHAR16 *fmt, ...) {
+        va_list args;
+
+        uefi_call_wrapper(ST->ConOut->SetAttribute, 2, ST->ConOut, EFI_LIGHTRED|EFI_BACKGROUND_BLACK);
+
+        Print(L"\n");
+        va_start(args, fmt);
+        VPrint(fmt, args);
+        va_end(args);
+        Print(L"\n");
+
+        uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
+}
+
 EFI_STATUS log_oom(void) {
-        Print(L"Out of memory.");
-        (void) uefi_call_wrapper(BS->Stall, 1, 3 * 1000 * 1000);
+        log_error_stall(L"Out of memory.");
         return EFI_OUT_OF_RESOURCES;
 }
diff -aruN old/src/boot/efi/util.h new/src/boot/efi/util.h
--- old/src/boot/efi/util.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/boot/efi/util.h	2021-11-19 17:19:28.000000000 +0000
@@ -74,4 +74,13 @@
 #define UINT64_MAX ((UINT64) -1)
 #endif
 
+VOID log_error_stall(const CHAR16 *fmt, ...);
 EFI_STATUS log_oom(void);
+
+/* This works just like log_error_errno() from userspace, but requires you
+ * to provide err a second time if you want to use %r in the message! */
+#define log_error_status_stall(err, fmt, ...) \
+        ({ \
+                log_error_stall(fmt, ##__VA_ARGS__); \
+                err; \
+        })
diff -aruN old/src/core/bpf-devices.c new/src/core/bpf-devices.c
--- old/src/core/bpf-devices.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/bpf-devices.c	2021-11-19 17:19:28.000000000 +0000
@@ -9,6 +9,7 @@
 #include "fileio.h"
 #include "nulstr-util.h"
 #include "parse-util.h"
+#include "path-util.h"
 #include "stat-util.h"
 #include "stdio-util.h"
 #include "string-util.h"
@@ -260,7 +261,7 @@
         r = bpf_program_cgroup_attach(prog, BPF_CGROUP_DEVICE, controller_path, BPF_F_ALLOW_MULTI);
         if (r < 0)
                 return log_error_errno(r, "Attaching device control BPF program to cgroup %s failed: %m",
-                                       cgroup_path);
+                                       empty_to_root(cgroup_path));
 
  finish:
         /* Unref the old BPF program (which will implicitly detach it) right before attaching the new program. */
diff -aruN old/src/core/cgroup.c new/src/core/cgroup.c
--- old/src/core/cgroup.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/cgroup.c	2021-11-19 17:19:28.000000000 +0000
@@ -84,7 +84,7 @@
         r = cg_set_attribute(controller, u->cgroup_path, attribute, value);
         if (r < 0)
                 log_unit_full_errno(u, LOG_LEVEL_CGROUP_WRITE(r), r, "Failed to set '%s' attribute on '%s' to '%.*s': %m",
-                                    strna(attribute), isempty(u->cgroup_path) ? "/" : u->cgroup_path, (int) strcspn(value, NEWLINE), value);
+                                    strna(attribute), empty_to_root(u->cgroup_path), (int) strcspn(value, NEWLINE), value);
 
         return r;
 }
@@ -713,25 +713,25 @@
         if (c->moom_preference == MANAGED_OOM_PREFERENCE_OMIT) {
                 r = cg_set_xattr(SYSTEMD_CGROUP_CONTROLLER, cgroup_path, "user.oomd_omit", "1", 1, 0);
                 if (r < 0)
-                        log_unit_debug_errno(u, r, "Failed to set oomd_omit flag on control group %s, ignoring: %m", cgroup_path);
+                        log_unit_debug_errno(u, r, "Failed to set oomd_omit flag on control group %s, ignoring: %m", empty_to_root(cgroup_path));
         }
 
         if (c->moom_preference == MANAGED_OOM_PREFERENCE_AVOID) {
                 r = cg_set_xattr(SYSTEMD_CGROUP_CONTROLLER, cgroup_path, "user.oomd_avoid", "1", 1, 0);
                 if (r < 0)
-                        log_unit_debug_errno(u, r, "Failed to set oomd_avoid flag on control group %s, ignoring: %m", cgroup_path);
+                        log_unit_debug_errno(u, r, "Failed to set oomd_avoid flag on control group %s, ignoring: %m", empty_to_root(cgroup_path));
         }
 
         if (c->moom_preference != MANAGED_OOM_PREFERENCE_AVOID) {
                 r = cg_remove_xattr(SYSTEMD_CGROUP_CONTROLLER, cgroup_path, "user.oomd_avoid");
-                if (r != -ENODATA)
-                        log_unit_debug_errno(u, r, "Failed to remove oomd_avoid flag on control group %s, ignoring: %m", cgroup_path);
+                if (r < 0 && r != -ENODATA)
+                        log_unit_debug_errno(u, r, "Failed to remove oomd_avoid flag on control group %s, ignoring: %m", empty_to_root(cgroup_path));
         }
 
         if (c->moom_preference != MANAGED_OOM_PREFERENCE_OMIT) {
                 r = cg_remove_xattr(SYSTEMD_CGROUP_CONTROLLER, cgroup_path, "user.oomd_omit");
-                if (r != -ENODATA)
-                        log_unit_debug_errno(u, r, "Failed to remove oomd_omit flag on control group %s, ignoring: %m", cgroup_path);
+                if (r < 0 && r != -ENODATA)
+                        log_unit_debug_errno(u, r, "Failed to remove oomd_omit flag on control group %s, ignoring: %m", empty_to_root(cgroup_path));
         }
 }
 
@@ -750,7 +750,7 @@
                                  sd_id128_to_string(u->invocation_id, ids), 32,
                                  0);
                 if (r < 0)
-                        log_unit_debug_errno(u, r, "Failed to set invocation ID on control group %s, ignoring: %m", u->cgroup_path);
+                        log_unit_debug_errno(u, r, "Failed to set invocation ID on control group %s, ignoring: %m", empty_to_root(u->cgroup_path));
         }
 
         if (unit_cgroup_delegate(u)) {
@@ -759,11 +759,11 @@
                                  "1", 1,
                                  0);
                 if (r < 0)
-                        log_unit_debug_errno(u, r, "Failed to set delegate flag on control group %s, ignoring: %m", u->cgroup_path);
+                        log_unit_debug_errno(u, r, "Failed to set delegate flag on control group %s, ignoring: %m", empty_to_root(u->cgroup_path));
         } else {
                 r = cg_remove_xattr(SYSTEMD_CGROUP_CONTROLLER, u->cgroup_path, "trusted.delegate");
-                if (r != -ENODATA)
-                        log_unit_debug_errno(u, r, "Failed to remove delegate flag on control group %s, ignoring: %m", u->cgroup_path);
+                if (r < 0 && r != -ENODATA)
+                        log_unit_debug_errno(u, r, "Failed to remove delegate flag on control group %s, ignoring: %m", empty_to_root(u->cgroup_path));
         }
 
         cgroup_oomd_xattr_apply(u, u->cgroup_path);
@@ -1921,12 +1921,12 @@
                                       * is not an error */
                         return 0;
 
-                return log_unit_error_errno(u, errno, "Failed to add control inotify watch descriptor for control group %s: %m", u->cgroup_path);
+                return log_unit_error_errno(u, errno, "Failed to add control inotify watch descriptor for control group %s: %m", empty_to_root(u->cgroup_path));
         }
 
         r = hashmap_put(u->manager->cgroup_control_inotify_wd_unit, INT_TO_PTR(u->cgroup_control_inotify_wd), u);
         if (r < 0)
-                return log_unit_error_errno(u, r, "Failed to add control inotify watch descriptor to hash map: %m");
+                return log_unit_error_errno(u, r, "Failed to add control inotify watch descriptor for control group %s to hash map: %m", empty_to_root(u->cgroup_path));
 
         return 0;
 }
@@ -1984,12 +1984,12 @@
                                       * is not an error */
                         return 0;
 
-                return log_unit_error_errno(u, errno, "Failed to add memory inotify watch descriptor for control group %s: %m", u->cgroup_path);
+                return log_unit_error_errno(u, errno, "Failed to add memory inotify watch descriptor for control group %s: %m", empty_to_root(u->cgroup_path));
         }
 
         r = hashmap_put(u->manager->cgroup_memory_inotify_wd_unit, INT_TO_PTR(u->cgroup_memory_inotify_wd), u);
         if (r < 0)
-                return log_unit_error_errno(u, r, "Failed to add memory inotify watch descriptor to hash map: %m");
+                return log_unit_error_errno(u, r, "Failed to add memory inotify watch descriptor for control group %s to hash map: %m", empty_to_root(u->cgroup_path));
 
         return 0;
 }
@@ -2012,9 +2012,9 @@
 
         r = unit_set_cgroup_path(u, path);
         if (r == -EEXIST)
-                return log_unit_error_errno(u, r, "Control group %s exists already.", path);
+                return log_unit_error_errno(u, r, "Control group %s exists already.", empty_to_root(path));
         if (r < 0)
-                return log_unit_error_errno(u, r, "Failed to set unit's control group path to %s: %m", path);
+                return log_unit_error_errno(u, r, "Failed to set unit's control group path to %s: %m", empty_to_root(path));
 
         return 0;
 }
@@ -2042,7 +2042,7 @@
         /* First, create our own group */
         r = cg_create_everywhere(u->manager->cgroup_supported, target_mask, u->cgroup_path);
         if (r < 0)
-                return log_unit_error_errno(u, r, "Failed to create cgroup %s: %m", u->cgroup_path);
+                return log_unit_error_errno(u, r, "Failed to create cgroup %s: %m", empty_to_root(u->cgroup_path));
         created = r;
 
         /* Start watching it */
@@ -2058,7 +2058,7 @@
                 /* Enable all controllers we need */
                 r = cg_enable_everywhere(u->manager->cgroup_supported, enable_mask, u->cgroup_path, &result_mask);
                 if (r < 0)
-                        log_unit_warning_errno(u, r, "Failed to enable/disable controllers on cgroup %s, ignoring: %m", u->cgroup_path);
+                        log_unit_warning_errno(u, r, "Failed to enable/disable controllers on cgroup %s, ignoring: %m", empty_to_root(u->cgroup_path));
 
                 /* Remember what's actually enabled now */
                 u->cgroup_enabled_mask = result_mask;
@@ -2080,12 +2080,12 @@
         if (cg_all_unified() == 0) {
                 r = cg_migrate_v1_controllers(u->manager->cgroup_supported, migrate_mask, u->cgroup_path, migrate_callback, u);
                 if (r < 0)
-                        log_unit_warning_errno(u, r, "Failed to migrate controller cgroups from %s, ignoring: %m", u->cgroup_path);
+                        log_unit_warning_errno(u, r, "Failed to migrate controller cgroups from %s, ignoring: %m", empty_to_root(u->cgroup_path));
 
                 is_root_slice = unit_has_name(u, SPECIAL_ROOT_SLICE);
                 r = cg_trim_v1_controllers(u->manager->cgroup_supported, ~target_mask, u->cgroup_path, !is_root_slice);
                 if (r < 0)
-                        log_unit_warning_errno(u, r, "Failed to delete controller cgroups %s, ignoring: %m", u->cgroup_path);
+                        log_unit_warning_errno(u, r, "Failed to delete controller cgroups %s, ignoring: %m", empty_to_root(u->cgroup_path));
         }
 
         /* Set attributes */
@@ -2137,7 +2137,7 @@
         CGroupMask delegated_mask;
         const char *p;
         void *pidp;
-        int r, q;
+        int ret, r;
 
         assert(u);
 
@@ -2164,18 +2164,18 @@
 
         delegated_mask = unit_get_delegate_mask(u);
 
-        r = 0;
+        ret = 0;
         SET_FOREACH(pidp, pids) {
                 pid_t pid = PTR_TO_PID(pidp);
 
                 /* First, attach the PID to the main cgroup hierarchy */
-                q = cg_attach(SYSTEMD_CGROUP_CONTROLLER, p, pid);
-                if (q < 0) {
-                        bool again = MANAGER_IS_USER(u->manager) && ERRNO_IS_PRIVILEGE(q);
+                r = cg_attach(SYSTEMD_CGROUP_CONTROLLER, p, pid);
+                if (r < 0) {
+                        bool again = MANAGER_IS_USER(u->manager) && ERRNO_IS_PRIVILEGE(r);
 
-                        log_unit_full_errno(u, again ? LOG_DEBUG : LOG_INFO,  q,
+                        log_unit_full_errno(u, again ? LOG_DEBUG : LOG_INFO,  r,
                                             "Couldn't move process "PID_FMT" to%s requested cgroup '%s': %m",
-                                            pid, again ? " directly" : "", p);
+                                            pid, again ? " directly" : "", empty_to_root(p));
 
                         if (again) {
                                 int z;
@@ -2187,21 +2187,25 @@
 
                                 z = unit_attach_pid_to_cgroup_via_bus(u, pid, suffix_path);
                                 if (z < 0)
-                                        log_unit_info_errno(u, z, "Couldn't move process "PID_FMT" to requested cgroup '%s' (directly or via the system bus): %m", pid, p);
-                                else
+                                        log_unit_info_errno(u, z, "Couldn't move process "PID_FMT" to requested cgroup '%s' (directly or via the system bus): %m", pid, empty_to_root(p));
+                                else {
+                                        if (ret >= 0)
+                                                ret++; /* Count successful additions */
                                         continue; /* When the bus thing worked via the bus we are fully done for this PID. */
+                                }
                         }
 
-                        if (r >= 0)
-                                r = q; /* Remember first error */
+                        if (ret >= 0)
+                                ret = r; /* Remember first error */
 
                         continue;
-                }
+                } else if (ret >= 0)
+                        ret++; /* Count successful additions */
 
-                q = cg_all_unified();
-                if (q < 0)
-                        return q;
-                if (q > 0)
+                r = cg_all_unified();
+                if (r < 0)
+                        return r;
+                if (r > 0)
                         continue;
 
                 /* In the legacy hierarchy, attach the process to the request cgroup if possible, and if not to the
@@ -2216,12 +2220,12 @@
 
                         /* If this controller is delegated and realized, honour the caller's request for the cgroup suffix. */
                         if (delegated_mask & u->cgroup_realized_mask & bit) {
-                                q = cg_attach(cgroup_controller_to_string(c), p, pid);
-                                if (q >= 0)
+                                r = cg_attach(cgroup_controller_to_string(c), p, pid);
+                                if (r >= 0)
                                         continue; /* Success! */
 
-                                log_unit_debug_errno(u, q, "Failed to attach PID " PID_FMT " to requested cgroup %s in controller %s, falling back to unit's cgroup: %m",
-                                                     pid, p, cgroup_controller_to_string(c));
+                                log_unit_debug_errno(u, r, "Failed to attach PID " PID_FMT " to requested cgroup %s in controller %s, falling back to unit's cgroup: %m",
+                                                     pid, empty_to_root(p), cgroup_controller_to_string(c));
                         }
 
                         /* So this controller is either not delegate or realized, or something else weird happened. In
@@ -2231,14 +2235,14 @@
                         if (!realized)
                                 continue; /* Not even realized in the root slice? Then let's not bother */
 
-                        q = cg_attach(cgroup_controller_to_string(c), realized, pid);
-                        if (q < 0)
-                                log_unit_debug_errno(u, q, "Failed to attach PID " PID_FMT " to realized cgroup %s in controller %s, ignoring: %m",
+                        r = cg_attach(cgroup_controller_to_string(c), realized, pid);
+                        if (r < 0)
+                                log_unit_debug_errno(u, r, "Failed to attach PID " PID_FMT " to realized cgroup %s in controller %s, ignoring: %m",
                                                      pid, realized, cgroup_controller_to_string(c));
                 }
         }
 
-        return r;
+        return ret;
 }
 
 static bool unit_has_mask_realized(
@@ -2656,7 +2660,7 @@
                  * the containing slice is stopped. So even if we failed now, this unit shouldn't assume
                  * that the cgroup is still realized the next time it is started. Do not return early
                  * on error, continue cleanup. */
-                log_unit_full_errno(u, r == -EBUSY ? LOG_DEBUG : LOG_WARNING, r, "Failed to destroy cgroup %s, ignoring: %m", u->cgroup_path);
+                log_unit_full_errno(u, r == -EBUSY ? LOG_DEBUG : LOG_WARNING, r, "Failed to destroy cgroup %s, ignoring: %m", empty_to_root(u->cgroup_path));
 
         if (is_root_slice)
                 return;
@@ -2869,7 +2873,7 @@
 
         r = cg_is_empty_recursive(SYSTEMD_CGROUP_CONTROLLER, u->cgroup_path);
         if (r < 0) {
-                log_unit_debug_errno(u, r, "Failed to determine whether cgroup %s is empty: %m", u->cgroup_path);
+                log_unit_debug_errno(u, r, "Failed to determine whether cgroup %s is empty: %m", empty_to_root(u->cgroup_path));
                 return;
         }
         if (r == 0)
@@ -3039,6 +3043,9 @@
 
         assert(u);
 
+        if (!u->cgroup_path)
+                return 0;
+
         r = cg_get_keyed_attribute_graceful(SYSTEMD_CGROUP_CONTROLLER, u->cgroup_path, "cgroup.events",
                                             STRV_MAKE("populated", "frozen"), values);
         if (r < 0)
@@ -3871,6 +3878,21 @@
         }
 }
 
+void unit_cgroup_catchup(Unit *u) {
+        assert(u);
+
+        if (!UNIT_HAS_CGROUP_CONTEXT(u))
+                return;
+
+        /* We dropped the inotify watch during reexec/reload, so we need to
+         * check these as they may have changed.
+         * Note that (currently) the kernel doesn't actually update cgroup
+         * file modification times, so we can't just serialize and then check
+         * the mtime for file(s) we are interested in. */
+        (void) unit_check_cgroup_events(u);
+        unit_add_to_cgroup_oom_queue(u);
+}
+
 bool unit_cgroup_delegate(Unit *u) {
         CGroupContext *c;
 
diff -aruN old/src/core/cgroup.h new/src/core/cgroup.h
--- old/src/core/cgroup.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/cgroup.h	2021-11-19 17:19:28.000000000 +0000
@@ -313,6 +313,8 @@
 const char* cgroup_device_policy_to_string(CGroupDevicePolicy i) _const_;
 CGroupDevicePolicy cgroup_device_policy_from_string(const char *s) _pure_;
 
+void unit_cgroup_catchup(Unit *u);
+
 bool unit_cgroup_delegate(Unit *u);
 
 int compare_job_priority(const void *a, const void *b);
diff -aruN old/src/core/dbus-execute.c new/src/core/dbus-execute.c
--- old/src/core/dbus-execute.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/dbus-execute.c	2021-11-19 17:19:28.000000000 +0000
@@ -1421,6 +1421,10 @@
                 if (r < 0)
                         return r;
 
+                if (strv_isempty(argv))
+                        return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS,
+                                                 "\"%s\" argv cannot be empty", name);
+
                 r = is_ex_prop ? sd_bus_message_read_strv(message, &ex_opts) : sd_bus_message_read(message, "b", &b);
                 if (r < 0)
                         return r;
diff -aruN old/src/core/dbus-unit.c new/src/core/dbus-unit.c
--- old/src/core/dbus-unit.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/dbus-unit.c	2021-11-19 17:19:28.000000000 +0000
@@ -905,10 +905,11 @@
         SD_BUS_PROPERTY("RefuseManualStop", "b", bus_property_get_bool, offsetof(Unit, refuse_manual_stop), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("AllowIsolate", "b", bus_property_get_bool, offsetof(Unit, allow_isolate), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("DefaultDependencies", "b", bus_property_get_bool, offsetof(Unit, default_dependencies), SD_BUS_VTABLE_PROPERTY_CONST),
-        SD_BUS_PROPERTY("OnSuccesJobMode", "s", property_get_job_mode, offsetof(Unit, on_success_job_mode), SD_BUS_VTABLE_PROPERTY_CONST),
+        SD_BUS_PROPERTY("OnSuccesJobMode", "s", property_get_job_mode, offsetof(Unit, on_success_job_mode), SD_BUS_VTABLE_PROPERTY_CONST|SD_BUS_VTABLE_HIDDEN), /* deprecated */
+        SD_BUS_PROPERTY("OnSuccessJobMode", "s", property_get_job_mode, offsetof(Unit, on_success_job_mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("OnFailureJobMode", "s", property_get_job_mode, offsetof(Unit, on_failure_job_mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IgnoreOnIsolate", "b", bus_property_get_bool, offsetof(Unit, ignore_on_isolate), SD_BUS_VTABLE_PROPERTY_CONST),
-        SD_BUS_PROPERTY("NeedDaemonReload", "b", property_get_need_daemon_reload, 0, SD_BUS_VTABLE_PROPERTY_CONST),
+        SD_BUS_PROPERTY("NeedDaemonReload", "b", property_get_need_daemon_reload, 0, 0),
         SD_BUS_PROPERTY("Markers", "as", property_get_markers, offsetof(Unit, markers), 0),
         SD_BUS_PROPERTY("JobTimeoutUSec", "t", bus_property_get_usec, offsetof(Unit, job_timeout), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("JobRunningTimeoutUSec", "t", bus_property_get_usec, offsetof(Unit, job_running_timeout), SD_BUS_VTABLE_PROPERTY_CONST),
diff -aruN old/src/core/execute.c new/src/core/execute.c
--- old/src/core/execute.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/execute.c	2021-11-19 17:19:28.000000000 +0000
@@ -4059,13 +4059,17 @@
                 }
         }
 
-        if (context->utmp_id)
+        if (context->utmp_id) {
+                const char *line = context->tty_path ?
+                        (path_startswith(context->tty_path, "/dev/") ?: context->tty_path) :
+                        NULL;
                 utmp_put_init_process(context->utmp_id, getpid_cached(), getsid(0),
-                                      context->tty_path,
+                                      line,
                                       context->utmp_mode == EXEC_UTMP_INIT  ? INIT_PROCESS :
                                       context->utmp_mode == EXEC_UTMP_LOGIN ? LOGIN_PROCESS :
                                       USER_PROCESS,
                                       username);
+        }
 
         if (uid_is_valid(uid)) {
                 r = chown_terminal(STDIN_FILENO, uid);
@@ -4357,7 +4361,7 @@
 
                 if (fd >= 0) {
                         r = mac_selinux_get_child_mls_label(fd, executable, context->selinux_context, &mac_selinux_context_net);
-                        if (r < 0) {
+                        if (r < 0 && !context->selinux_context_ignore) {
                                 *exit_status = EXIT_SELINUX_CONTEXT;
                                 return log_unit_error_errno(unit, r, "Failed to determine SELinux context: %m");
                         }
@@ -4404,7 +4408,7 @@
                  * process. This is the latest place before dropping capabilities. Other MAC context are set later. */
                 if (use_smack) {
                         r = setup_smack(context, executable_fd);
-                        if (r < 0) {
+                        if (r < 0 && !context->smack_process_label_ignore) {
                                 *exit_status = EXIT_SMACK_PROCESS_LABEL;
                                 return log_unit_error_errno(unit, r, "Failed to set SMACK process label: %m");
                         }
@@ -4491,7 +4495,7 @@
 
                         if (exec_context) {
                                 r = setexeccon(exec_context);
-                                if (r < 0) {
+                                if (r < 0 && !context->selinux_context_ignore) {
                                         *exit_status = EXIT_SELINUX_CONTEXT;
                                         return log_unit_error_errno(unit, r, "Failed to change SELinux context to %s: %m", exec_context);
                                 }
diff -aruN old/src/core/load-fragment.c new/src/core/load-fragment.c
--- old/src/core/load-fragment.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/load-fragment.c	2021-11-19 17:19:28.000000000 +0000
@@ -800,7 +800,7 @@
                 if (!separate_argv0) {
                         char *w = NULL;
 
-                        if (!GREEDY_REALLOC(n, nlen + 2))
+                        if (!GREEDY_REALLOC0(n, nlen + 2))
                                 return log_oom();
 
                         w = strdup(path);
@@ -832,7 +832,7 @@
                                 p += 2;
                                 p += strspn(p, WHITESPACE);
 
-                                if (!GREEDY_REALLOC(n, nlen + 2))
+                                if (!GREEDY_REALLOC0(n, nlen + 2))
                                         return log_oom();
 
                                 w = strdup(";");
diff -aruN old/src/core/main.c new/src/core/main.c
--- old/src/core/main.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/main.c	2021-11-19 17:19:28.000000000 +0000
@@ -1720,9 +1720,50 @@
                 log_warning_errno(r, "Failed to set NUMA memory policy: %m");
 }
 
+static void filter_args(const char* dst[], unsigned *pos, char **src, int argc) {
+        assert(dst);
+        assert(pos);
+
+        /* Copy some filtered arguments into the dst array from src. */
+        for (int i = 1; i < argc; i++) {
+                if (STR_IN_SET(src[i],
+                               "--switched-root",
+                               "--system",
+                               "--user"))
+                        continue;
+
+                if (startswith(src[i], "--deserialize="))
+                        continue;
+                if (streq(src[i], "--deserialize")) {
+                        i++;                            /* Skip the argument too */
+                        continue;
+                }
+
+                /* Skip target unit designators. We already acted upon this information and have queued
+                 * appropriate jobs. We don't want to redo all this after reexecution. */
+                if (startswith(src[i], "--unit="))
+                        continue;
+                if (streq(src[i], "--unit")) {
+                        i++;                            /* Skip the argument too */
+                        continue;
+                }
+
+                if (startswith(src[i],
+                               in_initrd() ? "rd.systemd.unit=" : "systemd.unit="))
+                        continue;
+
+                if (runlevel_to_target(src[i]))
+                        continue;
+
+                /* Seems we have a good old option. Let's pass it over to the new instance. */
+                dst[*pos] = src[i];
+                (*pos)++;
+        }
+}
+
 static void do_reexecute(
                 int argc,
-                char *argv[],
+                char* argv[],
                 const struct rlimit *saved_rlimit_nofile,
                 const struct rlimit *saved_rlimit_memlock,
                 FDSet *fds,
@@ -1730,7 +1771,7 @@
                 const char *switch_root_init,
                 const char **ret_error_message) {
 
-        unsigned i, j, args_size;
+        unsigned i, args_size;
         const char **args;
         int r;
 
@@ -1760,11 +1801,11 @@
                         log_error_errno(r, "Failed to switch root, trying to continue: %m");
         }
 
-        args_size = MAX(6, argc+1);
+        args_size = argc + 6;
         args = newa(const char*, args_size);
 
         if (!switch_root_init) {
-                char sfd[DECIMAL_STR_MAX(int) + 1];
+                char sfd[DECIMAL_STR_MAX(int)];
 
                 /* First try to spawn ourselves with the right path, and with full serialization. We do this only if
                  * the user didn't specify an explicit init to spawn. */
@@ -1774,8 +1815,9 @@
 
                 xsprintf(sfd, "%i", fileno(arg_serialization));
 
-                i = 0;
-                args[i++] = SYSTEMD_BINARY_PATH;
+                i = 1;         /* Leave args[0] empty for now. */
+                filter_args(args, &i, argv, argc);
+
                 if (switch_root_dir)
                         args[i++] = "--switched-root";
                 args[i++] = arg_system ? "--system" : "--user";
@@ -1793,8 +1835,9 @@
                  */
                 valgrind_summary_hack();
 
+                args[0] = SYSTEMD_BINARY_PATH;
                 (void) execv(args[0], (char* const*) args);
-                log_debug_errno(errno, "Failed to execute our own binary, trying fallback: %m");
+                log_debug_errno(errno, "Failed to execute our own binary %s, trying fallback: %m", args[0]);
         }
 
         /* Try the fallback, if there is any, without any serialization. We pass the original argv[] and envp[]. (Well,
@@ -1807,9 +1850,9 @@
         /* Reopen the console */
         (void) make_console_stdio();
 
-        for (j = 1, i = 1; j < (unsigned) argc; j++)
+        i = 1;         /* Leave args[0] empty for now. */
+        for (int j = 1; j <= argc; j++)
                 args[i++] = argv[j];
-        args[i++] = NULL;
         assert(i <= args_size);
 
         /* Re-enable any blocked signals, especially important if we switch from initial ramdisk to init=... */
@@ -1820,7 +1863,7 @@
         if (switch_root_init) {
                 args[0] = switch_root_init;
                 (void) execve(args[0], (char* const*) args, saved_env);
-                log_warning_errno(errno, "Failed to execute configured init, trying fallback: %m");
+                log_warning_errno(errno, "Failed to execute configured init %s, trying fallback: %m", args[0]);
         }
 
         args[0] = "/sbin/init";
@@ -2411,6 +2454,9 @@
         /* Push variables into the manager environment block */
         setenv_manager_environment();
 
+        /* Parse log environment variables again to take into account any new environment variables. */
+        log_parse_environment();
+
         return 0;
 }
 
diff -aruN old/src/core/manager.c new/src/core/manager.c
--- old/src/core/manager.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/manager.c	2021-11-19 17:19:28.000000000 +0000
@@ -1410,6 +1410,10 @@
         assert(!m->cleanup_queue);
         assert(!m->gc_unit_queue);
         assert(!m->gc_job_queue);
+        assert(!m->cgroup_realize_queue);
+        assert(!m->cgroup_empty_queue);
+        assert(!m->cgroup_oom_queue);
+        assert(!m->target_deps_queue);
         assert(!m->stop_when_unneeded_queue);
         assert(!m->start_when_upheld_queue);
         assert(!m->stop_when_bound_queue);
diff -aruN old/src/core/manager.h new/src/core/manager.h
--- old/src/core/manager.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/manager.h	2021-11-19 17:19:28.000000000 +0000
@@ -195,7 +195,7 @@
 
         sd_event *event;
 
-        /* This maps PIDs we care about to units that are interested in. We allow multiple units to he interested in
+        /* This maps PIDs we care about to units that are interested in. We allow multiple units to be interested in
          * the same PID and multiple PIDs to be relevant to the same unit. Since in most cases only a single unit will
          * be interested in the same PID we use a somewhat special encoding here: the first unit interested in a PID is
          * stored directly in the hashmap, keyed by the PID unmodified. If there are other units interested too they'll
diff -aruN old/src/core/meson.build new/src/core/meson.build
--- old/src/core/meson.build	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/meson.build	2021-11-19 17:19:28.000000000 +0000
@@ -193,7 +193,7 @@
                 output: file,
                 command : [meson_render_jinja2, config_h, '@INPUT@'],
                 capture : true,
-                install : dir != 'no',
+                install : (dir == pkgsysconfdir) ? install_sysconfdir_samples : (dir != 'no'),
                 install_dir : dir)
 endforeach
 
diff -aruN old/src/core/mount.c new/src/core/mount.c
--- old/src/core/mount.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/mount.c	2021-11-19 17:19:28.000000000 +0000
@@ -1582,6 +1582,10 @@
         if (r < 0)
                 return r;
 
+        r = mount_add_non_exec_dependencies(MOUNT(u));
+        if (r < 0)
+                return r;
+
         /* This unit was generated because /proc/self/mountinfo reported it. Remember this, so that by the time we load
          * the unit file for it (and thus add in extra deps right after) we know what source to attributes the deps
          * to. */
diff -aruN old/src/core/scope.c new/src/core/scope.c
--- old/src/core/scope.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/scope.c	2021-11-19 17:19:28.000000000 +0000
@@ -374,6 +374,12 @@
                 scope_enter_dead(s, SCOPE_FAILURE_RESOURCES);
                 return r;
         }
+        if (r == 0) {
+                log_unit_warning(u, "No PIDs left to attach to the scope's control group, refusing: %m");
+                scope_enter_dead(s, SCOPE_FAILURE_RESOURCES);
+                return -ECHILD;
+        }
+        log_unit_debug(u, "%i %s added to scope's control group.", r, r == 1 ? "process" : "processes");
 
         s->result = SCOPE_SUCCESS;
 
diff -aruN old/src/core/service.c new/src/core/service.c
--- old/src/core/service.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/service.c	2021-11-19 17:19:28.000000000 +0000
@@ -548,6 +548,22 @@
         assert(s);
         assert(UNIT(s)->load_state == UNIT_LOADED);
 
+        for (ServiceExecCommand c = 0; c < _SERVICE_EXEC_COMMAND_MAX; c++) {
+                ExecCommand *command;
+
+                LIST_FOREACH(command, command, s->exec_command[c]) {
+                        if (!path_is_absolute(command->path) && !filename_is_valid(command->path))
+                                return log_unit_error_errno(UNIT(s), SYNTHETIC_ERRNO(ENOEXEC),
+                                                            "Service %s= binary path \"%s\" is neither a valid executable name nor an absolute path. Refusing.",
+                                                            command->path,
+                                                            service_exec_command_to_string(c));
+                        if (strv_isempty(command->argv))
+                                return log_unit_error_errno(UNIT(s), SYNTHETIC_ERRNO(ENOEXEC),
+                                                            "Service has an empty argv in %s=. Refusing.",
+                                                            service_exec_command_to_string(c));
+                }
+        }
+
         if (!s->exec_command[SERVICE_EXEC_START] && !s->exec_command[SERVICE_EXEC_STOP] &&
             UNIT(s)->success_action == EMERGENCY_ACTION_NONE)
                 /* FailureAction= only makes sense if one of the start or stop commands is specified.
diff -aruN old/src/core/socket.c new/src/core/socket.c
--- old/src/core/socket.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/socket.c	2021-11-19 17:19:28.000000000 +0000
@@ -34,6 +34,7 @@
 #include "process-util.h"
 #include "selinux-util.h"
 #include "serialize.h"
+#include "service.h"
 #include "signal-util.h"
 #include "smack-util.h"
 #include "socket.h"
diff -aruN old/src/core/socket.h new/src/core/socket.h
--- old/src/core/socket.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/socket.h	2021-11-19 17:19:28.000000000 +0000
@@ -5,7 +5,6 @@
 typedef struct SocketPeer SocketPeer;
 
 #include "mount.h"
-#include "service.h"
 #include "socket-util.h"
 #include "unit.h"
 
diff -aruN old/src/core/unit.c new/src/core/unit.c
--- old/src/core/unit.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/core/unit.c	2021-11-19 17:19:28.000000000 +0000
@@ -427,7 +427,7 @@
 
                 r = cg_is_empty_recursive(SYSTEMD_CGROUP_CONTROLLER, u->cgroup_path);
                 if (r < 0)
-                        log_unit_debug_errno(u, r, "Failed to determine whether cgroup %s is empty: %m", u->cgroup_path);
+                        log_unit_debug_errno(u, r, "Failed to determine whether cgroup %s is empty: %m", empty_to_root(u->cgroup_path));
                 if (r <= 0)
                         return false;
         }
@@ -733,6 +733,9 @@
         if (u->in_dbus_queue)
                 LIST_REMOVE(dbus_queue, u->manager->dbus_unit_queue, u);
 
+        if (u->in_cleanup_queue)
+                LIST_REMOVE(cleanup_queue, u->manager->cleanup_queue, u);
+
         if (u->in_gc_queue)
                 LIST_REMOVE(gc_queue, u->manager->gc_unit_queue, u);
 
@@ -742,8 +745,8 @@
         if (u->in_cgroup_empty_queue)
                 LIST_REMOVE(cgroup_empty_queue, u->manager->cgroup_empty_queue, u);
 
-        if (u->in_cleanup_queue)
-                LIST_REMOVE(cleanup_queue, u->manager->cleanup_queue, u);
+        if (u->in_cgroup_oom_queue)
+                LIST_REMOVE(cgroup_oom_queue, u->manager->cgroup_oom_queue, u);
 
         if (u->in_target_deps_queue)
                 LIST_REMOVE(target_deps_queue, u->manager->target_deps_queue, u);
@@ -3578,7 +3581,6 @@
 int unit_coldplug(Unit *u) {
         int r = 0, q;
         char **i;
-        Job *uj;
 
         assert(u);
 
@@ -3601,9 +3603,13 @@
                         r = q;
         }
 
-        uj = u->job ?: u->nop_job;
-        if (uj) {
-                q = job_coldplug(uj);
+        if (u->job) {
+                q = job_coldplug(u->job);
+                if (q < 0 && r >= 0)
+                        r = q;
+        }
+        if (u->nop_job) {
+                q = job_coldplug(u->nop_job);
                 if (q < 0 && r >= 0)
                         r = q;
         }
@@ -3616,6 +3622,8 @@
 
         if (UNIT_VTABLE(u)->catchup)
                 UNIT_VTABLE(u)->catchup(u);
+
+        unit_cgroup_catchup(u);
 }
 
 static bool fragment_mtime_newer(const char *path, usec_t mtime, bool path_masked) {
@@ -4553,7 +4561,7 @@
                                       log_func, u);
                 if (r < 0) {
                         if (!IN_SET(r, -EAGAIN, -ESRCH, -ENOENT))
-                                log_unit_warning_errno(u, r, "Failed to kill control group %s, ignoring: %m", u->cgroup_path);
+                                log_unit_warning_errno(u, r, "Failed to kill control group %s, ignoring: %m", empty_to_root(u->cgroup_path));
 
                 } else if (r > 0) {
 
@@ -5011,7 +5019,7 @@
         if (u->cgroup_path) {
                 r = cg_attach_everywhere(u->manager->cgroup_supported, u->cgroup_path, 0, NULL, NULL);
                 if (r < 0) {
-                        log_unit_error_errno(u, r, "Failed to join unit cgroup %s: %m", u->cgroup_path);
+                        log_unit_error_errno(u, r, "Failed to join unit cgroup %s: %m", empty_to_root(u->cgroup_path));
                         _exit(EXIT_CGROUP);
                 }
         }
diff -aruN old/src/coredump/coredump.c new/src/coredump/coredump.c
--- old/src/coredump/coredump.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/coredump/coredump.c	2021-11-19 17:19:28.000000000 +0000
@@ -525,6 +525,7 @@
         if (lseek(fd, 0, SEEK_SET) == (off_t) -1)
                 return log_error_errno(errno, "Failed to seek on coredump %s: %m", fn);
 
+        *ret_filename = TAKE_PTR(fn);
         *ret_data_fd = TAKE_FD(fd);
         *ret_size = (uint64_t) st.st_size;
         *ret_truncated = truncated;
diff -aruN old/src/coredump/coredumpctl.c new/src/coredump/coredumpctl.c
--- old/src/coredump/coredumpctl.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/coredump/coredumpctl.c	2021-11-19 17:19:28.000000000 +0000
@@ -555,6 +555,8 @@
         assert(file);
         assert(j);
 
+        (void) sd_journal_set_data_threshold(j, 0);
+
         SD_JOURNAL_FOREACH_DATA(j, d, l) {
                 RETRIEVE(d, l, "MESSAGE_ID", mid);
                 RETRIEVE(d, l, "COREDUMP_PID", pid);
@@ -1186,6 +1188,10 @@
                 return false;
 
         r = sd_bus_default_system(&bus);
+        if (r == -ENOENT) {
+                log_debug("D-Bus is not running, skipping active unit check");
+                return 0;
+        }
         if (r < 0)
                 return log_error_errno(r, "Failed to acquire bus: %m");
 
diff -aruN old/src/coredump/stacktrace.c new/src/coredump/stacktrace.c
--- old/src/coredump/stacktrace.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/coredump/stacktrace.c	2021-11-19 17:19:28.000000000 +0000
@@ -153,6 +153,8 @@
                                             program_header->p_offset,
                                             program_header->p_filesz,
                                             ELF_T_NHDR);
+                if (!data)
+                        continue;
 
                 while (note_offset < data->d_size &&
                        (note_offset = gelf_getnote(data, note_offset, &note_header, &name_offset, &desc_offset)) > 0) {
@@ -297,6 +299,8 @@
                                             program_header->p_offset,
                                             program_header->p_filesz,
                                             ELF_T_NHDR);
+                if (!data)
+                        continue;
 
                 Elf *memelf = elf_memory(data->d_buf, data->d_size);
                 if (!memelf)
diff -aruN old/src/fstab-generator/fstab-generator.c new/src/fstab-generator/fstab-generator.c
--- old/src/fstab-generator/fstab-generator.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/fstab-generator/fstab-generator.c	2021-11-19 17:19:28.000000000 +0000
@@ -435,7 +435,8 @@
 
         /* Order the mount unit we generate relative to the post unit, so that DefaultDependencies= on the
          * target unit won't affect us. */
-        if (post && !FLAGS_SET(flags, MOUNT_AUTOMOUNT) && !FLAGS_SET(flags, MOUNT_NOAUTO))
+        if (post && !FLAGS_SET(flags, MOUNT_AUTOMOUNT) && !FLAGS_SET(flags, MOUNT_NOAUTO) &&
+            !FLAGS_SET(flags, MOUNT_NOFAIL))
                 fprintf(f, "Before=%s\n", post);
 
         if (passno != 0) {
diff -aruN old/src/home/homework.c new/src/home/homework.c
--- old/src/home/homework.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/home/homework.c	2021-11-19 17:19:28.000000000 +0000
@@ -1651,6 +1651,8 @@
 
         log_setup();
 
+        cryptsetup_enable_logging(NULL);
+
         umask(0022);
 
         if (argc < 2 || argc > 3)
diff -aruN old/src/home/homework-cifs.c new/src/home/homework-cifs.c
--- old/src/home/homework-cifs.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/home/homework-cifs.c	2021-11-19 17:19:28.000000000 +0000
@@ -58,8 +58,8 @@
 
                         f = safe_fclose(f);
 
-                        if (asprintf(&options, "credentials=%s,uid=" UID_FMT ",forceuid,gid=" UID_FMT ",forcegid,file_mode=0%3o,dir_mode=0%3o",
-                                     p, h->uid, h->uid, h->access_mode, h->access_mode) < 0)
+                        if (asprintf(&options, "credentials=%s,uid=" UID_FMT ",forceuid,gid=" GID_FMT ",forcegid,file_mode=0%3o,dir_mode=0%3o",
+                                     p, h->uid, user_record_gid(h), user_record_access_mode(h), user_record_access_mode(h)) < 0)
                                 return log_oom();
 
                         r = safe_fork("(mount)", FORK_RESET_SIGNALS|FORK_RLIMIT_NOFILE_SAFE|FORK_DEATHSIG|FORK_LOG|FORK_STDOUT_TO_STDERR, &mount_pid);
@@ -71,7 +71,7 @@
                                       h->cifs_service, "/run/systemd/user-home-mount",
                                       "-o", options, NULL);
 
-                                log_error_errno(errno, "Failed to execute fsck: %m");
+                                log_error_errno(errno, "Failed to execute mount: %m");
                                 _exit(EXIT_FAILURE);
                         }
 
@@ -86,7 +86,8 @@
                 }
 
                 if (!mounted)
-                        return log_error_errno(ENOKEY, "Failed to mount home directory with supplied password.");
+                        return log_error_errno(SYNTHETIC_ERRNO(ENOKEY),
+                                               "Failed to mount home directory with supplied password.");
 
                 setup->root_fd = open("/run/systemd/user-home-mount", O_RDONLY|O_CLOEXEC|O_DIRECTORY|O_NOFOLLOW);
         }
diff -aruN old/src/home/homework-luks.c new/src/home/homework-luks.c
--- old/src/home/homework-luks.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/home/homework-luks.c	2021-11-19 17:19:28.000000000 +0000
@@ -8,6 +8,10 @@
 #include <sys/mount.h>
 #include <sys/xattr.h>
 
+#if HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
 #include "blkid-util.h"
 #include "blockdev-util.h"
 #include "btrfs-util.h"
@@ -1136,6 +1140,10 @@
                                 offset *= 512U;
                         }
                 } else {
+#if HAVE_VALGRIND_MEMCHECK_H
+                        VALGRIND_MAKE_MEM_DEFINED(&info, sizeof(info));
+#endif
+
                         offset = info.lo_offset;
                         size = info.lo_sizelimit;
                 }
@@ -1146,7 +1154,7 @@
 
                 root_fd = open(user_record_home_directory(h), O_RDONLY|O_CLOEXEC|O_DIRECTORY|O_NOFOLLOW);
                 if (root_fd < 0) {
-                        r = log_error_errno(r, "Failed to open home directory: %m");
+                        r = log_error_errno(errno, "Failed to open home directory: %m");
                         goto fail;
                 }
         } else {
@@ -1233,7 +1241,7 @@
 
                 root_fd = open(subdir, O_RDONLY|O_CLOEXEC|O_DIRECTORY|O_NOFOLLOW);
                 if (root_fd < 0) {
-                        r = log_error_errno(r, "Failed to open home directory: %m");
+                        r = log_error_errno(errno, "Failed to open home directory: %m");
                         goto fail;
                 }
 
@@ -2813,7 +2821,7 @@
                 if (r > 0)
                         log_info("Growing of partition completed.");
 
-                if (ioctl(image_fd, BLKRRPART, 0) < 0)
+                if (S_ISBLK(st.st_mode) && ioctl(image_fd, BLKRRPART, 0) < 0)
                         log_debug_errno(errno, "BLKRRPART failed on block device, ignoring: %m");
 
                 /* Tell LUKS about the new bigger size too */
@@ -2887,7 +2895,7 @@
                 if (r > 0)
                         log_info("Shrinking of partition completed.");
 
-                if (ioctl(image_fd, BLKRRPART, 0) < 0)
+                if (S_ISBLK(st.st_mode) && ioctl(image_fd, BLKRRPART, 0) < 0)
                         log_debug_errno(errno, "BLKRRPART failed on block device, ignoring: %m");
         } else {
                 r = home_store_embedded_identity(new_home, setup->root_fd, h->uid, embedded_home);
diff -aruN old/src/home/homework-mount.c new/src/home/homework-mount.c
--- old/src/home/homework-mount.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/home/homework-mount.c	2021-11-19 17:19:28.000000000 +0000
@@ -69,9 +69,10 @@
         const char *d;
         int r;
 
-        assert(user_name_and_realm);
         assert(target);
 
+        /* If user_name_and_realm is set, then we'll mount a subdir of the source mount into the host. If
+         * it's NULL we'll move the mount itself */
         if (user_name_and_realm) {
                 subdir = path_join("/run/systemd/user-home-mount/", user_name_and_realm);
                 if (!subdir)
diff -aruN old/src/home/pam_systemd_home.c new/src/home/pam_systemd_home.c
--- old/src/home/pam_systemd_home.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/home/pam_systemd_home.c	2021-11-19 17:19:28.000000000 +0000
@@ -281,7 +281,6 @@
                 const sd_bus_error *error) {
 
         assert(user_name);
-        assert(secret);
         assert(error);
 
         int r;
@@ -301,6 +300,8 @@
         } else if (sd_bus_error_has_name(error, BUS_ERROR_BAD_PASSWORD)) {
                 _cleanup_(erase_and_freep) char *newp = NULL;
 
+                assert(secret);
+
                 /* This didn't work? Ask for an (additional?) password */
 
                 if (strv_isempty(secret->password))
@@ -326,6 +327,8 @@
         } else if (sd_bus_error_has_name(error, BUS_ERROR_BAD_PASSWORD_AND_NO_TOKEN)) {
                 _cleanup_(erase_and_freep) char *newp = NULL;
 
+                assert(secret);
+
                 if (strv_isempty(secret->password)) {
                         (void) pam_prompt(handle, PAM_ERROR_MSG, NULL, "Security token of user %s not inserted.", user_name);
                         r = pam_prompt(handle, PAM_PROMPT_ECHO_OFF, &newp, "Try again with password: ");
@@ -350,6 +353,8 @@
         } else if (sd_bus_error_has_name(error, BUS_ERROR_TOKEN_PIN_NEEDED)) {
                 _cleanup_(erase_and_freep) char *newp = NULL;
 
+                assert(secret);
+
                 r = pam_prompt(handle, PAM_PROMPT_ECHO_OFF, &newp, "Security token PIN: ");
                 if (r != PAM_SUCCESS)
                         return PAM_CONV_ERR; /* no logging here */
@@ -367,6 +372,8 @@
 
         } else if (sd_bus_error_has_name(error, BUS_ERROR_TOKEN_PROTECTED_AUTHENTICATION_PATH_NEEDED)) {
 
+                assert(secret);
+
                 (void) pam_prompt(handle, PAM_ERROR_MSG, NULL, "Please authenticate physically on security token of user %s.", user_name);
 
                 r = user_record_set_pkcs11_protected_authentication_path_permitted(secret, true);
@@ -377,6 +384,8 @@
 
         } else if (sd_bus_error_has_name(error, BUS_ERROR_TOKEN_USER_PRESENCE_NEEDED)) {
 
+                assert(secret);
+
                 (void) pam_prompt(handle, PAM_ERROR_MSG, NULL, "Please confirm presence on security token of user %s.", user_name);
 
                 r = user_record_set_fido2_user_presence_permitted(secret, true);
@@ -387,6 +396,8 @@
 
         } else if (sd_bus_error_has_name(error, BUS_ERROR_TOKEN_USER_VERIFICATION_NEEDED)) {
 
+                assert(secret);
+
                 (void) pam_prompt(handle, PAM_ERROR_MSG, NULL, "Please verify user on security token of user %s.", user_name);
 
                 r = user_record_set_fido2_user_verification_permitted(secret, true);
@@ -403,6 +414,8 @@
         } else if (sd_bus_error_has_name(error, BUS_ERROR_TOKEN_BAD_PIN)) {
                 _cleanup_(erase_and_freep) char *newp = NULL;
 
+                assert(secret);
+
                 (void) pam_prompt(handle, PAM_ERROR_MSG, NULL, "Security token PIN incorrect for user %s.", user_name);
                 r = pam_prompt(handle, PAM_PROMPT_ECHO_OFF, &newp, "Sorry, retry security token PIN: ");
                 if (r != PAM_SUCCESS)
@@ -422,6 +435,8 @@
         } else if (sd_bus_error_has_name(error, BUS_ERROR_TOKEN_BAD_PIN_FEW_TRIES_LEFT)) {
                 _cleanup_(erase_and_freep) char *newp = NULL;
 
+                assert(secret);
+
                 (void) pam_prompt(handle, PAM_ERROR_MSG, NULL, "Security token PIN of user %s incorrect (only a few tries left!)", user_name);
                 r = pam_prompt(handle, PAM_PROMPT_ECHO_OFF, &newp, "Sorry, retry security token PIN: ");
                 if (r != PAM_SUCCESS)
@@ -441,6 +456,8 @@
         } else if (sd_bus_error_has_name(error, BUS_ERROR_TOKEN_BAD_PIN_ONE_TRY_LEFT)) {
                 _cleanup_(erase_and_freep) char *newp = NULL;
 
+                assert(secret);
+
                 (void) pam_prompt(handle, PAM_ERROR_MSG, NULL, "Security token PIN of user %s incorrect (only one try left!)", user_name);
                 r = pam_prompt(handle, PAM_PROMPT_ECHO_OFF, &newp, "Sorry, retry security token PIN: ");
                 if (r != PAM_SUCCESS)
diff -aruN old/src/hostname/hostnamectl.c new/src/hostname/hostnamectl.c
--- old/src/hostname/hostnamectl.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/hostname/hostnamectl.c	2021-11-19 17:19:28.000000000 +0000
@@ -442,7 +442,7 @@
                  * dot if there is one. If it was not valid, then it will be made fully valid by truncating, dropping
                  * multiple dots, and dropping weird chars. Note that we clean the name up only if we also are
                  * supposed to set the pretty name. If the pretty name is not being set we assume the user knows what
-                 * he does and pass the name as-is. */
+                 * they are doing and pass the name as-is. */
                 h = strdup(hostname);
                 if (!h)
                         return log_oom();
diff -aruN old/src/hostname/hostnamed.c new/src/hostname/hostnamed.c
--- old/src/hostname/hostnamed.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/hostname/hostnamed.c	2021-11-19 17:19:28.000000000 +0000
@@ -204,14 +204,14 @@
 
         r = read_one_line_file("/sys/class/dmi/id/chassis_type", &type);
         if (r < 0) {
-                log_debug_errno(v, "Failed to read DMI chassis type, ignoring: %m");
+                log_debug_errno(r, "Failed to read DMI chassis type, ignoring: %m");
                 goto try_acpi;
         }
 
         r = safe_atou(type, &t);
         free(type);
         if (r < 0) {
-                log_debug_errno(v, "Failed to parse DMI chassis type, ignoring: %m");
+                log_debug_errno(r, "Failed to parse DMI chassis type, ignoring: %m");
                 goto try_acpi;
         }
 
@@ -260,14 +260,14 @@
 try_acpi:
         r = read_one_line_file("/sys/firmware/acpi/pm_profile", &type);
         if (r < 0) {
-                log_debug_errno(v, "Failed read ACPI PM profile, ignoring: %m");
+                log_debug_errno(r, "Failed read ACPI PM profile, ignoring: %m");
                 return NULL;
         }
 
         r = safe_atou(type, &t);
         free(type);
         if (r < 0) {
-                log_debug_errno(v, "Failed parse ACPI PM profile, ignoring: %m");
+                log_debug_errno(r, "Failed parse ACPI PM profile, ignoring: %m");
                 return NULL;
         }
 
diff -aruN old/src/hwdb/hwdb.c new/src/hwdb/hwdb.c
--- old/src/hwdb/hwdb.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/hwdb/hwdb.c	2021-11-19 17:19:28.000000000 +0000
@@ -43,7 +43,7 @@
                "     --version    Show package version\n"
                "  -s --strict     When updating, return non-zero exit value on any parsing error\n"
                "     --usr        Generate in " UDEVLIBEXECDIR " instead of /etc/udev\n"
-               "  -r --root=PATH  Alternative root path in the filesystem\n\n"
+               "  -r --root=PATH  Alternative root path in the filesystem\n"
                "\nSee the %s for details.\n",
                program_invocation_short_name,
                ansi_highlight(),
diff -aruN old/src/import/curl-util.c new/src/import/curl-util.c
--- old/src/import/curl-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/import/curl-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -256,6 +256,9 @@
         if (curl_easy_setopt(c, CURLOPT_LOW_SPEED_LIMIT, 30L) != CURLE_OK)
                 return -EIO;
 
+        if (curl_easy_setopt(c, CURLOPT_PROTOCOLS, CURLPROTO_HTTP|CURLPROTO_HTTPS|CURLPROTO_FILE) != CURLE_OK)
+                return -EIO;
+
         *ret = TAKE_PTR(c);
         return 0;
 }
diff -aruN old/src/journal/journalctl.c new/src/journal/journalctl.c
--- old/src/journal/journalctl.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/journal/journalctl.c	2021-11-19 17:19:28.000000000 +0000
@@ -2074,6 +2074,11 @@
 }
 
 static int flush_to_var(void) {
+        if (access("/run/systemd/journal/flushed", F_OK) >= 0)
+                return 0; /* Already flushed, no need to contact journald */
+        if (errno != ENOENT)
+                return log_error_errno(errno, "Unable to check for existence of /run/systemd/journal/flushed: %m");
+
         return simple_varlink_call("--flush", "io.systemd.Journal.FlushToVar");
 }
 
diff -aruN old/src/journal/journald-server.c new/src/journal/journald-server.c
--- old/src/journal/journald-server.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/journal/journald-server.c	2021-11-19 17:19:28.000000000 +0000
@@ -415,6 +415,13 @@
         if (s->runtime_journal)
                 return s->runtime_journal;
 
+        /* If we are not in persistent mode, then we need return NULL immediately rather than opening a
+         * persistent journal of any sort.
+         *
+         * Fixes https://github.com/systemd/systemd/issues/20390 */
+        if (!IN_SET(s->storage, STORAGE_AUTO, STORAGE_PERSISTENT))
+                return NULL;
+
         if (uid_for_system_journal(uid))
                 return s->system_journal;
 
@@ -1268,11 +1275,14 @@
         /* We use NAME_MAX space for the SELinux label here. The kernel currently enforces no limit, but
          * according to suggestions from the SELinux people this will change and it will probably be
          * identical to NAME_MAX. For now we use that, but this should be updated one day when the final
-         * limit is known. */
+         * limit is known.
+         *
+         * Here, we need to explicitly initialize the buffer with zero, as glibc has a bug in
+         * __convert_scm_timestamps(), which assumes the buffer is initialized. See #20741. */
         CMSG_BUFFER_TYPE(CMSG_SPACE(sizeof(struct ucred)) +
-                         CMSG_SPACE(sizeof(struct timeval)) +
+                         CMSG_SPACE_TIMEVAL +
                          CMSG_SPACE(sizeof(int)) + /* fd */
-                         CMSG_SPACE(NAME_MAX) /* selinux label */) control;
+                         CMSG_SPACE(NAME_MAX) /* selinux label */) control = {};
 
         union sockaddr_union sa = {};
 
diff -aruN old/src/journal/journald-stream.c new/src/journal/journald-stream.c
--- old/src/journal/journald-stream.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/journal/journald-stream.c	2021-11-19 17:19:28.000000000 +0000
@@ -108,7 +108,6 @@
                 return NULL;
 
         if (s->server) {
-
                 if (s->context)
                         client_context_release(s->server, s->context);
 
@@ -122,11 +121,7 @@
                 (void) server_start_or_stop_idle_timer(s->server); /* Maybe we are idle now? */
         }
 
-        if (s->event_source) {
-                sd_event_source_set_enabled(s->event_source, SD_EVENT_OFF);
-                s->event_source = sd_event_source_unref(s->event_source);
-        }
-
+        sd_event_source_disable_unref(s->event_source);
         safe_close(s->fd);
         free(s->label);
         free(s->identifier);
diff -aruN old/src/libsystemd/sd-bus/bus-socket.c new/src/libsystemd/sd-bus/bus-socket.c
--- old/src/libsystemd/sd-bus/bus-socket.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd/sd-bus/bus-socket.c	2021-11-19 17:19:28.000000000 +0000
@@ -300,8 +300,8 @@
         uid_t u;
         int r;
 
-        /* We don't do any real authentication here. Instead, we if
-         * the owner of this bus wanted authentication he should have
+        /* We don't do any real authentication here. Instead, if 
+         * the owner of this bus wanted authentication they should have
          * checked SO_PEERCRED before even creating the bus object. */
 
         if (!b->anonymous_auth && !b->ucred_valid)
diff -aruN old/src/libsystemd/sd-bus/sd-bus.c new/src/libsystemd/sd-bus/sd-bus.c
--- old/src/libsystemd/sd-bus/sd-bus.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd/sd-bus/sd-bus.c	2021-11-19 17:19:28.000000000 +0000
@@ -62,7 +62,6 @@
 
 static int bus_poll(sd_bus *bus, bool need_more, uint64_t timeout_usec);
 static void bus_detach_io_events(sd_bus *b);
-static void bus_detach_inotify_event(sd_bus *b);
 
 static thread_local sd_bus *default_system_bus = NULL;
 static thread_local sd_bus *default_user_bus = NULL;
@@ -139,7 +138,7 @@
 void bus_close_inotify_fd(sd_bus *b) {
         assert(b);
 
-        bus_detach_inotify_event(b);
+        b->inotify_event_source = sd_event_source_disable_unref(b->inotify_event_source);
 
         b->inotify_fd = safe_close(b->inotify_fd);
         b->inotify_watches = mfree(b->inotify_watches);
@@ -3275,7 +3274,7 @@
                         return e;
 
                 if (need_more)
-                        /* The caller really needs some more data, he doesn't
+                        /* The caller really needs some more data, they don't
                          * care about what's already read, or any timeouts
                          * except its own. */
                         e |= POLLIN;
@@ -3738,15 +3737,8 @@
 static void bus_detach_io_events(sd_bus *bus) {
         assert(bus);
 
-        if (bus->input_io_event_source) {
-                sd_event_source_set_enabled(bus->input_io_event_source, SD_EVENT_OFF);
-                bus->input_io_event_source = sd_event_source_unref(bus->input_io_event_source);
-        }
-
-        if (bus->output_io_event_source) {
-                sd_event_source_set_enabled(bus->output_io_event_source, SD_EVENT_OFF);
-                bus->output_io_event_source = sd_event_source_unref(bus->output_io_event_source);
-        }
+        bus->input_io_event_source = sd_event_source_disable_unref(bus->input_io_event_source);
+        bus->output_io_event_source = sd_event_source_disable_unref(bus->output_io_event_source);
 }
 
 int bus_attach_inotify_event(sd_bus *bus) {
@@ -3778,15 +3770,6 @@
         return 0;
 }
 
-static void bus_detach_inotify_event(sd_bus *bus) {
-        assert(bus);
-
-        if (bus->inotify_event_source) {
-                sd_event_source_set_enabled(bus->inotify_event_source, SD_EVENT_OFF);
-                bus->inotify_event_source = sd_event_source_unref(bus->inotify_event_source);
-        }
-}
-
 _public_ int sd_bus_attach_event(sd_bus *bus, sd_event *event, int priority) {
         int r;
 
@@ -3851,17 +3834,9 @@
                 return 0;
 
         bus_detach_io_events(bus);
-        bus_detach_inotify_event(bus);
-
-        if (bus->time_event_source) {
-                sd_event_source_set_enabled(bus->time_event_source, SD_EVENT_OFF);
-                bus->time_event_source = sd_event_source_unref(bus->time_event_source);
-        }
-
-        if (bus->quit_event_source) {
-                sd_event_source_set_enabled(bus->quit_event_source, SD_EVENT_OFF);
-                bus->quit_event_source = sd_event_source_unref(bus->quit_event_source);
-        }
+        bus->inotify_event_source = sd_event_source_disable_unref(bus->inotify_event_source);
+        bus->time_event_source = sd_event_source_disable_unref(bus->time_event_source);
+        bus->quit_event_source = sd_event_source_disable_unref(bus->quit_event_source);
 
         bus->event = sd_event_unref(bus->event);
         return 1;
diff -aruN old/src/libsystemd/sd-device/device-monitor.c new/src/libsystemd/sd-device/device-monitor.c
--- old/src/libsystemd/sd-device/device-monitor.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd/sd-device/device-monitor.c	2021-11-19 17:19:28.000000000 +0000
@@ -178,7 +178,7 @@
 
                 netns = ioctl(m->sock, SIOCGSKNS);
                 if (netns < 0)
-                        log_debug_errno(errno, "sd-device-monitor: Unable to get network namespace of udev netlink socket, unable to determine if we are in host netns: %m");
+                        log_debug_errno(errno, "sd-device-monitor: Unable to get network namespace of udev netlink socket, unable to determine if we are in host netns, ignoring: %m");
                 else {
                         struct stat a, b;
 
@@ -191,9 +191,9 @@
                                 if (ERRNO_IS_PRIVILEGE(errno))
                                         /* If we can't access PID1's netns info due to permissions, it's fine, this is a
                                          * safety check only after all. */
-                                        log_debug_errno(errno, "sd-device-monitor: No permission to stat PID1's netns, unable to determine if we are in host netns: %m");
+                                        log_debug_errno(errno, "sd-device-monitor: No permission to stat PID1's netns, unable to determine if we are in host netns, ignoring: %m");
                                 else
-                                        log_debug_errno(errno, "sd-device-monitor: Failed to stat PID1's netns: %m");
+                                        log_debug_errno(errno, "sd-device-monitor: Failed to stat PID1's netns, ignoring: %m");
 
                         } else if (a.st_dev != b.st_dev || a.st_ino != b.st_ino)
                                 log_debug("sd-device-monitor: Netlink socket we listen on is not from host netns, we won't see device events.");
diff -aruN old/src/libsystemd/sd-event/event-source.h new/src/libsystemd/sd-event/event-source.h
--- old/src/libsystemd/sd-event/event-source.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd/sd-event/event-source.h	2021-11-19 17:19:28.000000000 +0000
@@ -214,6 +214,11 @@
          * the events locally if they can't be coalesced). */
         unsigned n_pending;
 
+        /* If this counter is non-zero, don't GC the inotify data object even if not used to watch any inode
+         * anymore. This is useful to pin the object for a bit longer, after the last event source needing it
+         * is gone. */
+        unsigned n_busy;
+
         /* A linked list of all inotify objects with data already read, that still need processing. We keep this list
          * to make it efficient to figure out what inotify objects to process data on next. */
         LIST_FIELDS(struct inotify_data, buffered);
diff -aruN old/src/libsystemd/sd-event/sd-event.c new/src/libsystemd/sd-event/sd-event.c
--- old/src/libsystemd/sd-event/sd-event.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd/sd-event/sd-event.c	2021-11-19 17:19:28.000000000 +0000
@@ -1820,6 +1820,29 @@
         free(d);
 }
 
+static void event_gc_inotify_data(
+                sd_event *e,
+                struct inotify_data *d) {
+
+        assert(e);
+
+        /* GCs the inotify data object if we don't need it anymore. That's the case if we don't want to watch
+         * any inode with it anymore, which in turn happens if no event source of this priority is interested
+         * in any inode any longer. That said, we maintain an extra busy counter: if non-zero we'll delay GC
+         * (under the expectation that the GC is called again once the counter is decremented). */
+
+        if (!d)
+                return;
+
+        if (!hashmap_isempty(d->inodes))
+                return;
+
+        if (d->n_busy > 0)
+                return;
+
+        event_free_inotify_data(e, d);
+}
+
 static void event_gc_inode_data(
                 sd_event *e,
                 struct inode_data *d) {
@@ -1837,8 +1860,7 @@
         inotify_data = d->inotify_data;
         event_free_inode_data(e, d);
 
-        if (inotify_data && hashmap_isempty(inotify_data->inodes))
-                event_free_inotify_data(e, inotify_data);
+        event_gc_inotify_data(e, inotify_data);
 }
 
 static int event_make_inode_data(
@@ -3556,13 +3578,23 @@
                 sz = offsetof(struct inotify_event, name) + d->buffer.ev.len;
                 assert(d->buffer_filled >= sz);
 
+                /* If the inotify callback destroys the event source then this likely means we don't need to
+                 * watch the inode anymore, and thus also won't need the inotify object anymore. But if we'd
+                 * free it immediately, then we couldn't drop the event from the inotify event queue without
+                 * memory corruption anymore, as below. Hence, let's not free it immediately, but mark it
+                 * "busy" with a counter (which will ensure it's not GC'ed away prematurely). Let's then
+                 * explicitly GC it after we are done dropping the inotify event from the buffer. */
+                d->n_busy++;
                 r = s->inotify.callback(s, &d->buffer.ev, s->userdata);
+                d->n_busy--;
 
-                /* When no event is pending anymore on this inotify object, then let's drop the event from the
-                 * buffer. */
+                /* When no event is pending anymore on this inotify object, then let's drop the event from
+                 * the inotify event queue buffer. */
                 if (d->n_pending == 0)
                         event_inotify_data_drop(e, d, sz);
 
+                /* Now we don't want to access 'd' anymore, it's OK to GC now. */
+                event_gc_inotify_data(e, d);
                 break;
         }
 
@@ -4154,7 +4186,7 @@
         assert_return(!event_pid_changed(e), -ECHILD);
         assert_return(e->state == SD_EVENT_INITIAL, -EBUSY);
 
-        _unused_ _cleanup_(sd_event_unrefp) sd_event *ref = NULL;
+        _unused_ _cleanup_(sd_event_unrefp) sd_event *ref = sd_event_ref(e);
 
         while (e->state != SD_EVENT_FINISHED) {
                 r = sd_event_run(e, UINT64_MAX);
diff -aruN old/src/libsystemd/sd-journal/sd-journal.c new/src/libsystemd/sd-journal/sd-journal.c
--- old/src/libsystemd/sd-journal/sd-journal.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd/sd-journal/sd-journal.c	2021-11-19 17:19:28.000000000 +0000
@@ -3158,7 +3158,11 @@
                         if (JOURNAL_HEADER_CONTAINS(of->header, n_fields) && le64toh(of->header->n_fields) <= 0)
                                 continue;
 
-                        r = journal_file_find_field_object_with_hash(of, o->field.payload, sz, le64toh(o->field.hash), NULL, NULL);
+                        if (!JOURNAL_HEADER_KEYED_HASH(f->header) && !JOURNAL_HEADER_KEYED_HASH(of->header))
+                                r = journal_file_find_field_object_with_hash(of, o->field.payload, sz,
+                                                                             le64toh(o->field.hash), NULL, NULL);
+                        else
+                                r = journal_file_find_field_object(of, o->field.payload, sz, NULL, NULL);
                         if (r < 0)
                                 return r;
                         if (r > 0) {
@@ -3174,7 +3178,7 @@
                 if (memchr(o->field.payload, 0, sz))
                         return -EBADMSG;
 
-                if (sz > j->data_threshold)
+                if (j->data_threshold > 0 && sz > j->data_threshold)
                         sz = j->data_threshold;
 
                 if (!GREEDY_REALLOC(j->fields_buffer, sz + 1))
diff -aruN old/src/libsystemd/sd-netlink/rtnl-message.c new/src/libsystemd/sd-netlink/rtnl-message.c
--- old/src/libsystemd/sd-netlink/rtnl-message.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd/sd-netlink/rtnl-message.c	2021-11-19 17:19:28.000000000 +0000
@@ -443,8 +443,12 @@
         if (r < 0)
                 return r;
 
-        if (nlmsg_type == RTM_NEWNEIGH)
-                (*ret)->hdr->nlmsg_flags |= NLM_F_CREATE | NLM_F_REPLACE;
+        if (nlmsg_type == RTM_NEWNEIGH) {
+                if (ndm_family == AF_BRIDGE)
+                        (*ret)->hdr->nlmsg_flags |= NLM_F_CREATE | NLM_F_APPEND;
+                else
+                        (*ret)->hdr->nlmsg_flags |= NLM_F_CREATE | NLM_F_REPLACE;
+        }
 
         ndm = NLMSG_DATA((*ret)->hdr);
 
diff -aruN old/src/libsystemd/sd-resolve/sd-resolve.c new/src/libsystemd/sd-resolve/sd-resolve.c
--- old/src/libsystemd/sd-resolve/sd-resolve.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd/sd-resolve/sd-resolve.c	2021-11-19 17:19:28.000000000 +0000
@@ -1285,11 +1285,7 @@
         if (!resolve->event)
                 return 0;
 
-        if (resolve->event_source) {
-                sd_event_source_set_enabled(resolve->event_source, SD_EVENT_OFF);
-                resolve->event_source = sd_event_source_unref(resolve->event_source);
-        }
-
+        resolve->event_source = sd_event_source_disable_unref(resolve->event_source);
         resolve->event = sd_event_unref(resolve->event);
         return 1;
 }
diff -aruN old/src/libsystemd-network/dhcp6-internal.h new/src/libsystemd-network/dhcp6-internal.h
--- old/src/libsystemd-network/dhcp6-internal.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/dhcp6-internal.h	2021-11-19 17:19:28.000000000 +0000
@@ -104,7 +104,7 @@
 int dhcp6_option_parse(uint8_t **buf, size_t *buflen, uint16_t *optcode,
                        size_t *optlen, uint8_t **optvalue);
 int dhcp6_option_parse_status(DHCP6Option *option, size_t len);
-int dhcp6_option_parse_ia(sd_dhcp6_client *client, DHCP6Option *iaoption, DHCP6IA *ia, uint16_t *ret_status_code);
+int dhcp6_option_parse_ia(sd_dhcp6_client *client, DHCP6Option *iaoption, be32_t iaid, DHCP6IA *ia, uint16_t *ret_status_code);
 int dhcp6_option_parse_ip6addrs(uint8_t *optval, uint16_t optlen,
                                 struct in6_addr **addrs, size_t count);
 int dhcp6_option_parse_domainname_list(const uint8_t *optval, uint16_t optlen,
diff -aruN old/src/libsystemd-network/dhcp6-option.c new/src/libsystemd-network/dhcp6-option.c
--- old/src/libsystemd-network/dhcp6-option.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/dhcp6-option.c	2021-11-19 17:19:28.000000000 +0000
@@ -509,7 +509,13 @@
         return 0;
 }
 
-int dhcp6_option_parse_ia(sd_dhcp6_client *client, DHCP6Option *iaoption, DHCP6IA *ia, uint16_t *ret_status_code) {
+int dhcp6_option_parse_ia(
+                sd_dhcp6_client *client,
+                DHCP6Option *iaoption,
+                be32_t iaid,
+                DHCP6IA *ia,
+                uint16_t *ret_status_code) {
+
         uint32_t lt_t1, lt_t2, lt_valid = 0, lt_min = UINT32_MAX;
         uint16_t iatype, optlen;
         size_t iaaddr_offset;
@@ -529,6 +535,14 @@
                 if (len < DHCP6_OPTION_IA_NA_LEN)
                         return -ENOBUFS;
 
+                /* According to RFC8415, IAs which do not match the client's IAID should be ignored,
+                 * but not necessary to ignore or refuse the whole message. */
+                if (((const struct ia_na*) iaoption->data)->id != iaid)
+                        /* ENOANO indicates the option should be ignored. */
+                        return log_dhcp6_client_errno(client, SYNTHETIC_ERRNO(ENOANO),
+                                                      "Received an IA_NA option with a different IAID "
+                                                      "from the one chosen by the client, ignoring.");
+
                 iaaddr_offset = DHCP6_OPTION_IA_NA_LEN;
                 memcpy(&ia->ia_na, iaoption->data, sizeof(ia->ia_na));
 
@@ -547,6 +561,14 @@
                 if (len < sizeof(ia->ia_pd))
                         return -ENOBUFS;
 
+                /* According to RFC8415, IAs which do not match the client's IAID should be ignored,
+                 * but not necessary to ignore or refuse the whole message. */
+                if (((const struct ia_pd*) iaoption->data)->id != iaid)
+                        /* ENOANO indicates the option should be ignored. */
+                        return log_dhcp6_client_errno(client, SYNTHETIC_ERRNO(ENOANO),
+                                                      "Received an IA_PD option with a different IAID "
+                                                      "from the one chosen by the client, ignoring.");
+
                 iaaddr_offset = sizeof(ia->ia_pd);
                 memcpy(&ia->ia_pd, iaoption->data, sizeof(ia->ia_pd));
 
@@ -564,13 +586,21 @@
                 if (len < DHCP6_OPTION_IA_TA_LEN)
                         return -ENOBUFS;
 
+                /* According to RFC8415, IAs which do not match the client's IAID should be ignored,
+                 * but not necessary to ignore or refuse the whole message. */
+                if (((const struct ia_ta*) iaoption->data)->id != iaid)
+                        /* ENOANO indicates the option should be ignored. */
+                        return log_dhcp6_client_errno(client, SYNTHETIC_ERRNO(ENOANO),
+                                                      "Received an IA_TA option with a different IAID "
+                                                      "from the one chosen by the client, ignoring.");
+
                 iaaddr_offset = DHCP6_OPTION_IA_TA_LEN;
-                memcpy(&ia->ia_ta.id, iaoption->data, sizeof(ia->ia_ta));
+                memcpy(&ia->ia_ta, iaoption->data, sizeof(ia->ia_ta));
 
                 break;
 
         default:
-                return -ENOMSG;
+                return -EINVAL;
         }
 
         ia->type = iatype;
diff -aruN old/src/libsystemd-network/icmp6-util.c new/src/libsystemd-network/icmp6-util.c
--- old/src/libsystemd-network/icmp6-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/icmp6-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -148,8 +148,9 @@
 int icmp6_receive(int fd, void *buffer, size_t size, struct in6_addr *ret_dst,
                   triple_timestamp *ret_timestamp) {
 
+        /* This needs to be initialized with zero. See #20741. */
         CMSG_BUFFER_TYPE(CMSG_SPACE(sizeof(int)) + /* ttl */
-                         CMSG_SPACE(sizeof(struct timeval))) control;
+                         CMSG_SPACE_TIMEVAL) control = {};
         struct iovec iov = {};
         union sockaddr_union sa = {};
         struct msghdr msg = {
@@ -186,7 +187,6 @@
 
         /* namelen == 0 only happens when running the test-suite over a socketpair */
 
-        assert(!(msg.msg_flags & MSG_CTRUNC));
         assert(!(msg.msg_flags & MSG_TRUNC));
 
         CMSG_FOREACH(cmsg, &msg) {
diff -aruN old/src/libsystemd-network/sd-dhcp6-client.c new/src/libsystemd-network/sd-dhcp6-client.c
--- old/src/libsystemd-network/sd-dhcp6-client.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/sd-dhcp6-client.c	2021-11-19 17:19:28.000000000 +0000
@@ -1119,7 +1119,6 @@
         while (pos < len) {
                 DHCP6Option *option = (DHCP6Option *) &message->options[pos];
                 uint16_t optcode, optlen;
-                be32_t iaid_lease;
                 int  status;
                 uint8_t *optval;
 
@@ -1198,8 +1197,8 @@
                                 break;
                         }
 
-                        r = dhcp6_option_parse_ia(client, option, &lease->ia, &ia_na_status);
-                        if (r < 0 && r != -ENOMSG)
+                        r = dhcp6_option_parse_ia(client, option, client->ia_pd.ia_na.id, &lease->ia, &ia_na_status);
+                        if (r < 0 && r != -ENOANO)
                                 return r;
 
                         if (ia_na_status == DHCP6_STATUS_NO_ADDRS_AVAIL) {
@@ -1207,19 +1206,9 @@
                                 continue;
                         }
 
-                        r = dhcp6_lease_get_iaid(lease, &iaid_lease);
-                        if (r < 0)
-                                return r;
-
-                        if (client->ia_na.ia_na.id != iaid_lease) {
-                                log_dhcp6_client(client, "%s has wrong IAID for IA NA",
-                                                 dhcp6_message_type_to_string(message->type));
-                                return -EINVAL;
-                        }
-
                         if (lease->ia.addresses) {
                                 lt_t1 = MIN(lt_t1, be32toh(lease->ia.ia_na.lifetime_t1));
-                                lt_t2 = MIN(lt_t2, be32toh(lease->ia.ia_na.lifetime_t1));
+                                lt_t2 = MIN(lt_t2, be32toh(lease->ia.ia_na.lifetime_t2));
                         }
 
                         break;
@@ -1231,8 +1220,8 @@
                                 break;
                         }
 
-                        r = dhcp6_option_parse_ia(client, option, &lease->pd, &ia_pd_status);
-                        if (r < 0 && r != -ENOMSG)
+                        r = dhcp6_option_parse_ia(client, option, client->ia_pd.ia_pd.id, &lease->pd, &ia_pd_status);
+                        if (r < 0 && r != -ENOANO)
                                 return r;
 
                         if (ia_pd_status == DHCP6_STATUS_NO_PREFIX_AVAIL) {
@@ -1240,16 +1229,6 @@
                                 continue;
                         }
 
-                        r = dhcp6_lease_get_pd_iaid(lease, &iaid_lease);
-                        if (r < 0)
-                                return r;
-
-                        if (client->ia_pd.ia_pd.id != iaid_lease) {
-                                log_dhcp6_client(client, "%s has wrong IAID for IA PD",
-                                                 dhcp6_message_type_to_string(message->type));
-                                return -EINVAL;
-                        }
-
                         if (lease->pd.addresses) {
                                 lt_t1 = MIN(lt_t1, be32toh(lease->pd.ia_pd.lifetime_t1));
                                 lt_t2 = MIN(lt_t2, be32toh(lease->pd.ia_pd.lifetime_t2));
@@ -1328,17 +1307,16 @@
                                          dhcp6_message_type_to_string(message->type));
                         return -EINVAL;
                 }
+        }
 
-        } else {
-                if (lease->ia.addresses) {
-                        lease->ia.ia_na.lifetime_t1 = htobe32(lt_t1);
-                        lease->ia.ia_na.lifetime_t2 = htobe32(lt_t2);
-                }
+        if (lease->ia.addresses) {
+                lease->ia.ia_na.lifetime_t1 = htobe32(lt_t1);
+                lease->ia.ia_na.lifetime_t2 = htobe32(lt_t2);
+        }
 
-                if (lease->pd.addresses) {
-                        lease->pd.ia_pd.lifetime_t1 = htobe32(lt_t1);
-                        lease->pd.ia_pd.lifetime_t2 = htobe32(lt_t2);
-                }
+        if (lease->pd.addresses) {
+                lease->pd.ia_pd.lifetime_t1 = htobe32(lt_t1);
+                lease->pd.ia_pd.lifetime_t2 = htobe32(lt_t2);
         }
 
         client->information_refresh_time_usec = MAX(irt, IRT_MINIMUM);
diff -aruN old/src/libsystemd-network/sd-dhcp-client.c new/src/libsystemd-network/sd-dhcp-client.c
--- old/src/libsystemd-network/sd-dhcp-client.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/sd-dhcp-client.c	2021-11-19 17:19:28.000000000 +0000
@@ -192,7 +192,7 @@
                 if (len != sizeof_field(sd_dhcp_client_id, eth))
                         return -EINVAL;
 
-                r = asprintf(&t, "%x:%x:%x:%x:%x:%x",
+                r = asprintf(&t, "%02x:%02x:%02x:%02x:%02x:%02x",
                              client_id->eth.haddr[0],
                              client_id->eth.haddr[1],
                              client_id->eth.haddr[2],
@@ -726,7 +726,7 @@
 static int client_initialize(sd_dhcp_client *client) {
         assert_return(client, -EINVAL);
 
-        client->receive_message = sd_event_source_unref(client->receive_message);
+        client->receive_message = sd_event_source_disable_unref(client->receive_message);
 
         client->fd = safe_close(client->fd);
 
@@ -1492,7 +1492,7 @@
 
         assert(client);
 
-        client->receive_message = sd_event_source_unref(client->receive_message);
+        client->receive_message = sd_event_source_disable_unref(client->receive_message);
         client->fd = safe_close(client->fd);
 
         client->state = DHCP_STATE_REBINDING;
@@ -1847,7 +1847,7 @@
 
                 client->start_delay = 0;
                 (void) event_source_disable(client->timeout_resend);
-                client->receive_message = sd_event_source_unref(client->receive_message);
+                client->receive_message = sd_event_source_disable_unref(client->receive_message);
                 client->fd = safe_close(client->fd);
 
                 client->state = DHCP_STATE_BOUND;
@@ -2229,17 +2229,15 @@
 
         log_dhcp_client(client, "FREE");
 
+        client_initialize(client);
+
         client->timeout_resend = sd_event_source_unref(client->timeout_resend);
         client->timeout_t1 = sd_event_source_unref(client->timeout_t1);
         client->timeout_t2 = sd_event_source_unref(client->timeout_t2);
         client->timeout_expire = sd_event_source_unref(client->timeout_expire);
 
-        client_initialize(client);
-
         sd_dhcp_client_detach_event(client);
 
-        sd_dhcp_lease_unref(client->lease);
-
         set_free(client->req_opts);
         free(client->hostname);
         free(client->vendor_class_identifier);
diff -aruN old/src/libsystemd-network/sd-dhcp-server.c new/src/libsystemd-network/sd-dhcp-server.c
--- old/src/libsystemd-network/sd-dhcp-server.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/sd-dhcp-server.c	2021-11-19 17:19:28.000000000 +0000
@@ -267,8 +267,8 @@
         if (!server)
                 return 0;
 
-        server->receive_message = sd_event_source_unref(server->receive_message);
-        server->receive_broadcast = sd_event_source_unref(server->receive_broadcast);
+        server->receive_message = sd_event_source_disable_unref(server->receive_message);
+        server->receive_broadcast = sd_event_source_disable_unref(server->receive_broadcast);
 
         server->fd_raw = safe_close(server->fd_raw);
         server->fd = safe_close(server->fd);
@@ -1107,7 +1107,7 @@
 
                 if (server->bound_leases[pool_offset] == existing_lease) {
                         server->bound_leases[pool_offset] = NULL;
-                        hashmap_remove(server->leases_by_client_id, existing_lease);
+                        hashmap_remove(server->leases_by_client_id, &existing_lease->client_id);
                         dhcp_lease_free(existing_lease);
 
                         if (server->callback)
diff -aruN old/src/libsystemd-network/sd-ipv4acd.c new/src/libsystemd-network/sd-ipv4acd.c
--- old/src/libsystemd-network/sd-ipv4acd.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/sd-ipv4acd.c	2021-11-19 17:19:28.000000000 +0000
@@ -120,7 +120,7 @@
         assert(acd);
 
         (void) event_source_disable(acd->timer_event_source);
-        acd->receive_message_event_source = sd_event_source_unref(acd->receive_message_event_source);
+        acd->receive_message_event_source = sd_event_source_disable_unref(acd->receive_message_event_source);
 
         acd->fd = safe_close(acd->fd);
 
@@ -130,9 +130,8 @@
 static sd_ipv4acd *ipv4acd_free(sd_ipv4acd *acd) {
         assert(acd);
 
-        acd->timer_event_source = sd_event_source_unref(acd->timer_event_source);
-
         ipv4acd_reset(acd);
+        sd_event_source_unref(acd->timer_event_source);
         sd_ipv4acd_detach_event(acd);
         free(acd->ifname);
         return mfree(acd);
diff -aruN old/src/libsystemd-network/sd-lldp.c new/src/libsystemd-network/sd-lldp.c
--- old/src/libsystemd-network/sd-lldp.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/sd-lldp.c	2021-11-19 17:19:28.000000000 +0000
@@ -239,7 +239,7 @@
         assert(lldp);
 
         (void) event_source_disable(lldp->timer_event_source);
-        lldp->io_event_source = sd_event_source_unref(lldp->io_event_source);
+        lldp->io_event_source = sd_event_source_disable_unref(lldp->io_event_source);
         lldp->fd = safe_close(lldp->fd);
 }
 
@@ -365,10 +365,11 @@
 static sd_lldp* lldp_free(sd_lldp *lldp) {
         assert(lldp);
 
-        lldp->timer_event_source = sd_event_source_unref(lldp->timer_event_source);
-
         lldp_reset(lldp);
+
+        sd_event_source_unref(lldp->timer_event_source);
         sd_lldp_detach_event(lldp);
+
         lldp_flush_neighbors(lldp);
 
         hashmap_free(lldp->neighbor_by_id);
diff -aruN old/src/libsystemd-network/sd-ndisc.c new/src/libsystemd-network/sd-ndisc.c
--- old/src/libsystemd-network/sd-ndisc.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/sd-ndisc.c	2021-11-19 17:19:28.000000000 +0000
@@ -133,18 +133,19 @@
         (void) event_source_disable(nd->timeout_event_source);
         (void) event_source_disable(nd->timeout_no_ra);
         nd->retransmit_time = 0;
-        nd->recv_event_source = sd_event_source_unref(nd->recv_event_source);
+        nd->recv_event_source = sd_event_source_disable_unref(nd->recv_event_source);
         nd->fd = safe_close(nd->fd);
 }
 
 static sd_ndisc *ndisc_free(sd_ndisc *nd) {
         assert(nd);
 
-        nd->timeout_event_source = sd_event_source_unref(nd->timeout_event_source);
-        nd->timeout_no_ra = sd_event_source_unref(nd->timeout_no_ra);
-
         ndisc_reset(nd);
+
+        sd_event_source_unref(nd->timeout_event_source);
+        sd_event_source_unref(nd->timeout_no_ra);
         sd_ndisc_detach_event(nd);
+
         free(nd->ifname);
         return mfree(nd);
 }
diff -aruN old/src/libsystemd-network/sd-radv.c new/src/libsystemd-network/sd-radv.c
--- old/src/libsystemd-network/sd-radv.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/sd-radv.c	2021-11-19 17:19:28.000000000 +0000
@@ -89,8 +89,7 @@
 
         (void) event_source_disable(ra->timeout_event_source);
 
-        ra->recv_event_source =
-                sd_event_source_unref(ra->recv_event_source);
+        ra->recv_event_source = sd_event_source_disable_unref(ra->recv_event_source);
 
         ra->ra_sent = 0;
 }
@@ -116,10 +115,9 @@
         free(ra->rdnss);
         free(ra->dnssl);
 
-        ra->timeout_event_source = sd_event_source_unref(ra->timeout_event_source);
-
         radv_reset(ra);
 
+        sd_event_source_unref(ra->timeout_event_source);
         sd_radv_detach_event(ra);
 
         ra->fd = safe_close(ra->fd);
diff -aruN old/src/libsystemd-network/test-dhcp6-client.c new/src/libsystemd-network/test-dhcp6-client.c
--- old/src/libsystemd-network/test-dhcp6-client.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/libsystemd-network/test-dhcp6-client.c	2021-11-19 17:19:28.000000000 +0000
@@ -287,25 +287,31 @@
         };
         DHCP6Option *option;
         DHCP6IA ia, pd;
+        be32_t iaid;
         int r = 0;
 
         log_debug("/* %s */", __func__);
 
+        memcpy(&iaid, option1 + 4, sizeof(iaid));
+
         zero(ia);
         option = (DHCP6Option *)option1;
         assert_se(sizeof(option1) == sizeof(DHCP6Option) + be16toh(option->len));
 
-        r = dhcp6_option_parse_ia(NULL, option, &ia, NULL);
+        r = dhcp6_option_parse_ia(NULL, option, 0, &ia, NULL);
+        assert_se(r == -ENOANO);
+
+        r = dhcp6_option_parse_ia(NULL, option, iaid, &ia, NULL);
         assert_se(r == 0);
         assert_se(ia.addresses == NULL);
 
         option->len = htobe16(17);
-        r = dhcp6_option_parse_ia(NULL, option, &ia, NULL);
+        r = dhcp6_option_parse_ia(NULL, option, iaid, &ia, NULL);
         assert_se(r == -ENOBUFS);
         assert_se(ia.addresses == NULL);
 
         option->len = htobe16(sizeof(DHCP6Option));
-        r = dhcp6_option_parse_ia(NULL, option, &ia, NULL);
+        r = dhcp6_option_parse_ia(NULL, option, iaid, &ia, NULL);
         assert_se(r == -ENOBUFS);
         assert_se(ia.addresses == NULL);
 
@@ -313,7 +319,7 @@
         option = (DHCP6Option *)option2;
         assert_se(sizeof(option2) == sizeof(DHCP6Option) + be16toh(option->len));
 
-        r = dhcp6_option_parse_ia(NULL, option, &ia, NULL);
+        r = dhcp6_option_parse_ia(NULL, option, iaid, &ia, NULL);
         assert_se(r >= 0);
         assert_se(ia.addresses == NULL);
 
@@ -321,7 +327,7 @@
         option = (DHCP6Option *)option3;
         assert_se(sizeof(option3) == sizeof(DHCP6Option) + be16toh(option->len));
 
-        r = dhcp6_option_parse_ia(NULL, option, &ia, NULL);
+        r = dhcp6_option_parse_ia(NULL, option, iaid, &ia, NULL);
         assert_se(r >= 0);
         assert_se(ia.addresses != NULL);
         dhcp6_lease_free_ia(&ia);
@@ -330,7 +336,7 @@
         option = (DHCP6Option *)option4;
         assert_se(sizeof(option4) == sizeof(DHCP6Option) + be16toh(option->len));
 
-        r = dhcp6_option_parse_ia(NULL, option, &pd, NULL);
+        r = dhcp6_option_parse_ia(NULL, option, iaid, &pd, NULL);
         assert_se(r >= 0);
         assert_se(pd.addresses != NULL);
         assert_se(memcmp(&pd.ia_pd.id, &option4[4], 4) == 0);
@@ -342,7 +348,7 @@
         option = (DHCP6Option *)option5;
         assert_se(sizeof(option5) == sizeof(DHCP6Option) + be16toh(option->len));
 
-        r = dhcp6_option_parse_ia(NULL, option, &pd, NULL);
+        r = dhcp6_option_parse_ia(NULL, option, iaid, &pd, NULL);
         assert_se(r >= 0);
         assert_se(pd.addresses != NULL);
         dhcp6_lease_free_ia(&pd);
@@ -447,13 +453,14 @@
                         opt_clientid = true;
                         break;
 
-                case SD_DHCP6_OPTION_IA_NA:
+                case SD_DHCP6_OPTION_IA_NA: {
+                        be32_t iaid = htobe32(0x0ecfa37d);
+
                         assert_se(optlen == 94);
                         assert_se(optval == &msg_advertise[26]);
                         assert_se(!memcmp(optval, &msg_advertise[26], optlen));
 
-                        val = htobe32(0x0ecfa37d);
-                        assert_se(!memcmp(optval, &val, sizeof(val)));
+                        assert_se(!memcmp(optval, &iaid, sizeof(val)));
 
                         val = htobe32(80);
                         assert_se(!memcmp(optval + 4, &val, sizeof(val)));
@@ -461,10 +468,10 @@
                         val = htobe32(120);
                         assert_se(!memcmp(optval + 8, &val, sizeof(val)));
 
-                        assert_se(dhcp6_option_parse_ia(NULL, option, &lease->ia, NULL) >= 0);
+                        assert_se(dhcp6_option_parse_ia(NULL, option, iaid, &lease->ia, NULL) >= 0);
 
                         break;
-
+                }
                 case SD_DHCP6_OPTION_SERVERID:
                         assert_se(optlen == 14);
                         assert_se(optval == &msg_advertise[179]);
@@ -598,6 +605,8 @@
 static int test_client_send_reply(DHCP6Message *request) {
         DHCP6Message reply;
 
+        log_debug("/* %s */", __func__);
+
         reply.transaction_id = request->transaction_id;
         reply.type = DHCP6_REPLY;
 
@@ -658,7 +667,7 @@
                         assert_se(!memcmp(optval + 8, &val, sizeof(val)));
 
                         /* Then, this should refuse all addresses. */
-                        assert_se(dhcp6_option_parse_ia(NULL, option, &lease->ia, NULL) >= 0);
+                        assert_se(dhcp6_option_parse_ia(NULL, option, test_iaid, &lease->ia, NULL) >= 0);
 
                         break;
 
@@ -704,6 +713,8 @@
 static int test_client_send_advertise(DHCP6Message *solicit) {
         DHCP6Message advertise;
 
+        log_debug("/* %s */", __func__);
+
         advertise.transaction_id = solicit->transaction_id;
         advertise.type = DHCP6_ADVERTISE;
 
@@ -899,6 +910,8 @@
                 IN6ADDR_ALL_DHCP6_RELAY_AGENTS_AND_SERVERS_INIT;
         DHCP6Message *message;
 
+        log_debug("/* %s */", __func__);
+
         assert_se(s == test_dhcp_fd[0]);
         assert_se(server_address);
         assert_se(packet);
diff -aruN old/src/locale/localed.c new/src/locale/localed.c
--- old/src/locale/localed.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/locale/localed.c	2021-11-19 17:19:28.000000000 +0000
@@ -560,7 +560,7 @@
 
         fmt = strjoina("libxkbcommon: ", format);
         DISABLE_WARNING_FORMAT_NONLITERAL;
-        log_internalv(LOG_DEBUG, 0, __FILE__, __LINE__, __func__, fmt, args);
+        log_internalv(LOG_DEBUG, 0, PROJECT_FILE, __LINE__, __func__, fmt, args);
         REENABLE_WARNING;
 }
 
diff -aruN old/src/locale/test-keymap-util.c new/src/locale/test-keymap-util.c
--- old/src/locale/test-keymap-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/locale/test-keymap-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -190,12 +190,17 @@
 }
 
 int main(int argc, char **argv) {
+        _cleanup_free_ char *map = NULL;
+
         test_setup_logging(LOG_DEBUG);
 
         test_find_language_fallback();
         test_find_converted_keymap();
-        test_find_legacy_keymap();
 
+        assert_se(get_testdata_dir("test-keymap-util/kbd-model-map", &map) >= 0);
+        assert_se(setenv("SYSTEMD_KBD_MODEL_MAP", map, 1) == 0);
+
+        test_find_legacy_keymap();
         test_vconsole_convert_to_x11();
         test_x11_convert_to_vconsole();
 
diff -aruN old/src/login/70-uaccess.rules.in new/src/login/70-uaccess.rules.in
--- old/src/login/70-uaccess.rules.in	2021-07-07 18:41:29.000000000 +0100
+++ new/src/login/70-uaccess.rules.in	2021-11-19 17:19:28.000000000 +0000
@@ -33,6 +33,7 @@
 # Webcams, frame grabber, TV cards
 SUBSYSTEM=="video4linux", TAG+="uaccess"
 SUBSYSTEM=="dvb", TAG+="uaccess"
+SUBSYSTEM=="media", TAG+="uaccess"
 
 # industrial cameras, some webcams, camcorders, set-top boxes, TV sets, audio devices, and more
 SUBSYSTEM=="firewire", TEST=="units", ENV{IEEE1394_UNIT_FUNCTION_MIDI}=="1", TAG+="uaccess"
diff -aruN old/src/login/logind-core.c new/src/login/logind-core.c
--- old/src/login/logind-core.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/login/logind-core.c	2021-11-19 17:19:28.000000000 +0000
@@ -707,7 +707,9 @@
                 errno = 0;
                 u = getutxent();
                 if (!u) {
-                        if (errno != 0)
+                        if (errno == ENOENT)
+                                log_debug_errno(errno, _PATH_UTMPX " does not exist, ignoring.");
+                        else if (errno != 0)
                                 log_warning_errno(errno, "Failed to read " _PATH_UTMPX ", ignoring: %m");
                         return 0;
                 }
diff -aruN old/src/login/meson.build new/src/login/meson.build
--- old/src/login/meson.build	2021-07-07 18:41:29.000000000 +0100
+++ new/src/login/meson.build	2021-11-19 17:19:28.000000000 +0000
@@ -67,22 +67,24 @@
 
 enable_logind = conf.get('ENABLE_LOGIND') == 1
 in_files = [
-        ['logind.conf',        pkgsysconfdir, enable_logind],
+        ['logind.conf',        pkgsysconfdir, enable_logind and install_sysconfdir_samples],
         ['70-uaccess.rules',   udevrulesdir,  enable_logind and conf.get('HAVE_ACL') == 1],
         ['71-seat.rules',      udevrulesdir,  enable_logind],
         ['73-seat-late.rules', udevrulesdir,  enable_logind],
-        ['systemd-user',       pamconfdir,    enable_logind and pamconfdir != 'no']]
+        ['systemd-user',       pamconfdir,    enable_logind]]
 
 foreach tuple : in_files
         file = tuple[0]
+        dir = tuple[1]
+        install = (dir == pkgsysconfdir) ? install_sysconfdir_samples : (dir != 'no')
         custom_target(
                 file,
                 input : file + '.in',
                 output: file,
                 command : [meson_render_jinja2, config_h, '@INPUT@'],
                 capture : true,
-                install : tuple[2],
-                install_dir : tuple[1])
+                install : tuple[2] and install,
+                install_dir : dir)
 endforeach
 
 if enable_logind
diff -aruN old/src/machine/machined-varlink.c new/src/machine/machined-varlink.c
--- old/src/machine/machined-varlink.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/machine/machined-varlink.c	2021-11-19 17:19:28.000000000 +0000
@@ -297,7 +297,7 @@
                 desc = mfree(desc);
 
         *ret_gid = converted_gid;
-        *ret_description = desc;
+        *ret_description = TAKE_PTR(desc);
         return 0;
 }
 
diff -aruN old/src/mount/mount-tool.c new/src/mount/mount-tool.c
--- old/src/mount/mount-tool.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/mount/mount-tool.c	2021-11-19 17:19:28.000000000 +0000
@@ -332,6 +332,9 @@
                         assert_not_reached("Unhandled option");
                 }
 
+        if (arg_user)
+                arg_ask_password = false;
+
         if (arg_user && arg_transport != BUS_TRANSPORT_LOCAL)
                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                        "Execution in user context is not supported on non-local systems.");
diff -aruN old/src/network/netdev/macvlan.c new/src/network/netdev/macvlan.c
--- old/src/network/netdev/macvlan.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/netdev/macvlan.c	2021-11-19 17:19:28.000000000 +0000
@@ -5,6 +5,7 @@
 #include "conf-parser.h"
 #include "macvlan.h"
 #include "macvlan-util.h"
+#include "networkd-network.h"
 #include "parse-util.h"
 
 DEFINE_CONFIG_PARSE_ENUM(config_parse_macvlan_mode, macvlan_mode, MacVlanMode, "Failed to parse macvlan mode");
@@ -16,6 +17,7 @@
         assert(netdev);
         assert(link);
         assert(netdev->ifname);
+        assert(link->network);
 
         if (netdev->kind == NETDEV_KIND_MACVLAN)
                 m = MACVLAN(netdev);
@@ -52,6 +54,13 @@
                         return log_netdev_error_errno(netdev, r, "Could not append IFLA_MACVLAN_MODE attribute: %m");
         }
 
+        /* set the nopromisc flag if Promiscuous= of the link is explicitly set to false */
+        if (m->mode == NETDEV_MACVLAN_MODE_PASSTHRU && link->network->promiscuous == 0) {
+                r = sd_netlink_message_append_u16(req, IFLA_MACVLAN_FLAGS, MACVLAN_FLAG_NOPROMISC);
+                if (r < 0)
+                        return log_netdev_error_errno(netdev, r, "Could not append IFLA_MACVLAN_FLAGS attribute: %m");
+        }
+
         if (m->bc_queue_length != UINT32_MAX) {
                 r = sd_netlink_message_append_u32(req, IFLA_MACVLAN_BC_QUEUE_LEN, m->bc_queue_length);
                 if (r < 0)
diff -aruN old/src/network/networkd-address.c new/src/network/networkd-address.c
--- old/src/network/networkd-address.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-address.c	2021-11-19 17:19:28.000000000 +0000
@@ -165,7 +165,7 @@
                 set_remove(address->link->dhcp6_pd_addresses, address);
                 set_remove(address->link->dhcp6_pd_addresses_old, address);
                 SET_FOREACH(n, address->link->ndisc_addresses)
-                        if (n->address == address)
+                        if (address_equal(n->address, address))
                                 free(set_remove(address->link->ndisc_addresses, n));
 
                 if (address->family == AF_INET6 &&
@@ -1272,17 +1272,17 @@
         if (r <= 0)
                 return r;
 
-        r = address_get(link, req->address, &a);
-        if (r < 0)
-                return r;
-
-        r = address_configure(a, link, req->netlink_handler);
+        r = address_configure(req->address, link, req->netlink_handler);
         if (r < 0)
                 return r;
 
         /* To prevent a double decrement on failure in after_configure(). */
         req->message_counter = NULL;
 
+        r = address_get(link, req->address, &a);
+        if (r < 0)
+                return r;
+
         if (req->after_configure) {
                 r = req->after_configure(req, a);
                 if (r < 0)
diff -aruN old/src/network/networkd-link.c new/src/network/networkd-link.c
--- old/src/network/networkd-link.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-link.c	2021-11-19 17:19:28.000000000 +0000
@@ -1,9 +1,11 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
+#include <net/if.h>
 #include <netinet/in.h>
 #include <linux/if.h>
 #include <linux/if_arp.h>
 #include <linux/if_link.h>
+#include <linux/netdevice.h>
 #include <sys/socket.h>
 #include <unistd.h>
 
@@ -20,6 +22,7 @@
 #include "ethtool-util.h"
 #include "fd-util.h"
 #include "fileio.h"
+#include "format-util.h"
 #include "fs-util.h"
 #include "ipvlan.h"
 #include "missing_network.h"
@@ -1401,17 +1404,21 @@
         assert(link);
         assert(device);
 
-        if (link->state != LINK_STATE_PENDING)
-                return 0;
+        /* Always replace with the new sd_device object. As the sysname (and possibly other properties
+         * or sysattrs) may be outdated. */
+        sd_device_ref(device);
+        sd_device_unref(link->sd_device);
+        link->sd_device = device;
 
-        if (link->sd_device)
+        /* Do not ignore unamanaged state case here. If an interface is renamed after being once
+         * configured, and the corresponding .network file has Name= in [Match] section, then the
+         * interface may be already in unmanaged state. See #20657. */
+        if (!IN_SET(link->state, LINK_STATE_PENDING, LINK_STATE_UNMANAGED))
                 return 0;
 
         log_link_debug(link, "udev initialized link");
         link_set_state(link, LINK_STATE_INITIALIZED);
 
-        link->sd_device = sd_device_ref(device);
-
         /* udev has initialized the link, but we don't know if we have yet
          * processed the NEWLINK messages with the latest state. Do a GETLINK,
          * when it returns we know that the pending NEWLINKs have already been
@@ -2160,6 +2167,7 @@
 }
 
 static int link_update_name(Link *link, sd_netlink_message *message) {
+        char ifname_from_index[IF_NAMESIZE + 1];
         const char *ifname;
         int r;
 
@@ -2176,6 +2184,16 @@
         if (streq(ifname, link->ifname))
                 return 0;
 
+        if (!format_ifname(link->ifindex, ifname_from_index))
+                return log_link_debug_errno(link, SYNTHETIC_ERRNO(ENXIO), "Could not get interface name for index %i.", link->ifindex);
+
+        if (!streq(ifname, ifname_from_index)) {
+                log_link_debug(link, "New interface name '%s' received from the kernel does not correspond "
+                               "with the name currently configured on the actual interface '%s'. Ignoring.",
+                               ifname, ifname_from_index);
+                return 0;
+        }
+
         log_link_info(link, "Interface name change detected, renamed to %s.", ifname);
 
         hashmap_remove(link->manager->links_by_name, link->ifname);
diff -aruN old/src/network/networkd-lldp-tx.c new/src/network/networkd-lldp-tx.c
--- old/src/network/networkd-lldp-tx.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-lldp-tx.c	2021-11-19 17:19:28.000000000 +0000
@@ -413,7 +413,7 @@
 void link_lldp_emit_stop(Link *link) {
         assert(link);
 
-        link->lldp_emit_event_source = sd_event_source_unref(link->lldp_emit_event_source);
+        link->lldp_emit_event_source = sd_event_source_disable_unref(link->lldp_emit_event_source);
 }
 
 int config_parse_lldp_mud(
diff -aruN old/src/network/networkd-ndisc.c new/src/network/networkd-ndisc.c
--- old/src/network/networkd-ndisc.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-ndisc.c	2021-11-19 17:19:28.000000000 +0000
@@ -765,7 +765,9 @@
         assert(link);
         assert(rt);
 
-        r = sd_ndisc_router_get_timestamp(rt, clock_boottime_or_monotonic(), &time_now);
+        /* Do not use clock_boottime_or_monotonic() here, as the kernel internally manages cstamp and
+         * tstamp with jiffies, and it is not increased while the system is suspended. */
+        r = sd_ndisc_router_get_timestamp(rt, CLOCK_MONOTONIC, &time_now);
         if (r < 0)
                 return log_link_error_errno(link, r, "Failed to get RA timestamp: %m");
 
diff -aruN old/src/network/networkd-nexthop.c new/src/network/networkd-nexthop.c
--- old/src/network/networkd-nexthop.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-nexthop.c	2021-11-19 17:19:28.000000000 +0000
@@ -791,12 +791,7 @@
                 }
         }
 
-        if (nexthop->onlink <= 0 &&
-            in_addr_is_set(nexthop->family, &nexthop->gw) &&
-            !manager_address_is_reachable(link->manager, nexthop->family, &nexthop->gw))
-                return false;
-
-        return true;
+        return gateway_is_ready(link, nexthop->onlink, nexthop->family, &nexthop->gw);
 }
 
 int request_process_nexthop(Request *req) {
diff -aruN old/src/network/networkd-route.c new/src/network/networkd-route.c
--- old/src/network/networkd-route.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-route.c	2021-11-19 17:19:28.000000000 +0000
@@ -279,7 +279,7 @@
                 set_remove(route->link->dhcp6_pd_routes, route);
                 set_remove(route->link->dhcp6_pd_routes_old, route);
                 SET_FOREACH(n, route->link->ndisc_routes)
-                        if (n->route == route)
+                        if (route_equal(n->route, route))
                                 free(set_remove(route->link->ndisc_routes, n));
         }
 
@@ -290,7 +290,7 @@
 
         ordered_set_free_with_destructor(route->multipath_routes, multipath_route_free);
 
-        sd_event_source_unref(route->expire);
+        sd_event_source_disable_unref(route->expire);
 
         return mfree(route);
 }
@@ -435,7 +435,7 @@
                 route_compare_func,
                 route_free);
 
-static bool route_equal(const Route *r1, const Route *r2) {
+bool route_equal(const Route *r1, const Route *r2) {
         if (r1 == r2)
                 return true;
 
@@ -746,21 +746,54 @@
                         FAMILY_ADDRESS_SIZE(family) * 8) > 0;
 }
 
-bool manager_address_is_reachable(Manager *manager, int family, const union in_addr_union *address) {
-        Link *link;
+static bool prefix_route_address_is_reachable(const Address *a, int family, const union in_addr_union *address) {
+        assert(a);
+        assert(IN_SET(family, AF_INET, AF_INET6));
+        assert(address);
 
-        assert(manager);
+        if (a->family != family)
+                return false;
+        if (!address_is_ready(a))
+                return false;
+        if (FLAGS_SET(a->flags, IFA_F_NOPREFIXROUTE))
+                return false;
+        if (in_addr_is_set(a->family, &a->in_addr_peer))
+                return false;
+
+        return in_addr_prefix_intersect(
+                        family,
+                        &a->in_addr,
+                        a->prefixlen,
+                        address,
+                        FAMILY_ADDRESS_SIZE(family) * 8) > 0;
+}
+
+static bool link_address_is_reachable(Link *link, int family, const union in_addr_union *address) {
+        Route *route;
+
+        assert(link);
+        assert(link->manager);
         assert(IN_SET(family, AF_INET, AF_INET6));
         assert(address);
 
-        HASHMAP_FOREACH(link, manager->links_by_index) {
-                Route *route;
 
-                SET_FOREACH(route, link->routes)
-                        if (route_address_is_reachable(route, family, address))
+        SET_FOREACH(route, link->routes)
+                if (route_address_is_reachable(route, family, address))
+                        return true;
+        SET_FOREACH(route, link->routes_foreign)
+                if (route_address_is_reachable(route, family, address))
+                        return true;
+
+        /* If we do not manage foreign routes, then there may exist a prefix route we do not know,
+         * which was created on configuring an address. Hence, also check the addresses. */
+        if (!link->manager->manage_foreign_routes) {
+                Address *a;
+
+                SET_FOREACH(a, link->addresses)
+                        if (prefix_route_address_is_reachable(a, family, address))
                                 return true;
-                SET_FOREACH(route, link->routes_foreign)
-                        if (route_address_is_reachable(route, family, address))
+                SET_FOREACH(a, link->addresses_foreign)
+                        if (prefix_route_address_is_reachable(a, family, address))
                                 return true;
         }
 
@@ -1240,7 +1273,7 @@
 }
 
 static int route_add_and_setup_timer_one(Link *link, const Route *route, const MultipathRoute *m, const NextHop *nh, uint8_t nh_weight, Route **ret) {
-        _cleanup_(sd_event_source_unrefp) sd_event_source *expire = NULL;
+        _cleanup_(sd_event_source_disable_unrefp) sd_event_source *expire = NULL;
         Route *nr;
         int r;
 
@@ -1278,7 +1311,7 @@
                         return log_link_error_errno(link, r, "Could not arm expiration timer: %m");
         }
 
-        sd_event_source_unref(nr->expire);
+        sd_event_source_disable_unref(nr->expire);
         nr->expire = TAKE_PTR(expire);
 
         *ret = nr;
@@ -1504,7 +1537,7 @@
 
         if (route->lifetime != USEC_INFINITY && kernel_route_expiration_supported()) {
                 r = sd_netlink_message_append_u32(req, RTA_EXPIRES,
-                        DIV_ROUND_UP(usec_sub_unsigned(route->lifetime, now(clock_boottime_or_monotonic())), USEC_PER_SEC));
+                        MIN(DIV_ROUND_UP(usec_sub_unsigned(route->lifetime, now(clock_boottime_or_monotonic())), USEC_PER_SEC), UINT32_MAX));
                 if (r < 0)
                         return log_link_error_errno(link, r, "Could not append RTA_EXPIRES attribute: %m");
         }
@@ -1658,6 +1691,22 @@
         return 0;
 }
 
+bool gateway_is_ready(Link *link, int onlink, int family, const union in_addr_union *gw) {
+        assert(link);
+        assert(gw);
+
+        if (onlink > 0)
+                return true;
+
+        if (!in_addr_is_set(family, gw))
+                return true;
+
+        if (family == AF_INET6 && in6_addr_is_link_local(&gw->in6))
+                return true;
+
+        return link_address_is_reachable(link, family, gw);
+}
+
 static int route_is_ready_to_configure(const Route *route, Link *link) {
         MultipathRoute *m;
         NextHop *nh = NULL;
@@ -1701,19 +1750,13 @@
                         return r;
         }
 
-        if (route->gateway_onlink <= 0 &&
-            in_addr_is_set(route->gw_family, &route->gw) > 0 &&
-            !manager_address_is_reachable(link->manager, route->gw_family, &route->gw))
+        if (!gateway_is_ready(link, route->gateway_onlink, route->gw_family, &route->gw))
                 return false;
 
         ORDERED_SET_FOREACH(m, route->multipath_routes) {
                 union in_addr_union a = m->gateway.address;
                 Link *l = NULL;
 
-                if (route->gateway_onlink <= 0 &&
-                    !manager_address_is_reachable(link->manager, m->gateway.family, &a))
-                        return false;
-
                 if (m->ifname) {
                         if (link_get_by_name(link->manager, m->ifname, &l) < 0)
                                 return false;
@@ -1725,6 +1768,9 @@
                 }
                 if (l && !link_is_ready_to_configure(l, true))
                         return false;
+
+                if (!gateway_is_ready(l ?: link, route->gateway_onlink, m->gateway.family, &a))
+                        return false;
         }
 
         return true;
diff -aruN old/src/network/networkd-route.h new/src/network/networkd-route.h
--- old/src/network/networkd-route.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-route.h	2021-11-19 17:19:28.000000000 +0000
@@ -66,6 +66,7 @@
 
 void route_hash_func(const Route *route, struct siphash *state);
 int route_compare_func(const Route *a, const Route *b);
+bool route_equal(const Route *r1, const Route *r2);
 extern const struct hash_ops route_hash_ops;
 
 int route_new(Route **ret);
@@ -77,8 +78,8 @@
 int route_remove(const Route *route, Manager *manager, Link *link);
 
 int link_has_route(Link *link, const Route *route);
-bool manager_address_is_reachable(Manager *manager, int family, const union in_addr_union *address);
 int manager_find_uplink(Manager *m, int family, Link *exclude, Link **ret);
+bool gateway_is_ready(Link *link, int onlink, int family, const union in_addr_union *gw);
 
 int link_drop_routes(Link *link);
 int link_drop_foreign_routes(Link *link);
diff -aruN old/src/network/networkd-routing-policy-rule.c new/src/network/networkd-routing-policy-rule.c
--- old/src/network/networkd-routing-policy-rule.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-routing-policy-rule.c	2021-11-19 17:19:28.000000000 +0000
@@ -163,7 +163,9 @@
                 siphash24_compress(&rule->type, sizeof(rule->type), state);
                 siphash24_compress(&rule->fwmark, sizeof(rule->fwmark), state);
                 siphash24_compress(&rule->fwmask, sizeof(rule->fwmask), state);
-                siphash24_compress(&rule->priority, sizeof(rule->priority), state);
+                siphash24_compress_boolean(rule->priority_set, state);
+                if (rule->priority_set)
+                        siphash24_compress(&rule->priority, sizeof(rule->priority), state);
                 siphash24_compress(&rule->table, sizeof(rule->table), state);
                 siphash24_compress(&rule->suppress_prefixlen, sizeof(rule->suppress_prefixlen), state);
 
@@ -229,10 +231,16 @@
                 if (r != 0)
                         return r;
 
-                r = CMP(a->priority, b->priority);
+                r = CMP(a->priority_set, b->priority_set);
                 if (r != 0)
                         return r;
 
+                if (a->priority_set) {
+                        r = CMP(a->priority, b->priority);
+                        if (r != 0)
+                                return r;
+                }
+
                 r = CMP(a->table, b->table);
                 if (r != 0)
                         return r;
@@ -293,8 +301,9 @@
                 routing_policy_rule_compare_func,
                 routing_policy_rule_free);
 
-static int routing_policy_rule_get(Manager *m, const RoutingPolicyRule *rule, RoutingPolicyRule **ret) {
+static int routing_policy_rule_get(Manager *m, const RoutingPolicyRule *rule, bool require_priority, RoutingPolicyRule **ret) {
         RoutingPolicyRule *existing;
+        int r;
 
         assert(m);
 
@@ -312,6 +321,23 @@
                 return 0;
         }
 
+        if (!require_priority && rule->priority_set) {
+                _cleanup_(routing_policy_rule_freep) RoutingPolicyRule *tmp = NULL;
+
+                r = routing_policy_rule_dup(rule, &tmp);
+                if (r < 0)
+                        return r;
+
+                tmp->priority_set = false;
+
+                existing = set_get(m->rules, tmp);
+                if (existing) {
+                        if (ret)
+                                *ret = existing;
+                        return 1;
+                }
+        }
+
         return -ENOENT;
 }
 
@@ -328,7 +354,7 @@
         if (r < 0)
                 return r;
 
-        r = routing_policy_rule_get(m, rule, &existing);
+        r = routing_policy_rule_get(m, rule, true, &existing);
         if (r == -ENOENT) {
                 /* Rule does not exist, use a new one. */
                 r = set_ensure_put(&m->rules, &routing_policy_rule_hash_ops, rule);
@@ -371,6 +397,32 @@
         return 1;
 }
 
+static int routing_policy_rule_update_priority(RoutingPolicyRule *rule, uint32_t priority) {
+        int r;
+
+        assert(rule);
+        assert(rule->manager);
+
+        if (rule->priority_set)
+                return 0;
+
+        if (!set_remove(rule->manager->rules, rule))
+                return -ENOENT;
+
+        rule->priority = priority;
+        rule->priority_set = true;
+
+        r = set_put(rule->manager->rules, rule);
+        if (r <= 0) {
+                /* Undo */
+                rule->priority_set = false;
+                assert_se(set_put(rule->manager->rules, rule) > 0);
+                return r == 0 ? -EEXIST : r;
+        }
+
+        return 1;
+}
+
 static void log_routing_policy_rule_debug(const RoutingPolicyRule *rule, const char *str, const Link *link, const Manager *m) {
         _cleanup_free_ char *from = NULL, *to = NULL, *table = NULL;
 
@@ -422,9 +474,11 @@
                         return log_link_error_errno(link, r, "Could not set destination prefix length: %m");
         }
 
-        r = sd_netlink_message_append_u32(m, FRA_PRIORITY, rule->priority);
-        if (r < 0)
-                return log_link_error_errno(link, r, "Could not append FRA_PRIORITY attribute: %m");
+        if (rule->priority_set) {
+                r = sd_netlink_message_append_u32(m, FRA_PRIORITY, rule->priority);
+                if (r < 0)
+                        return log_link_error_errno(link, r, "Could not append FRA_PRIORITY attribute: %m");
+        }
 
         if (rule->tos > 0) {
                 r = sd_rtnl_message_routing_policy_rule_set_tos(m, rule->tos);
@@ -662,6 +716,28 @@
                         continue;
                 }
 
+                if (!foreign) {
+                        _cleanup_(routing_policy_rule_freep) RoutingPolicyRule *tmp = NULL;
+
+                        /* The rule may be configured without priority. Try to find without priority. */
+
+                        k = routing_policy_rule_dup(rule, &tmp);
+                        if (k < 0) {
+                                if (r >= 0)
+                                        r = k;
+                                continue;
+                        }
+
+                        tmp->priority_set = false;
+
+                        k = links_have_routing_policy_rule(m, tmp, except);
+                        if (k != 0) {
+                                if (k < 0 && r >= 0)
+                                        r = k;
+                                continue;
+                        }
+                }
+
                 k = routing_policy_rule_remove(rule, m);
                 if (k < 0 && r >= 0)
                         r = k;
@@ -821,11 +897,11 @@
 }
 
 static const RoutingPolicyRule kernel_rules[] = {
-        { .family = AF_INET,  .priority = 0,     .table = RT_TABLE_LOCAL,   .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
-        { .family = AF_INET,  .priority = 32766, .table = RT_TABLE_MAIN,    .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
-        { .family = AF_INET,  .priority = 32767, .table = RT_TABLE_DEFAULT, .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
-        { .family = AF_INET6, .priority = 0,     .table = RT_TABLE_LOCAL,   .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
-        { .family = AF_INET6, .priority = 32766, .table = RT_TABLE_MAIN,    .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
+        { .family = AF_INET,  .priority_set = true, .priority = 0,     .table = RT_TABLE_LOCAL,   .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
+        { .family = AF_INET,  .priority_set = true, .priority = 32766, .table = RT_TABLE_MAIN,    .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
+        { .family = AF_INET,  .priority_set = true, .priority = 32767, .table = RT_TABLE_DEFAULT, .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
+        { .family = AF_INET6, .priority_set = true, .priority = 0,     .table = RT_TABLE_LOCAL,   .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
+        { .family = AF_INET6, .priority_set = true, .priority = 32766, .table = RT_TABLE_MAIN,    .type = FR_ACT_TO_TBL, .uid_range.start = UID_INVALID, .uid_range.end = UID_INVALID, .suppress_prefixlen = -1, },
 };
 
 static bool routing_policy_rule_is_created_by_kernel(const RoutingPolicyRule *rule) {
@@ -936,6 +1012,9 @@
                 log_warning_errno(r, "rtnl: could not get FRA_PRIORITY attribute, ignoring: %m");
                 return 0;
         }
+        /* The kernel does not send priority if priority is zero. So, the flag below must be always set
+         * even if the message does not contain FRA_PRIORITY. */
+        tmp->priority_set = true;
 
         r = sd_netlink_message_read_u32(message, FRA_TABLE, &tmp->table);
         if (r < 0 && r != -ENODATA) {
@@ -1027,13 +1106,16 @@
                  * protocol of the received rule is RTPROT_KERNEL or RTPROT_STATIC. */
                 tmp->protocol = routing_policy_rule_is_created_by_kernel(tmp) ? RTPROT_KERNEL : RTPROT_STATIC;
 
-        (void) routing_policy_rule_get(m, tmp, &rule);
+        (void) routing_policy_rule_get(m, tmp, false, &rule);
 
         switch (type) {
         case RTM_NEWRULE:
-                if (rule)
+                if (rule) {
                         log_routing_policy_rule_debug(tmp, "Received remembered", NULL, m);
-                else if (!m->manage_foreign_routes)
+                        r = routing_policy_rule_update_priority(rule, tmp->priority);
+                        if (r < 0)
+                                log_warning_errno(r, "Failed to update priority of remembered routing policy rule, ignoring: %m");
+                } else if (!m->manage_foreign_rules)
                         log_routing_policy_rule_debug(tmp, "Ignoring received foreign", NULL, m);
                 else {
                         log_routing_policy_rule_debug(tmp, "Remembering foreign", NULL, m);
@@ -1155,11 +1237,19 @@
         if (r < 0)
                 return log_oom();
 
+        if (isempty(rvalue)) {
+                n->priority = 0;
+                n->priority_set = false;
+                TAKE_PTR(n);
+                return 0;
+        }
+
         r = safe_atou32(rvalue, &n->priority);
         if (r < 0) {
                 log_syntax(unit, LOG_WARNING, filename, line, r, "Failed to parse RPDB rule priority, ignoring: %s", rvalue);
                 return 0;
         }
+        n->priority_set = true;
 
         TAKE_PTR(n);
         return 0;
diff -aruN old/src/network/networkd-routing-policy-rule.h new/src/network/networkd-routing-policy-rule.h
--- old/src/network/networkd-routing-policy-rule.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-routing-policy-rule.h	2021-11-19 17:19:28.000000000 +0000
@@ -20,6 +20,7 @@
         NetworkConfigSection *section;
 
         bool invert_rule;
+        bool priority_set;
 
         uint8_t tos;
         uint8_t type;
diff -aruN old/src/network/networkd-setlink.c new/src/network/networkd-setlink.c
--- old/src/network/networkd-setlink.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/network/networkd-setlink.c	2021-11-19 17:19:28.000000000 +0000
@@ -95,9 +95,16 @@
         return 1;
 
 on_error:
-        if (op == SET_LINK_FLAGS) {
+        switch (op) {
+        case SET_LINK_FLAGS:
                 assert(link->set_flags_messages > 0);
                 link->set_flags_messages--;
+                break;
+        case SET_LINK_MASTER:
+                link->master_set = true;
+                break;
+        default:
+                break;
         }
 
         return 0;
@@ -106,7 +113,7 @@
 static int link_set_addrgen_mode_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
         int r;
 
-        r = set_link_handler_internal(rtnl, m, link, SET_LINK_ADDRESS_GENERATION_MODE, true, NULL);
+        r = set_link_handler_internal(rtnl, m, link, SET_LINK_ADDRESS_GENERATION_MODE, /* ignore = */ true, NULL);
         if (r <= 0)
                 return r;
 
@@ -120,31 +127,31 @@
 }
 
 static int link_set_bond_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
-        return set_link_handler_internal(rtnl, m, link, SET_LINK_BOND, false, NULL);
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_BOND, /* ignore = */ false, NULL);
 }
 
 static int link_set_bridge_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
-        return set_link_handler_internal(rtnl, m, link, SET_LINK_BRIDGE, false, NULL);
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_BRIDGE, /* ignore = */ true, NULL);
 }
 
 static int link_set_bridge_vlan_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
-        return set_link_handler_internal(rtnl, m, link, SET_LINK_BRIDGE_VLAN, false, NULL);
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_BRIDGE_VLAN, /* ignore = */ false, NULL);
 }
 
 static int link_set_can_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
-        return set_link_handler_internal(rtnl, m, link, SET_LINK_CAN, false, NULL);
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_CAN, /* ignore = */ false, NULL);
 }
 
 static int link_set_flags_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
-        return set_link_handler_internal(rtnl, m, link, SET_LINK_FLAGS, false, get_link_update_flag_handler);
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_FLAGS, /* ignore = */ false, get_link_update_flag_handler);
 }
 
 static int link_set_group_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
-        return set_link_handler_internal(rtnl, m, link, SET_LINK_GROUP, false, NULL);
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_GROUP, /* ignore = */ false, NULL);
 }
 
 static int link_set_mac_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
-        return set_link_handler_internal(rtnl, m, link, SET_LINK_MAC, true, get_link_default_handler);
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_MAC, /* ignore = */ true, get_link_default_handler);
 }
 
 static int link_set_mac_allow_retry_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
@@ -180,13 +187,18 @@
 }
 
 static int link_set_master_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
-        return set_link_handler_internal(rtnl, m, link, SET_LINK_MASTER, false, get_link_master_handler);
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_MASTER, /* ignore = */ false, get_link_master_handler);
+}
+
+static int link_unset_master_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
+        /* Some devices do not support setting master ifindex. Let's ignore error on unsetting master ifindex. */
+        return set_link_handler_internal(rtnl, m, link, SET_LINK_MASTER, /* ignore = */ true, get_link_master_handler);
 }
 
 static int link_set_mtu_handler(sd_netlink *rtnl, sd_netlink_message *m, Link *link) {
         int r;
 
-        r = set_link_handler_internal(rtnl, m, link, SET_LINK_MTU, true, get_link_default_handler);
+        r = set_link_handler_internal(rtnl, m, link, SET_LINK_MTU, /* ignore = */ true, get_link_default_handler);
         if (r <= 0)
                 return r;
 
@@ -217,10 +229,14 @@
 
         log_link_debug(link, "Setting %s", set_link_operation_to_string(op));
 
-        if (IN_SET(op, SET_LINK_BOND, SET_LINK_CAN)) {
+        if (op == SET_LINK_BOND) {
                 r = sd_rtnl_message_new_link(link->manager->rtnl, &req, RTM_NEWLINK, link->master_ifindex);
                 if (r < 0)
                         return log_link_debug_errno(link, r, "Could not allocate RTM_NEWLINK message: %m");
+        } else if (op == SET_LINK_CAN) {
+                r = sd_rtnl_message_new_link(link->manager->rtnl, &req, RTM_NEWLINK, link->ifindex);
+                if (r < 0)
+                        return log_link_debug_errno(link, r, "Could not allocate RTM_NEWLINK message: %m");
         } else {
                 r = sd_rtnl_message_new_link(link->manager->rtnl, &req, RTM_SETLINK, link->ifindex);
                 if (r < 0)
@@ -745,10 +761,14 @@
 
 int link_request_to_set_master(Link *link) {
         assert(link);
+        assert(link->network);
 
         link->master_set = false;
 
-        return link_request_set_link(link, SET_LINK_MASTER, link_set_master_handler, NULL);
+        if (link->network->batadv || link->network->bond || link->network->bridge || link->network->vrf)
+                return link_request_set_link(link, SET_LINK_MASTER, link_set_master_handler, NULL);
+        else
+                return link_request_set_link(link, SET_LINK_MASTER, link_unset_master_handler, NULL);
 }
 
 int link_request_to_set_mtu(Link *link, uint32_t mtu) {
diff -aruN old/src/nspawn/nspawn.c new/src/nspawn/nspawn.c
--- old/src/nspawn/nspawn.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/nspawn/nspawn.c	2021-11-19 17:19:28.000000000 +0000
@@ -5354,7 +5354,7 @@
         if (fd < 0)
                 return log_error_errno(errno, "Failed to allocate udev control socket: %m");
 
-        if (connect(fd, &sa.un, SOCKADDR_UN_LEN(sa.un)) < 0) {
+        if (connect(fd, &sa.sa, SOCKADDR_UN_LEN(sa.un)) < 0) {
 
                 if (errno == ENOENT || ERRNO_IS_DISCONNECT(errno))
                         return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP),
diff -aruN old/src/nss-systemd/nss-systemd.c new/src/nss-systemd/nss-systemd.c
--- old/src/nss-systemd/nss-systemd.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/nss-systemd/nss-systemd.c	2021-11-19 17:19:28.000000000 +0000
@@ -2,6 +2,7 @@
 
 #include <nss.h>
 #include <pthread.h>
+#include <string.h>
 
 #include "env-util.h"
 #include "errno-util.h"
@@ -139,6 +140,155 @@
 NSS_SGENT_PROTOTYPES(systemd);
 NSS_INITGROUPS_PROTOTYPE(systemd);
 
+/* Since our NSS functions implement reentrant glibc APIs, we have to guarantee
+ * all the string pointers we return point into the buffer provided by the
+ * caller, not into our own static memory. */
+
+static enum nss_status copy_synthesized_passwd(
+                struct passwd *dest,
+                const struct passwd *src,
+                char *buffer, size_t buflen,
+                int *errnop) {
+
+        size_t required;
+
+        assert(dest);
+        assert(src);
+        assert(src->pw_name);
+        assert(src->pw_passwd);
+        assert(src->pw_gecos);
+        assert(src->pw_dir);
+        assert(src->pw_shell);
+
+        required = strlen(src->pw_name) + 1;
+        required += strlen(src->pw_passwd) + 1;
+        required += strlen(src->pw_gecos) + 1;
+        required += strlen(src->pw_dir) + 1;
+        required += strlen(src->pw_shell) + 1;
+
+        if (buflen < required) {
+                *errnop = ERANGE;
+                return NSS_STATUS_TRYAGAIN;
+        }
+
+        assert(buffer);
+
+        *dest = *src;
+
+        /* String fields point into the user-provided buffer */
+        dest->pw_name = buffer;
+        dest->pw_passwd = stpcpy(dest->pw_name, src->pw_name) + 1;
+        dest->pw_gecos = stpcpy(dest->pw_passwd, src->pw_passwd) + 1;
+        dest->pw_dir = stpcpy(dest->pw_gecos, src->pw_gecos) + 1;
+        dest->pw_shell = stpcpy(dest->pw_dir, src->pw_dir) + 1;
+        strcpy(dest->pw_shell, src->pw_shell);
+
+        return NSS_STATUS_SUCCESS;
+}
+
+static enum nss_status copy_synthesized_spwd(
+                struct spwd *dest,
+                const struct spwd *src,
+                char *buffer, size_t buflen,
+                int *errnop) {
+
+        size_t required;
+
+        assert(dest);
+        assert(src);
+        assert(src->sp_namp);
+        assert(src->sp_pwdp);
+
+        required = strlen(src->sp_namp) + 1;
+        required += strlen(src->sp_pwdp) + 1;
+
+        if (buflen < required) {
+                *errnop = ERANGE;
+                return NSS_STATUS_TRYAGAIN;
+        }
+
+        assert(buffer);
+
+        *dest = *src;
+
+        /* String fields point into the user-provided buffer */
+        dest->sp_namp = buffer;
+        dest->sp_pwdp = stpcpy(dest->sp_namp, src->sp_namp) + 1;
+        strcpy(dest->sp_pwdp, src->sp_pwdp);
+
+        return NSS_STATUS_SUCCESS;
+}
+
+static enum nss_status copy_synthesized_group(
+                struct group *dest,
+                const struct group *src,
+                char *buffer, size_t buflen,
+                int *errnop) {
+
+        size_t required;
+
+        assert(dest);
+        assert(src);
+        assert(src->gr_name);
+        assert(src->gr_passwd);
+        assert(src->gr_mem);
+        assert(!*src->gr_mem); /* Our synthesized records' gr_mem is always just NULL... */
+
+        required = strlen(src->gr_name) + 1;
+        required += strlen(src->gr_passwd) + 1;
+        required += 1; /* ...but that NULL still needs to be stored into the buffer! */
+
+        if (buflen < required) {
+                *errnop = ERANGE;
+                return NSS_STATUS_TRYAGAIN;
+        }
+
+        assert(buffer);
+
+        *dest = *src;
+
+        /* String fields point into the user-provided buffer */
+        dest->gr_name = buffer;
+        dest->gr_passwd = stpcpy(dest->gr_name, src->gr_name) + 1;
+        dest->gr_mem = (char **) strcpy(dest->gr_passwd, src->gr_passwd) + 1;
+        *dest->gr_mem = NULL;
+
+        return NSS_STATUS_SUCCESS;
+}
+
+static enum nss_status copy_synthesized_sgrp(
+                struct sgrp *dest,
+                const struct sgrp *src,
+                char *buffer, size_t buflen,
+                int *errnop) {
+
+        size_t required;
+
+        assert(dest);
+        assert(src);
+        assert(src->sg_namp);
+        assert(src->sg_passwd);
+
+        required = strlen(src->sg_namp) + 1;
+        required += strlen(src->sg_passwd) + 1;
+
+        if (buflen < required) {
+                *errnop = ERANGE;
+                return NSS_STATUS_TRYAGAIN;
+        }
+
+        assert(buffer);
+
+        *dest = *src;
+
+        /* String fields point into the user-provided buffer */
+        dest->sg_namp = buffer;
+        dest->sg_passwd = stpcpy(dest->sg_namp, src->sg_namp) + 1;
+        strcpy(dest->sg_passwd, src->sg_passwd);
+
+        return NSS_STATUS_SUCCESS;
+}
+
 enum nss_status _nss_systemd_getpwnam_r(
                 const char *name,
                 struct passwd *pwd,
@@ -164,17 +314,14 @@
         /* Synthesize entries for the root and nobody users, in case they are missing in /etc/passwd */
         if (getenv_bool_secure("SYSTEMD_NSS_BYPASS_SYNTHETIC") <= 0) {
 
-                if (streq(name, root_passwd.pw_name)) {
-                        *pwd = root_passwd;
-                        return NSS_STATUS_SUCCESS;
-                }
+                if (streq(name, root_passwd.pw_name))
+                        return copy_synthesized_passwd(pwd, &root_passwd, buffer, buflen, errnop);
 
                 if (streq(name, nobody_passwd.pw_name)) {
                         if (!synthesize_nobody())
                                 return NSS_STATUS_NOTFOUND;
 
-                        *pwd = nobody_passwd;
-                        return NSS_STATUS_SUCCESS;
+                        return copy_synthesized_passwd(pwd, &nobody_passwd, buffer, buflen, errnop);
                 }
 
         } else if (STR_IN_SET(name, root_passwd.pw_name, nobody_passwd.pw_name))
@@ -211,17 +358,14 @@
         /* Synthesize data for the root user and for nobody in case they are missing from /etc/passwd */
         if (getenv_bool_secure("SYSTEMD_NSS_BYPASS_SYNTHETIC") <= 0) {
 
-                if (uid == root_passwd.pw_uid) {
-                        *pwd = root_passwd;
-                        return NSS_STATUS_SUCCESS;
-                }
+                if (uid == root_passwd.pw_uid)
+                        return copy_synthesized_passwd(pwd, &root_passwd, buffer, buflen, errnop);
 
                 if (uid == nobody_passwd.pw_uid) {
                         if (!synthesize_nobody())
                                 return NSS_STATUS_NOTFOUND;
 
-                        *pwd = nobody_passwd;
-                        return NSS_STATUS_SUCCESS;
+                        return copy_synthesized_passwd(pwd, &nobody_passwd, buffer, buflen, errnop);
                 }
 
         } else if (uid == root_passwd.pw_uid || uid == nobody_passwd.pw_uid)
@@ -259,17 +403,14 @@
         /* Synthesize entries for the root and nobody users, in case they are missing in /etc/passwd */
         if (getenv_bool_secure("SYSTEMD_NSS_BYPASS_SYNTHETIC") <= 0) {
 
-                if (streq(name, root_spwd.sp_namp)) {
-                        *spwd = root_spwd;
-                        return NSS_STATUS_SUCCESS;
-                }
+                if (streq(name, root_spwd.sp_namp))
+                        return copy_synthesized_spwd(spwd, &root_spwd, buffer, buflen, errnop);
 
                 if (streq(name, nobody_spwd.sp_namp)) {
                         if (!synthesize_nobody())
                                 return NSS_STATUS_NOTFOUND;
 
-                        *spwd = nobody_spwd;
-                        return NSS_STATUS_SUCCESS;
+                        return copy_synthesized_spwd(spwd, &nobody_spwd, buffer, buflen, errnop);
                 }
 
         } else if (STR_IN_SET(name, root_spwd.sp_namp, nobody_spwd.sp_namp))
@@ -309,17 +450,14 @@
         /* Synthesize records for root and nobody, in case they are missing from /etc/group */
         if (getenv_bool_secure("SYSTEMD_NSS_BYPASS_SYNTHETIC") <= 0) {
 
-                if (streq(name, root_group.gr_name)) {
-                        *gr = root_group;
-                        return NSS_STATUS_SUCCESS;
-                }
+                if (streq(name, root_group.gr_name))
+                        return copy_synthesized_group(gr, &root_group, buffer, buflen, errnop);
 
                 if (streq(name, nobody_group.gr_name)) {
                         if (!synthesize_nobody())
                                 return NSS_STATUS_NOTFOUND;
 
-                        *gr = nobody_group;
-                        return NSS_STATUS_SUCCESS;
+                        return copy_synthesized_group(gr, &nobody_group, buffer, buflen, errnop);
                 }
 
         } else if (STR_IN_SET(name, root_group.gr_name, nobody_group.gr_name))
@@ -356,17 +494,14 @@
         /* Synthesize records for root and nobody, in case they are missing from /etc/group */
         if (getenv_bool_secure("SYSTEMD_NSS_BYPASS_SYNTHETIC") <= 0) {
 
-                if (gid == root_group.gr_gid) {
-                        *gr = root_group;
-                        return NSS_STATUS_SUCCESS;
-                }
+                if (gid == root_group.gr_gid)
+                        return copy_synthesized_group(gr, &root_group, buffer, buflen, errnop);
 
                 if (gid == nobody_group.gr_gid) {
                         if (!synthesize_nobody())
                                 return NSS_STATUS_NOTFOUND;
 
-                        *gr = nobody_group;
-                        return NSS_STATUS_SUCCESS;
+                        return copy_synthesized_group(gr, &nobody_group, buffer, buflen, errnop);
                 }
 
         } else if (gid == root_group.gr_gid || gid == nobody_group.gr_gid)
@@ -404,17 +539,14 @@
         /* Synthesize records for root and nobody, in case they are missing from /etc/group */
         if (getenv_bool_secure("SYSTEMD_NSS_BYPASS_SYNTHETIC") <= 0) {
 
-                if (streq(name, root_sgrp.sg_namp)) {
-                        *sgrp = root_sgrp;
-                        return NSS_STATUS_SUCCESS;
-                }
+                if (streq(name, root_sgrp.sg_namp))
+                        return copy_synthesized_sgrp(sgrp, &root_sgrp, buffer, buflen, errnop);
 
                 if (streq(name, nobody_sgrp.sg_namp)) {
                         if (!synthesize_nobody())
                                 return NSS_STATUS_NOTFOUND;
 
-                        *sgrp = nobody_sgrp;
-                        return NSS_STATUS_SUCCESS;
+                        return copy_synthesized_sgrp(sgrp, &nobody_sgrp, buffer, buflen, errnop);
                 }
 
         } else if (STR_IN_SET(name, root_sgrp.sg_namp, nobody_sgrp.sg_namp))
diff -aruN old/src/nss-systemd/userdb-glue.c new/src/nss-systemd/userdb-glue.c
--- old/src/nss-systemd/userdb-glue.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/nss-systemd/userdb-glue.c	2021-11-19 17:19:28.000000000 +0000
@@ -35,6 +35,8 @@
         assert(hr->user_name);
         required = strlen(hr->user_name) + 1;
 
+        required += 2; /* strlen(PASSWORD_SEE_SHADOW) + 1 */
+
         assert_se(rn = user_record_real_name(hr));
         required += strlen(rn) + 1;
 
@@ -51,12 +53,12 @@
                 .pw_name = buffer,
                 .pw_uid = hr->uid,
                 .pw_gid = user_record_gid(hr),
-                .pw_passwd = (char*) PASSWORD_SEE_SHADOW,
         };
 
         assert(buffer);
 
-        pwd->pw_gecos = stpcpy(pwd->pw_name, hr->user_name) + 1;
+        pwd->pw_passwd = stpcpy(pwd->pw_name, hr->user_name) + 1;
+        pwd->pw_gecos = stpcpy(pwd->pw_passwd, PASSWORD_SEE_SHADOW) + 1;
         pwd->pw_dir = stpcpy(pwd->pw_gecos, rn) + 1;
         pwd->pw_shell = stpcpy(pwd->pw_dir, hd) + 1;
         strcpy(pwd->pw_shell, shell);
diff -aruN old/src/oom/test-oomd-util.c new/src/oom/test-oomd-util.c
--- old/src/oom/test-oomd-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/oom/test-oomd-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -90,6 +90,7 @@
         _cleanup_free_ char *cgroup = NULL;
         ManagedOOMPreference root_pref;
         OomdCGroupContext *c1, *c2;
+        CGroupMask mask;
         bool test_xattrs;
         int root_xattrs, r;
 
@@ -102,6 +103,11 @@
         if (cg_all_unified() <= 0)
                 return (void) log_tests_skipped("cgroups are not running in unified mode");
 
+        assert_se(cg_mask_supported(&mask) >= 0);
+
+        if (!FLAGS_SET(mask, CGROUP_MASK_MEMORY))
+                return (void) log_tests_skipped("cgroup memory controller is not available");
+
         assert_se(cg_pid_get_path(NULL, 0, &cgroup) >= 0);
 
         /* If we don't have permissions to set xattrs we're likely in a userns or missing capabilities
diff -aruN old/src/partition/repart.c new/src/partition/repart.c
--- old/src/partition/repart.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/partition/repart.c	2021-11-19 17:19:28.000000000 +0000
@@ -206,7 +206,12 @@
         [ENCRYPT_KEY_FILE_TPM2] = "key-file+tpm2",
 };
 
+#if HAVE_LIBCRYPTSETUP
 DEFINE_PRIVATE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(encrypt_mode, EncryptMode, ENCRYPT_KEY_FILE);
+#else
+DEFINE_PRIVATE_STRING_TABLE_LOOKUP_FROM_STRING_WITH_BOOLEAN(encrypt_mode, EncryptMode, ENCRYPT_KEY_FILE);
+#endif
+
 
 static uint64_t round_down_size(uint64_t v, uint64_t p) {
         return (v / p) * p;
@@ -2779,7 +2784,7 @@
                         return log_error_errno(r, "Failed to copy in data from '%s': %m", p->copy_blocks_path);
 
                 if (fsync(target_fd) < 0)
-                        return log_error_errno(r, "Failed to synchronize copied data blocks: %m");
+                        return log_error_errno(errno, "Failed to synchronize copied data blocks: %m");
 
                 if (p->encrypt != ENCRYPT_OFF) {
                         encrypted_dev_fd = safe_close(encrypted_dev_fd);
@@ -3055,7 +3060,7 @@
 
                 if (p->encrypt != ENCRYPT_OFF) {
                         if (fsync(encrypted_dev_fd) < 0)
-                                return log_error_errno(r, "Failed to synchronize LUKS volume: %m");
+                                return log_error_errno(errno, "Failed to synchronize LUKS volume: %m");
                         encrypted_dev_fd = safe_close(encrypted_dev_fd);
 
                         r = deactivate_luks(cd, encrypted);
@@ -4858,6 +4863,10 @@
         if (r < 0)
                 return r;
 
+#if HAVE_LIBCRYPTSETUP
+        cryptsetup_enable_logging(NULL);
+#endif
+
         if (arg_image) {
                 assert(!arg_root);
 
diff -aruN old/src/resolve/resolvconf-compat.c new/src/resolve/resolvconf-compat.c
--- old/src/resolve/resolvconf-compat.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/resolve/resolvconf-compat.c	2021-11-19 17:19:28.000000000 +0000
@@ -39,8 +39,8 @@
                "This is a compatibility alias for the resolvectl(1) tool, providing native\n"
                "command line compatibility with the resolvconf(8) tool of various Linux\n"
                "distributions and BSD systems. Some options supported by other implementations\n"
-               "are not supported and are ignored: -m, -p. Various options supported by other\n"
-               "implementations are not supported and will cause the invocation to fail: -u,\n"
+               "are not supported and are ignored: -m, -p, -u. Various options supported by other\n"
+               "implementations are not supported and will cause the invocation to fail:\n"
                "-I, -i, -l, -R, -r, -v, -V, --enable-updates, --disable-updates,\n"
                "--updates-are-enabled.\n"
                "\nSee the %2$s for details.\n",
@@ -171,8 +171,11 @@
                         log_debug("Switch -%c ignored.", c);
                         break;
 
-                /* Everybody else can agree on the existence of -u but we don't support it. */
+                /* -u supposedly should "update all subscribers". We have no subscribers, hence let's make
+                    this a NOP, and exit immediately, cleanly. */
                 case 'u':
+                        log_info("Switch -%c ignored.", c);
+                        return 0;
 
                 /* The following options are openresolv inventions we don't support. */
                 case 'I':
diff -aruN old/src/resolve/resolved-dns-server.c new/src/resolve/resolved-dns-server.c
--- old/src/resolve/resolved-dns-server.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/resolve/resolved-dns-server.c	2021-11-19 17:19:28.000000000 +0000
@@ -362,9 +362,8 @@
         if (s->possible_feature_level > level) {
                 s->possible_feature_level = level;
                 dns_server_reset_counters(s);
+                log_debug("Downgrading transaction feature level fixed an RCODE error, downgrading server %s too.", strna(dns_server_string_full(s)));
         }
-
-        log_debug("Downgrading transaction feature level fixed an RCODE error, downgrading server %s too.", strna(dns_server_string_full(s)));
 }
 
 void dns_server_packet_invalid(DnsServer *s, DnsServerFeatureLevel level) {
diff -aruN old/src/resolve/resolved-dns-stub.c new/src/resolve/resolved-dns-stub.c
--- old/src/resolve/resolved-dns-stub.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/resolve/resolved-dns-stub.c	2021-11-19 17:19:28.000000000 +0000
@@ -585,7 +585,7 @@
                         DNS_PACKET_RD(q->request_packet),
                         !!q->request_packet->opt,
                         edns0_do,
-                        DNS_PACKET_AD(q->request_packet) && dns_query_fully_authenticated(q),
+                        (DNS_PACKET_AD(q->request_packet) || DNS_PACKET_DO(q->request_packet)) && dns_query_fully_authenticated(q),
                         DNS_PACKET_CD(q->request_packet),
                         q->stub_listener_extra ? ADVERTISE_EXTRA_DATAGRAM_SIZE_MAX : ADVERTISE_DATAGRAM_SIZE_MAX,
                         dns_packet_has_nsid_request(q->request_packet) > 0 && !q->stub_listener_extra);
@@ -627,7 +627,7 @@
                         DNS_PACKET_RD(p),
                         !!p->opt,
                         DNS_PACKET_DO(p),
-                        DNS_PACKET_AD(p) && authenticated,
+                        (DNS_PACKET_AD(p) || DNS_PACKET_DO(p)) && authenticated,
                         DNS_PACKET_CD(p),
                         l ? ADVERTISE_EXTRA_DATAGRAM_SIZE_MAX : ADVERTISE_DATAGRAM_SIZE_MAX,
                         dns_packet_has_nsid_request(p) > 0 && !l);
diff -aruN old/src/resolve/resolved-dns-transaction.c new/src/resolve/resolved-dns-transaction.c
--- old/src/resolve/resolved-dns-transaction.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/resolve/resolved-dns-transaction.c	2021-11-19 17:19:28.000000000 +0000
@@ -1142,22 +1142,35 @@
                                 break;
                         }
 
-                        /* Reduce this feature level by one and try again. */
-                        switch (t->current_feature_level) {
-                        case DNS_SERVER_FEATURE_LEVEL_TLS_DO:
-                                t->clamp_feature_level_servfail = DNS_SERVER_FEATURE_LEVEL_TLS_PLAIN;
-                                break;
-                        case DNS_SERVER_FEATURE_LEVEL_TLS_PLAIN + 1:
-                                /* Skip plain TLS when TLS is not supported */
-                                t->clamp_feature_level_servfail = DNS_SERVER_FEATURE_LEVEL_TLS_PLAIN - 1;
-                                break;
-                        default:
-                                t->clamp_feature_level_servfail = t->current_feature_level - 1;
-                        }
+                        /* SERVFAIL can happen for many reasons and may be transient.
+                         * To avoid unnecessary downgrades retry once with the initial level.
+                         * Check for clamp_feature_level_servfail having an invalid value as a sign that this is the
+                         * first attempt to downgrade. If so, clamp to the current value so that the transaction
+                         * is retried without actually downgrading. If the next try also fails we will downgrade by
+                         * hitting the else branch below. */
+                        if (DNS_PACKET_RCODE(p) == DNS_RCODE_SERVFAIL &&
+                            t->clamp_feature_level_servfail < 0) {
+                                t->clamp_feature_level_servfail = t->current_feature_level;
+                                log_debug("Server returned error %s, retrying transaction.",
+                                          dns_rcode_to_string(DNS_PACKET_RCODE(p)));
+                        } else {
+                                /* Reduce this feature level by one and try again. */
+                                switch (t->current_feature_level) {
+                                case DNS_SERVER_FEATURE_LEVEL_TLS_DO:
+                                        t->clamp_feature_level_servfail = DNS_SERVER_FEATURE_LEVEL_TLS_PLAIN;
+                                        break;
+                                case DNS_SERVER_FEATURE_LEVEL_TLS_PLAIN + 1:
+                                        /* Skip plain TLS when TLS is not supported */
+                                        t->clamp_feature_level_servfail = DNS_SERVER_FEATURE_LEVEL_TLS_PLAIN - 1;
+                                        break;
+                                default:
+                                        t->clamp_feature_level_servfail = t->current_feature_level - 1;
+                                }
 
-                        log_debug("Server returned error %s, retrying transaction with reduced feature level %s.",
-                                  dns_rcode_to_string(DNS_PACKET_RCODE(p)),
-                                  dns_server_feature_level_to_string(t->clamp_feature_level_servfail));
+                                log_debug("Server returned error %s, retrying transaction with reduced feature level %s.",
+                                          dns_rcode_to_string(DNS_PACKET_RCODE(p)),
+                                          dns_server_feature_level_to_string(t->clamp_feature_level_servfail));
+                        }
 
                         dns_transaction_retry(t, false /* use the same server */);
                         return;
diff -aruN old/src/resolve/resolved-resolv-conf.c new/src/resolve/resolved-resolv-conf.c
--- old/src/resolve/resolved-resolv-conf.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/resolve/resolved-resolv-conf.c	2021-11-19 17:19:28.000000000 +0000
@@ -216,6 +216,13 @@
                 return;
         }
 
+        /* resolv.conf simply doesn't support any other ports than 53, hence there's nothing much we can
+         * do — we have to suppress these entries */
+        if (dns_server_port(s) != 53) {
+                log_debug("DNS server %s with non-standard UDP port number, suppressing from generated resolv.conf.", dns_server_string(s));
+                return;
+        }
+
         /* Check if the scope this DNS server belongs to is suitable as 'default' route for lookups; resolv.conf does
          * not have a syntax to express that, so it must not appear as a global name server to avoid routing unrelated
          * domains to it (which is a privacy violation, will most probably fail anyway, and adds unnecessary load) */
diff -aruN old/src/run/run.c new/src/run/run.c
--- old/src/run/run.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/run/run.c	2021-11-19 17:19:28.000000000 +0000
@@ -506,6 +506,10 @@
                         assert_not_reached("Unhandled option");
                 }
 
+        /* If we are talking to the per-user instance PolicyKit isn't going to help */
+        if (arg_user)
+                arg_ask_password = false;
+
         with_trigger = !!arg_path_property || !!arg_socket_property || arg_with_timer;
 
         /* currently, only single trigger (path, socket, timer) unit can be created simultaneously */
diff -aruN old/src/shared/creds-util.c new/src/shared/creds-util.c
--- old/src/shared/creds-util.c	1970-01-01 01:00:00.000000000 +0100
+++ new/src/shared/creds-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -0,0 +1,954 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+#include <sys/file.h>
+
+#if HAVE_OPENSSL
+#include <openssl/err.h>
+#endif
+
+#include "sd-id128.h"
+
+#include "blockdev-util.h"
+#include "chattr-util.h"
+#include "creds-util.h"
+#include "env-util.h"
+#include "fd-util.h"
+#include "fileio.h"
+#include "fs-util.h"
+#include "io-util.h"
+#include "memory-util.h"
+#include "mkdir.h"
+#include "openssl-util.h"
+#include "path-util.h"
+#include "random-util.h"
+#include "sparse-endian.h"
+#include "stat-util.h"
+#include "tpm2-util.h"
+#include "virt.h"
+
+bool credential_name_valid(const char *s) {
+        /* We want that credential names are both valid in filenames (since that's our primary way to pass
+         * them around) and as fdnames (which is how we might want to pass them around eventually) */
+        return filename_is_valid(s) && fdname_is_valid(s);
+}
+
+int get_credentials_dir(const char **ret) {
+        const char *e;
+
+        assert(ret);
+
+        e = secure_getenv("CREDENTIALS_DIRECTORY");
+        if (!e)
+                return -ENXIO;
+
+        if (!path_is_absolute(e) || !path_is_normalized(e))
+                return -EINVAL;
+
+        *ret = e;
+        return 0;
+}
+
+int read_credential(const char *name, void **ret, size_t *ret_size) {
+        _cleanup_free_ char *fn = NULL;
+        const char *d;
+        int r;
+
+        assert(ret);
+
+        if (!credential_name_valid(name))
+                return -EINVAL;
+
+        r = get_credentials_dir(&d);
+        if (r < 0)
+                return r;
+
+        fn = path_join(d, name);
+        if (!fn)
+                return -ENOMEM;
+
+        return read_full_file_full(
+                        AT_FDCWD, fn,
+                        UINT64_MAX, SIZE_MAX,
+                        READ_FULL_FILE_SECURE,
+                        NULL,
+                        (char**) ret, ret_size);
+}
+
+#if HAVE_OPENSSL
+
+#define CREDENTIAL_HOST_SECRET_SIZE 4096
+
+static const sd_id128_t credential_app_id =
+        SD_ID128_MAKE(d3,ac,ec,ba,0d,ad,4c,df,b8,c9,38,15,28,93,6c,58);
+
+struct credential_host_secret_format {
+        /* The hashed machine ID of the machine this belongs to. Why? We want to ensure that each machine
+         * gets its own secret, even if people forget to flush out this secret file. Hence we bind it to the
+         * machine ID, for which there's hopefully a better chance it will be flushed out. We use a hashed
+         * machine ID instead of the literal one, because it's trivial to, and it might be a good idea not
+         * being able to directly associate a secret key file with a host. */
+        sd_id128_t machine_id;
+
+        /* The actual secret key */
+        uint8_t data[CREDENTIAL_HOST_SECRET_SIZE];
+} _packed_;
+
+static int make_credential_host_secret(
+                int dfd,
+                const sd_id128_t machine_id,
+                const char *fn,
+                void **ret_data,
+                size_t *ret_size) {
+
+        struct credential_host_secret_format buf;
+        _cleanup_free_ char *t = NULL;
+        _cleanup_close_ int fd = -1;
+        int r;
+
+        assert(dfd >= 0);
+        assert(fn);
+
+        fd = openat(dfd, ".", O_CLOEXEC|O_WRONLY|O_TMPFILE, 0400);
+        if (fd < 0) {
+                log_debug_errno(errno, "Failed to create temporary credential file with O_TMPFILE, proceeding without: %m");
+
+                if (asprintf(&t, "credential.secret.%016" PRIx64, random_u64()) < 0)
+                        return -ENOMEM;
+
+                fd = openat(dfd, t, O_CLOEXEC|O_WRONLY|O_CREAT|O_EXCL|O_NOFOLLOW, 0400);
+                if (fd < 0)
+                        return -errno;
+        }
+
+        r = chattr_secret(fd, 0);
+        if (r < 0)
+                log_debug_errno(r, "Failed to set file attributes for secrets file, ignoring: %m");
+
+        buf = (struct credential_host_secret_format) {
+                .machine_id = machine_id,
+        };
+
+        r = genuine_random_bytes(buf.data, sizeof(buf.data), RANDOM_BLOCK);
+        if (r < 0)
+                goto finish;
+
+        r = loop_write(fd, &buf, sizeof(buf), false);
+        if (r < 0)
+                goto finish;
+
+        if (fsync(fd) < 0) {
+                r = -errno;
+                goto finish;
+        }
+
+        if (t) {
+                r = rename_noreplace(dfd, t, dfd, fn);
+                if (r < 0)
+                        goto finish;
+
+                t = mfree(t);
+        } else if (linkat(fd, "", dfd, fn, AT_EMPTY_PATH) < 0) {
+                r = -errno;
+                goto finish;
+        }
+
+        if (fsync(dfd) < 0) {
+                r = -errno;
+                goto finish;
+        }
+
+        if (ret_data) {
+                void *copy;
+
+                copy = memdup(buf.data, sizeof(buf.data));
+                if (!copy) {
+                        r = -ENOMEM;
+                        goto finish;
+                }
+
+                *ret_data = copy;
+        }
+
+        if (ret_size)
+                *ret_size = sizeof(buf.data);
+
+        r = 0;
+
+finish:
+        if (t && unlinkat(dfd, t, 0) < 0)
+                log_debug_errno(errno, "Failed to remove temporary credential key: %m");
+
+        explicit_bzero_safe(&buf, sizeof(buf));
+        return r;
+}
+
+int get_credential_host_secret(CredentialSecretFlags flags, void **ret, size_t *ret_size) {
+        _cleanup_free_ char *efn = NULL, *ep = NULL;
+        _cleanup_close_ int dfd = -1;
+        sd_id128_t machine_id;
+        const char *e, *fn, *p;
+        int r;
+
+        r = sd_id128_get_machine_app_specific(credential_app_id, &machine_id);
+        if (r < 0)
+                return r;
+
+        e = secure_getenv("SYSTEMD_CREDENTIAL_SECRET");
+        if (e) {
+                if (!path_is_normalized(e))
+                        return -EINVAL;
+                if (!path_is_absolute(e))
+                        return -EINVAL;
+
+                r = path_extract_directory(e, &ep);
+                if (r < 0)
+                        return r;
+
+                r = path_extract_filename(e, &efn);
+                if (r < 0)
+                        return r;
+
+                p = ep;
+                fn = efn;
+        } else {
+                p = "/var/lib/systemd";
+                fn = "credential.secret";
+        }
+
+        (void) mkdir_p(p, 0755);
+        dfd = open(p, O_CLOEXEC|O_DIRECTORY|O_RDONLY);
+        if (dfd < 0)
+                return -errno;
+
+        if (FLAGS_SET(flags, CREDENTIAL_SECRET_FAIL_ON_TEMPORARY_FS)) {
+                r = fd_is_temporary_fs(dfd);
+                if (r < 0)
+                        return r;
+                if (r > 0)
+                        return -ENOMEDIUM;
+        }
+
+        for (unsigned attempt = 0;; attempt++) {
+                _cleanup_(erase_and_freep) struct credential_host_secret_format *f = NULL;
+                _cleanup_close_ int fd = -1;
+                size_t l = 0;
+                ssize_t n = 0;
+                struct stat st;
+
+                if (attempt >= 3) /* Somebody is playing games with us */
+                        return -EIO;
+
+                fd = openat(dfd, fn, O_CLOEXEC|O_RDONLY|O_NOCTTY|O_NOFOLLOW);
+                if (fd < 0) {
+                        if (errno != ENOENT || !FLAGS_SET(flags, CREDENTIAL_SECRET_GENERATE))
+                                return -errno;
+
+                        r = make_credential_host_secret(dfd, machine_id, fn, ret, ret_size);
+                        if (r == -EEXIST) {
+                                log_debug_errno(r, "Credential secret was created while we were creating it. Trying to read new secret.");
+                                continue;
+                        }
+                        if (r < 0)
+                                return r;
+
+                        return 0;
+                }
+
+                if (fstat(fd, &st) < 0)
+                        return -errno;
+
+                r = stat_verify_regular(&st);
+                if (r < 0)
+                        return r;
+                if (st.st_nlink == 0) /* Deleted by now, try again */
+                        continue;
+                if (st.st_nlink > 1)
+                        return -EPERM; /* Our deletion check won't work if hardlinked somewhere else */
+                if ((st.st_mode & 07777) != 0400) /* Don't use file if not 0400 access mode */
+                        return -EPERM;
+                if (st.st_size > 16*1024*1024)
+                        return -E2BIG;
+                l = st.st_size;
+                if (l < offsetof(struct credential_host_secret_format, data) + 1)
+                        return -EINVAL;
+
+                f = malloc(l+1);
+                if (!f)
+                        return -ENOMEM;
+
+                n = read(fd, f, l+1);
+                if (n < 0)
+                        return -errno;
+                if ((size_t) n != l) /* What? The size changed? */
+                        return -EIO;
+
+                if (sd_id128_equal(machine_id, f->machine_id)) {
+                        size_t sz;
+
+                        if (FLAGS_SET(flags, CREDENTIAL_SECRET_WARN_NOT_ENCRYPTED)) {
+                                r = fd_is_encrypted(fd);
+                                if (r < 0)
+                                        log_debug_errno(r, "Failed to determine if credential secret file '%s/%s' is encrypted.", p, fn);
+                                else if (r == 0)
+                                        log_warning("Credential secret file '%s/%s' is not located on encrypted media, using anyway.", p, fn);
+                        }
+
+                        sz = l - offsetof(struct credential_host_secret_format, data);
+                        assert(sz > 0);
+
+                        if (ret) {
+                                void *copy;
+
+                                assert(sz <= sizeof(f->data)); /* Ensure we don't read past f->data bounds */
+
+                                copy = memdup(f->data, sz);
+                                if (!copy)
+                                        return -ENOMEM;
+
+                                *ret = copy;
+                        }
+
+                        if (ret_size)
+                                *ret_size = sz;
+
+                        return 0;
+                }
+
+                /* Hmm, this secret is from somewhere else. Let's delete the file. Let's first acquire a lock
+                 * to ensure we are the only ones accessing the file while we delete it. */
+
+                if (flock(fd, LOCK_EX) < 0)
+                        return -errno;
+
+                /* Before we delete it check that the file is still linked into the file system */
+                if (fstat(fd, &st) < 0)
+                        return -errno;
+                if (st.st_nlink == 0) /* Already deleted by now? */
+                        continue;
+                if (st.st_nlink != 1) /* Safety check, someone is playing games with us */
+                        return -EPERM;
+
+                if (unlinkat(dfd, fn, 0) < 0)
+                        return -errno;
+
+                /* And now try again */
+        }
+}
+
+/* Construction is like this:
+ *
+ * A symmetric encryption key is derived from:
+ *
+ *      1. Either the "host" key (a key stored in /var/lib/credential.secret)
+ *
+ *      2. A key generated by letting the TPM2 calculate an HMAC hash of some nonce we pass to it, keyed
+ *         by a key derived from its internal seed key.
+ *
+ *      3. The concatenation of the above.
+ *
+ * The above is hashed with SHA256 which is then used as encryption key for AES256-GCM. The encrypted
+ * credential is a short (unencrypted) header describing which of the three keys to use, the IV to use for
+ * AES256-GCM and some more meta information (sizes of certain objects) that is strictly speaking redundant,
+ * but kinda nice to have since we can have a more generic parser. If the TPM2 key is used this is followed
+ * by another (unencrypted) header, with information about the TPM2 policy used (specifically: the PCR mask
+ * to bind against, and a hash of the resulting policy — the latter being redundant, but speeding up things a
+ * bit, since we can more quickly refuse PCR state), followed by a sealed/exported TPM2 HMAC key. This is
+ * then followed by the encrypted data, which begins with a metadata header (which contains validity
+ * timestamps as well as the credential name), followed by the actual credential payload. The file ends in
+ * the AES256-GCM tag. To make things simple, the AES256-GCM AAD covers the main and the TPM2 header in
+ * full. This means the whole file is either protected by AAD, or is ciphertext, or is the tag. No
+ * unprotected data is included.
+ */
+
+struct _packed_ encrypted_credential_header {
+        sd_id128_t id;
+        le32_t key_size;
+        le32_t block_size;
+        le32_t iv_size;
+        le32_t tag_size;
+        uint8_t iv[];
+        /* Followed by NUL bytes until next 8 byte boundary */
+};
+
+struct _packed_ tpm2_credential_header {
+        le64_t pcr_mask;    /* Note that the spec for PC Clients only mandates 24 PCRs, and that's what systems
+                             * generally have. But keep the door open for more. */
+        le16_t pcr_bank;    /* For now, either TPM2_ALG_SHA256 or TPM2_ALG_SHA1 */
+        le16_t primary_alg; /* Primary key algorithm (either TPM2_ALG_RSA or TPM2_ALG_ECC for now) */
+        le32_t blob_size;
+        le32_t policy_hash_size;
+        uint8_t policy_hash_and_blob[];
+        /* Followed by NUL bytes until next 8 byte boundary */
+};
+
+struct _packed_ metadata_credential_header {
+        le64_t timestamp;
+        le64_t not_after;
+        le32_t name_size;
+        char name[];
+        /* Followed by NUL bytes until next 8 byte boundary */
+};
+
+/* Some generic limit for parts of the encrypted credential for which we don't know the right size ahead of
+ * time, but where we are really sure it won't be larger than this. Should be larger than any possible IV,
+ * padding, tag size and so on. This is purely used for early filtering out of invalid sizes. */
+#define CREDENTIAL_FIELD_SIZE_MAX (16U*1024U)
+
+static int sha256_hash_host_and_tpm2_key(
+                const void *host_key,
+                size_t host_key_size,
+                const void *tpm2_key,
+                size_t tpm2_key_size,
+                uint8_t ret[static SHA256_DIGEST_LENGTH]) {
+
+        _cleanup_(EVP_MD_CTX_freep) EVP_MD_CTX *md = NULL;
+        unsigned l;
+
+        assert(host_key_size == 0 || host_key);
+        assert(tpm2_key_size == 0 || tpm2_key);
+        assert(ret);
+
+        /* Combines the host key and the TPM2 HMAC hash into a SHA256 hash value we'll use as symmetric encryption key. */
+
+        md = EVP_MD_CTX_new();
+        if (!md)
+                return log_oom();
+
+        if (EVP_DigestInit_ex(md, EVP_sha256(), NULL) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to initial SHA256 context.");
+
+        if (host_key && EVP_DigestUpdate(md, host_key, host_key_size) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to hash host key.");
+
+        if (tpm2_key && EVP_DigestUpdate(md, tpm2_key, tpm2_key_size) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to hash TPM2 key.");
+
+        assert(EVP_MD_CTX_size(md) == SHA256_DIGEST_LENGTH);
+
+        if (EVP_DigestFinal_ex(md, ret, &l) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to finalize SHA256 hash.");
+
+        assert(l == SHA256_DIGEST_LENGTH);
+        return 0;
+}
+
+int encrypt_credential_and_warn(
+                sd_id128_t with_key,
+                const char *name,
+                usec_t timestamp,
+                usec_t not_after,
+                const char *tpm2_device,
+                uint32_t tpm2_pcr_mask,
+                const void *input,
+                size_t input_size,
+                void **ret,
+                size_t *ret_size) {
+
+        _cleanup_(EVP_CIPHER_CTX_freep) EVP_CIPHER_CTX *context = NULL;
+        _cleanup_(erase_and_freep) void *host_key = NULL, *tpm2_key = NULL;
+        size_t host_key_size = 0, tpm2_key_size = 0, tpm2_blob_size = 0, tpm2_policy_hash_size = 0, output_size, p, ml;
+        _cleanup_free_ void *tpm2_blob = NULL, *tpm2_policy_hash = NULL, *iv = NULL, *output = NULL;
+        _cleanup_free_ struct metadata_credential_header *m = NULL;
+        uint16_t tpm2_pcr_bank = 0, tpm2_primary_alg = 0;
+        struct encrypted_credential_header *h;
+        int ksz, bsz, ivsz, tsz, added, r;
+        uint8_t md[SHA256_DIGEST_LENGTH];
+        const EVP_CIPHER *cc;
+#if HAVE_TPM2
+        bool try_tpm2 = false;
+#endif
+        sd_id128_t id;
+
+        assert(input || input_size == 0);
+        assert(ret);
+        assert(ret_size);
+
+        if (name && !credential_name_valid(name))
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Invalid credential name: %s", name);
+
+        if (not_after != USEC_INFINITY && timestamp != USEC_INFINITY && not_after < timestamp)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Credential is invalidated before it is valid (" USEC_FMT " < " USEC_FMT ").", not_after, timestamp);
+
+        if (DEBUG_LOGGING) {
+                char buf[FORMAT_TIMESTAMP_MAX];
+
+                if (name)
+                        log_debug("Including credential name '%s' in encrypted credential.", name);
+                if (timestamp != USEC_INFINITY)
+                        log_debug("Including timestamp '%s' in encrypted credential.", format_timestamp(buf, sizeof(buf), timestamp));
+                if (not_after != USEC_INFINITY)
+                        log_debug("Including not-after timestamp '%s' in encrypted credential.", format_timestamp(buf, sizeof(buf), not_after));
+        }
+
+        if (sd_id128_is_null(with_key) ||
+            sd_id128_in_set(with_key, CRED_AES256_GCM_BY_HOST, CRED_AES256_GCM_BY_HOST_AND_TPM2_HMAC)) {
+
+                r = get_credential_host_secret(
+                                CREDENTIAL_SECRET_GENERATE|
+                                CREDENTIAL_SECRET_WARN_NOT_ENCRYPTED|
+                                (sd_id128_is_null(with_key) ? CREDENTIAL_SECRET_FAIL_ON_TEMPORARY_FS : 0),
+                                &host_key,
+                                &host_key_size);
+                if (r == -ENOMEDIUM && sd_id128_is_null(with_key))
+                        log_debug_errno(r, "Credential host secret location on temporary file system, not using.");
+                else if (r < 0)
+                        return log_error_errno(r, "Failed to determine local credential host secret: %m");
+        }
+
+#if HAVE_TPM2
+        if (sd_id128_is_null(with_key)) {
+                /* If automatic mode is selected and we are running in a container, let's not try TPM2. OTOH
+                 * if user picks TPM2 explicitly, let's always honour the request and try. */
+
+                r = detect_container();
+                if (r < 0)
+                        log_debug_errno(r, "Failed to determine whether we are running in a container, ignoring: %m");
+                else if (r > 0)
+                        log_debug("Running in container, not attempting to use TPM2.");
+
+                try_tpm2 = r <= 0;
+        }
+
+        if (try_tpm2 ||
+            sd_id128_in_set(with_key, CRED_AES256_GCM_BY_TPM2_HMAC, CRED_AES256_GCM_BY_HOST_AND_TPM2_HMAC)) {
+
+                r = tpm2_seal(tpm2_device,
+                              tpm2_pcr_mask,
+                              &tpm2_key,
+                              &tpm2_key_size,
+                              &tpm2_blob,
+                              &tpm2_blob_size,
+                              &tpm2_policy_hash,
+                              &tpm2_policy_hash_size,
+                              &tpm2_pcr_bank,
+                              &tpm2_primary_alg);
+                if (r < 0) {
+                        if (!sd_id128_is_null(with_key))
+                                return r;
+
+                        log_debug_errno(r, "TPM2 sealing didn't work, not using: %m");
+                }
+
+                assert(tpm2_blob_size <= CREDENTIAL_FIELD_SIZE_MAX);
+                assert(tpm2_policy_hash_size <= CREDENTIAL_FIELD_SIZE_MAX);
+        }
+#endif
+
+        if (sd_id128_is_null(with_key)) {
+                /* Let's settle the key type in auto mode now. */
+
+                if (host_key && tpm2_key)
+                        id = CRED_AES256_GCM_BY_HOST_AND_TPM2_HMAC;
+                else if (tpm2_key)
+                        id = CRED_AES256_GCM_BY_TPM2_HMAC;
+                else if (host_key)
+                        id = CRED_AES256_GCM_BY_HOST;
+                else
+                        return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
+                                               "TPM2 not available and host key located on temporary file system, no encryption key available.");
+        } else
+                id = with_key;
+
+        /* Let's now take the host key and the TPM2 key and hash it together, to use as encryption key for the data */
+        r = sha256_hash_host_and_tpm2_key(host_key, host_key_size, tpm2_key, tpm2_key_size, md);
+        if (r < 0)
+                return r;
+
+        assert_se(cc = EVP_aes_256_gcm());
+
+        ksz = EVP_CIPHER_key_length(cc);
+        assert(ksz == sizeof(md));
+
+        bsz = EVP_CIPHER_block_size(cc);
+        assert(bsz > 0);
+        assert((size_t) bsz <= CREDENTIAL_FIELD_SIZE_MAX);
+
+        ivsz = EVP_CIPHER_iv_length(cc);
+        if (ivsz > 0) {
+                assert((size_t) ivsz <= CREDENTIAL_FIELD_SIZE_MAX);
+
+                iv = malloc(ivsz);
+                if (!iv)
+                        return log_oom();
+
+                r = genuine_random_bytes(iv, ivsz, RANDOM_BLOCK);
+                if (r < 0)
+                        return log_error_errno(r, "Failed to acquired randomized IV: %m");
+        }
+
+        tsz = 16; /* FIXME: On OpenSSL 3 there is EVP_CIPHER_CTX_get_tag_length(), until then let's hardcode this */
+
+        context = EVP_CIPHER_CTX_new();
+        if (!context)
+                return log_error_errno(SYNTHETIC_ERRNO(ENOMEM), "Failed to allocate encryption object: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        if (EVP_EncryptInit_ex(context, cc, NULL, md, iv) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to initialize encryption context: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        /* Just an upper estimate */
+        output_size =
+                ALIGN8(offsetof(struct encrypted_credential_header, iv) + ivsz) +
+                ALIGN8(tpm2_key ? offsetof(struct tpm2_credential_header, policy_hash_and_blob) + tpm2_blob_size + tpm2_policy_hash_size : 0) +
+                ALIGN8(offsetof(struct metadata_credential_header, name) + strlen_ptr(name)) +
+                input_size + 2U * (size_t) bsz +
+                tsz;
+
+        output = malloc0(output_size);
+        if (!output)
+                return log_oom();
+
+        h = (struct encrypted_credential_header*) output;
+        h->id = id;
+        h->block_size = htole32(bsz);
+        h->key_size = htole32(ksz);
+        h->tag_size = htole32(tsz);
+        h->iv_size = htole32(ivsz);
+        memcpy(h->iv, iv, ivsz);
+
+        p = ALIGN8(offsetof(struct encrypted_credential_header, iv) + ivsz);
+
+        if (tpm2_key) {
+                struct tpm2_credential_header *t;
+
+                t = (struct tpm2_credential_header*) ((uint8_t*) output + p);
+                t->pcr_mask = htole64(tpm2_pcr_mask);
+                t->pcr_bank = htole16(tpm2_pcr_bank);
+                t->primary_alg = htole16(tpm2_primary_alg);
+                t->blob_size = htole32(tpm2_blob_size);
+                t->policy_hash_size = htole32(tpm2_policy_hash_size);
+                memcpy(t->policy_hash_and_blob, tpm2_blob, tpm2_blob_size);
+                memcpy(t->policy_hash_and_blob + tpm2_blob_size, tpm2_policy_hash, tpm2_policy_hash_size);
+
+                p += ALIGN8(offsetof(struct tpm2_credential_header, policy_hash_and_blob) + tpm2_blob_size + tpm2_policy_hash_size);
+        }
+
+        /* Pass the encrypted + TPM2 header as AAD */
+        if (EVP_EncryptUpdate(context, NULL, &added, output, p) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to write AAD data: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        /* Now construct the metadata header */
+        ml = strlen_ptr(name);
+        m = malloc0(ALIGN8(offsetof(struct metadata_credential_header, name) + ml));
+        if (!m)
+                return log_oom();
+
+        m->timestamp = htole64(timestamp);
+        m->not_after = htole64(not_after);
+        m->name_size = htole32(ml);
+        memcpy_safe(m->name, name, ml);
+
+        /* And encrypt the metadata header */
+        if (EVP_EncryptUpdate(context, (uint8_t*) output + p, &added, (const unsigned char*) m, ALIGN8(offsetof(struct metadata_credential_header, name) + ml)) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to encrypt metadata header: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        assert(added >= 0);
+        assert((size_t) added <= output_size - p);
+        p += added;
+
+        /* Then encrypt the plaintext */
+        if (EVP_EncryptUpdate(context, (uint8_t*) output + p, &added, input, input_size) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to encrypt data: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        assert(added >= 0);
+        assert((size_t) added <= output_size - p);
+        p += added;
+
+        /* Finalize */
+        if (EVP_EncryptFinal_ex(context, (uint8_t*) output + p, &added) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to finalize data encryption: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        assert(added >= 0);
+        assert((size_t) added <= output_size - p);
+        p += added;
+
+        assert(p <= output_size - tsz);
+
+        /* Append tag */
+        if (EVP_CIPHER_CTX_ctrl(context, EVP_CTRL_GCM_GET_TAG, tsz, (uint8_t*) output + p) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to get tag: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        p += tsz;
+        assert(p <= output_size);
+
+        if (DEBUG_LOGGING && input_size > 0) {
+                size_t base64_size;
+
+                base64_size = DIV_ROUND_UP(p * 4, 3); /* Include base64 size increase in debug output */
+                assert(base64_size >= input_size);
+                log_debug("Input of %zu bytes grew to output of %zu bytes (+%2zu%%).", input_size, base64_size, base64_size * 100 / input_size - 100);
+        }
+
+        *ret = TAKE_PTR(output);
+        *ret_size = p;
+
+        return 0;
+}
+
+int decrypt_credential_and_warn(
+                const char *validate_name,
+                usec_t validate_timestamp,
+                const char *tpm2_device,
+                const void *input,
+                size_t input_size,
+                void **ret,
+                size_t *ret_size) {
+
+        _cleanup_(erase_and_freep) void *host_key = NULL, *tpm2_key = NULL, *plaintext = NULL;
+        _cleanup_(EVP_CIPHER_CTX_freep) EVP_CIPHER_CTX *context = NULL;
+        size_t host_key_size = 0, tpm2_key_size = 0, plaintext_size, p, hs;
+        struct encrypted_credential_header *h;
+        struct metadata_credential_header *m;
+        uint8_t md[SHA256_DIGEST_LENGTH];
+        bool with_tpm2, with_host_key;
+        const EVP_CIPHER *cc;
+        int r, added;
+
+        assert(input || input_size == 0);
+        assert(ret);
+        assert(ret_size);
+
+        h = (struct encrypted_credential_header*) input;
+
+        /* The ID must fit in, for the current and all future formats */
+        if (input_size < sizeof(h->id))
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Encrypted file too short.");
+
+        with_host_key = sd_id128_in_set(h->id, CRED_AES256_GCM_BY_HOST, CRED_AES256_GCM_BY_HOST_AND_TPM2_HMAC);
+        with_tpm2 = sd_id128_in_set(h->id, CRED_AES256_GCM_BY_TPM2_HMAC, CRED_AES256_GCM_BY_HOST_AND_TPM2_HMAC);
+
+        if (!with_host_key && !with_tpm2)
+                return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP), "Unknown encryption format, or corrupted data: %m");
+
+        /* Now we know the minimum header size */
+        if (input_size < offsetof(struct encrypted_credential_header, iv))
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Encrypted file too short.");
+
+        /* Verify some basic header values */
+        if (le32toh(h->key_size) != sizeof(md))
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Unexpected key size in header.");
+        if (le32toh(h->block_size) <= 0 || le32toh(h->block_size) > CREDENTIAL_FIELD_SIZE_MAX)
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Unexpected block size in header.");
+        if (le32toh(h->iv_size) > CREDENTIAL_FIELD_SIZE_MAX)
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "IV size too large.");
+        if (le32toh(h->tag_size) != 16) /* FIXME: On OpenSSL 3, let's verify via EVP_CIPHER_CTX_get_tag_length() */
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Unexpected tag size in header.");
+
+        /* Ensure we have space for the full header now (we don't know the size of the name hence this is a
+         * lower limit only) */
+        if (input_size <
+            ALIGN8(offsetof(struct encrypted_credential_header, iv) + le32toh(h->iv_size)) +
+            ALIGN8((with_tpm2 ? offsetof(struct tpm2_credential_header, policy_hash_and_blob) : 0)) +
+            ALIGN8(offsetof(struct metadata_credential_header, name)) +
+            le32toh(h->tag_size))
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Encrypted file too short.");
+
+        p = ALIGN8(offsetof(struct encrypted_credential_header, iv) + le32toh(h->iv_size));
+
+        if (with_tpm2) {
+#if HAVE_TPM2
+                struct tpm2_credential_header* t = (struct tpm2_credential_header*) ((uint8_t*) input + p);
+
+                if (le64toh(t->pcr_mask) >= (UINT64_C(1) << TPM2_PCRS_MAX))
+                        return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "TPM2 PCR mask out of range.");
+                if (!tpm2_pcr_bank_to_string(le16toh(t->pcr_bank)))
+                        return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "TPM2 PCR bank invalid or not supported");
+                if (!tpm2_primary_alg_to_string(le16toh(t->primary_alg)))
+                        return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "TPM2 primary key algorithm invalid or not supported.");
+                if (le32toh(t->blob_size) > CREDENTIAL_FIELD_SIZE_MAX)
+                        return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Unexpected TPM2 blob size.");
+                if (le32toh(t->policy_hash_size) > CREDENTIAL_FIELD_SIZE_MAX)
+                        return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Unexpected TPM2 policy hash size.");
+
+                /* Ensure we have space for the full TPM2 header now (still don't know the name, and its size
+                 * though, hence still just a lower limit test only) */
+                if (input_size <
+                    ALIGN8(offsetof(struct encrypted_credential_header, iv) + le32toh(h->iv_size)) +
+                    ALIGN8(offsetof(struct tpm2_credential_header, policy_hash_and_blob) + le32toh(t->blob_size) + le32toh(t->policy_hash_size)) +
+                    ALIGN8(offsetof(struct metadata_credential_header, name)) +
+                    le32toh(h->tag_size))
+                        return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Encrypted file too short.");
+
+                r = tpm2_unseal(tpm2_device,
+                                le64toh(t->pcr_mask),
+                                le16toh(t->pcr_bank),
+                                le16toh(t->primary_alg),
+                                t->policy_hash_and_blob,
+                                le32toh(t->blob_size),
+                                t->policy_hash_and_blob + le32toh(t->blob_size),
+                                le32toh(t->policy_hash_size),
+                                &tpm2_key,
+                                &tpm2_key_size);
+                if (r < 0)
+                        return r;
+
+                p += ALIGN8(offsetof(struct tpm2_credential_header, policy_hash_and_blob) +
+                            le32toh(t->blob_size) +
+                            le32toh(t->policy_hash_size));
+#else
+                return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP), "Credential requires TPM2 support, but TPM2 support not available.");
+#endif
+        }
+
+        if (with_host_key) {
+                r = get_credential_host_secret(
+                                0,
+                                &host_key,
+                                &host_key_size);
+                if (r < 0)
+                        return log_error_errno(r, "Failed to determine local credential key: %m");
+        }
+
+        sha256_hash_host_and_tpm2_key(host_key, host_key_size, tpm2_key, tpm2_key_size, md);
+
+        assert_se(cc = EVP_aes_256_gcm());
+
+        /* Make sure cipher expectations match the header */
+        if (EVP_CIPHER_key_length(cc) != (int) le32toh(h->key_size))
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Unexpected key size in header.");
+        if (EVP_CIPHER_block_size(cc) != (int) le32toh(h->block_size))
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Unexpected block size in header.");
+
+        context = EVP_CIPHER_CTX_new();
+        if (!context)
+                return log_error_errno(SYNTHETIC_ERRNO(ENOMEM), "Failed to allocate decryption object: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        if (EVP_DecryptInit_ex(context, cc, NULL, NULL, NULL) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to initialize decryption context: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        if (EVP_CIPHER_CTX_ctrl(context, EVP_CTRL_GCM_SET_IVLEN, le32toh(h->iv_size), NULL) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to set IV size on decryption context: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        if (EVP_DecryptInit_ex(context, NULL, NULL, md, h->iv) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to set IV and key: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        if (EVP_DecryptUpdate(context, NULL, &added, input, p) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to write AAD data: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        plaintext = malloc(input_size - p - le32toh(h->tag_size));
+        if (!plaintext)
+                return -ENOMEM;
+
+        if (EVP_DecryptUpdate(
+                            context,
+                            plaintext,
+                            &added,
+                            (uint8_t*) input + p,
+                            input_size - p - le32toh(h->tag_size)) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to decrypt data: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        assert(added >= 0);
+        assert((size_t) added <= input_size - p - le32toh(h->tag_size));
+        plaintext_size = added;
+
+        if (EVP_CIPHER_CTX_ctrl(context, EVP_CTRL_GCM_SET_TAG, le32toh(h->tag_size), (uint8_t*) input + input_size - le32toh(h->tag_size)) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to set tag: %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        if (EVP_DecryptFinal_ex(context, (uint8_t*) plaintext + plaintext_size, &added) != 1)
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Decryption failed (incorrect key?): %s",
+                                       ERR_error_string(ERR_get_error(), NULL));
+
+        plaintext_size += added;
+
+        if (plaintext_size < ALIGN8(offsetof(struct metadata_credential_header, name)))
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Metadata header incomplete.");
+
+        m = plaintext;
+
+        if (le64toh(m->timestamp) != USEC_INFINITY &&
+            le64toh(m->not_after) != USEC_INFINITY &&
+            le64toh(m->timestamp) >= le64toh(m->not_after))
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Timestamps of credential are not in order, refusing.");
+
+        if (le32toh(m->name_size) > CREDENTIAL_NAME_MAX)
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Embedded credential name too long, refusing.");
+
+        hs = ALIGN8(offsetof(struct metadata_credential_header, name) + le32toh(m->name_size));
+        if (plaintext_size < hs)
+                return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Metadata header incomplete.");
+
+        if (le32toh(m->name_size) > 0) {
+                _cleanup_free_ char *embedded_name = NULL;
+
+                if (memchr(m->name, 0, le32toh(m->name_size)))
+                        return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Embedded credential name contains NUL byte, refusing.");
+
+                embedded_name = memdup_suffix0(m->name, le32toh(m->name_size));
+                if (!embedded_name)
+                        return log_oom();
+
+                if (!credential_name_valid(embedded_name))
+                        return log_error_errno(SYNTHETIC_ERRNO(EBADMSG), "Embedded credential name is not valid, refusing.");
+
+                if (validate_name && !streq(embedded_name, validate_name)) {
+
+                        r = getenv_bool_secure("SYSTEMD_CREDENTIAL_VALIDATE_NAME");
+                        if (r < 0 && r != -ENXIO)
+                                log_debug_errno(r, "Failed to parse $SYSTEMD_CREDENTIAL_VALIDATE_NAME: %m");
+                        if (r != 0)
+                                return log_error_errno(SYNTHETIC_ERRNO(EREMOTE), "Embedded credential name '%s' does not match filename '%s', refusing.", embedded_name, validate_name);
+
+                        log_debug("Embedded credential name '%s' does not match expected name '%s', but configured to use credential anyway.", embedded_name, validate_name);
+                }
+        }
+
+        if (validate_timestamp != USEC_INFINITY) {
+                if (le64toh(m->timestamp) != USEC_INFINITY && le64toh(m->timestamp) > validate_timestamp)
+                        log_debug("Credential timestamp is from the future, assuming clock skew.");
+
+                if (le64toh(m->not_after) != USEC_INFINITY && le64toh(m->not_after) < validate_timestamp) {
+
+                        r = getenv_bool_secure("SYSTEMD_CREDENTIAL_VALIDATE_NOT_AFTER");
+                        if (r < 0 && r != -ENXIO)
+                                log_debug_errno(r, "Failed to parse $SYSTEMD_CREDENTIAL_VALIDATE_NOT_AFTER: %m");
+                        if (r != 0)
+                                return log_error_errno(SYNTHETIC_ERRNO(ESTALE), "Credential's time passed, refusing to use.");
+
+                        log_debug("Credential not-after timestamp has passed, but configured to use credential anyway.");
+                }
+        }
+
+        if (ret) {
+                char *without_metadata;
+
+                without_metadata = memdup((uint8_t*) plaintext + hs, plaintext_size - hs);
+                if (!without_metadata)
+                        return log_oom();
+
+                *ret = without_metadata;
+        }
+
+        if (ret_size)
+                *ret_size = plaintext_size - hs;
+
+        return 0;
+}
+
+#else
+
+int get_credential_host_secret(CredentialSecretFlags flags, void **ret, size_t *ret_size) {
+        return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP), "Support for encrypted credentials not available.");
+}
+
+int encrypt_credential_and_warn(sd_id128_t with_key, const char *name, usec_t timestamp, usec_t not_after, const char *tpm2_device, uint32_t tpm2_pcr_mask, const void *input, size_t input_size, void **ret, size_t *ret_size) {
+        return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP), "Support for encrypted credentials not available.");
+}
+
+int decrypt_credential_and_warn(const char *validate_name, usec_t validate_timestamp, const char *tpm2_device, const void *input, size_t input_size, void **ret, size_t *ret_size) {
+        return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP), "Support for encrypted credentials not available.");
+}
+
+#endif
diff -aruN old/src/shared/discover-image.c new/src/shared/discover-image.c
--- old/src/shared/discover-image.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/discover-image.c	2021-11-19 17:19:28.000000000 +0000
@@ -305,7 +305,7 @@
                 }
 
                 /* Get directory creation time (not available everywhere, but that's OK */
-                (void) fd_getcrtime(dfd, &crtime);
+                (void) fd_getcrtime(fd, &crtime);
 
                 /* If the IMMUTABLE bit is set, we consider the directory read-only. Since the ioctl is not
                  * supported everywhere we ignore failures. */
@@ -1208,6 +1208,7 @@
                                 DISSECT_IMAGE_GENERIC_ROOT |
                                 DISSECT_IMAGE_REQUIRE_ROOT |
                                 DISSECT_IMAGE_RELAX_VAR_CHECK |
+                                DISSECT_IMAGE_READ_ONLY |
                                 DISSECT_IMAGE_USR_NO_ROOT,
                                 &m);
                 if (r < 0)
diff -aruN old/src/shared/format-table.c new/src/shared/format-table.c
--- old/src/shared/format-table.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/format-table.c	2021-11-19 17:19:28.000000000 +0000
@@ -1409,7 +1409,7 @@
                 _cleanup_free_ char *p = NULL;
                 char *ret;
 
-                p = new(char, FORMAT_TIMESTAMP_MAX);
+                p = new(char, d->type == TABLE_TIMESTAMP_RELATIVE ? FORMAT_TIMESTAMP_RELATIVE_MAX : FORMAT_TIMESTAMP_MAX);
                 if (!p)
                         return NULL;
 
@@ -1418,7 +1418,7 @@
                 else if (d->type == TABLE_TIMESTAMP_UTC)
                         ret = format_timestamp_style(p, FORMAT_TIMESTAMP_MAX, d->timestamp, TIMESTAMP_UTC);
                 else
-                        ret = format_timestamp_relative(p, FORMAT_TIMESTAMP_MAX, d->timestamp);
+                        ret = format_timestamp_relative(p, FORMAT_TIMESTAMP_RELATIVE_MAX, d->timestamp);
                 if (!ret)
                         return "n/a";
 
diff -aruN old/src/shared/hostname-setup.c new/src/shared/hostname-setup.c
--- old/src/shared/hostname-setup.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/hostname-setup.c	2021-11-19 17:19:28.000000000 +0000
@@ -20,11 +20,11 @@
 #include "util.h"
 
 static int sethostname_idempotent_full(const char *s, bool really) {
-        char buf[HOST_NAME_MAX + 1] = {};
+        char buf[HOST_NAME_MAX + 1];
 
         assert(s);
 
-        if (gethostname(buf, sizeof(buf) - 1) < 0)
+        if (gethostname(buf, sizeof(buf)) < 0)
                 return -errno;
 
         if (streq(buf, s))
@@ -42,11 +42,11 @@
 }
 
 bool get_hostname_filtered(char ret[static HOST_NAME_MAX + 1]) {
-        char buf[HOST_NAME_MAX + 1] = {};
+        char buf[HOST_NAME_MAX + 1];
 
         /* Returns true if we got a good hostname, false otherwise. */
 
-        if (gethostname(buf, sizeof(buf) - 1) < 0)
+        if (gethostname(buf, sizeof(buf)) < 0)
                 return false;  /* This can realistically only fail with ENAMETOOLONG.
                                 * Let's treat that case the same as an invalid hostname. */
 
diff -aruN old/src/shared/json.c new/src/shared/json.c
--- old/src/shared/json.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/json.c	2021-11-19 17:19:28.000000000 +0000
@@ -359,6 +359,12 @@
         }
         REENABLE_WARNING;
 
+        /* JSON doesn't know NaN, +Infinity or -Infinity. Let's silently convert to 'null'. */
+        if (isnan(d) || isinf(d)) {
+                *ret = JSON_VARIANT_MAGIC_NULL;
+                return 0;
+        }
+
         r = json_variant_new(&v, JSON_VARIANT_REAL, sizeof(d));
         if (r < 0)
                 return r;
diff -aruN old/src/shared/libfido2-util.c new/src/shared/libfido2-util.c
--- old/src/shared/libfido2-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/libfido2-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -58,6 +58,7 @@
 int (*sym_fido_dev_make_cred)(fido_dev_t *, fido_cred_t *, const char *) = NULL;
 fido_dev_t* (*sym_fido_dev_new)(void) = NULL;
 int (*sym_fido_dev_open)(fido_dev_t *, const char *) = NULL;
+int (*sym_fido_dev_close)(fido_dev_t *) = NULL;
 const char* (*sym_fido_strerr)(int) = NULL;
 
 int dlopen_libfido2(void) {
@@ -106,6 +107,7 @@
                         DLSYM_ARG(fido_dev_make_cred),
                         DLSYM_ARG(fido_dev_new),
                         DLSYM_ARG(fido_dev_open),
+                        DLSYM_ARG(fido_dev_close),
                         DLSYM_ARG(fido_strerr));
 }
 
diff -aruN old/src/shared/libfido2-util.h new/src/shared/libfido2-util.h
--- old/src/shared/libfido2-util.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/libfido2-util.h	2021-11-19 17:19:28.000000000 +0000
@@ -60,6 +60,7 @@
 extern int (*sym_fido_dev_make_cred)(fido_dev_t *, fido_cred_t *, const char *);
 extern fido_dev_t* (*sym_fido_dev_new)(void);
 extern int (*sym_fido_dev_open)(fido_dev_t *, const char *);
+extern int (*sym_fido_dev_close)(fido_dev_t *);
 extern const char* (*sym_fido_strerr)(int);
 
 int dlopen_libfido2(void);
@@ -75,8 +76,10 @@
 }
 
 static inline void fido_dev_free_wrapper(fido_dev_t **p) {
-        if (*p)
+        if (*p) {
+                sym_fido_dev_close(*p);
                 sym_fido_dev_free(p);
+        }
 }
 
 static inline void fido_cred_free_wrapper(fido_cred_t **p) {
diff -aruN old/src/shared/nscd-flush.c new/src/shared/nscd-flush.c
--- old/src/shared/nscd-flush.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/nscd-flush.c	2021-11-19 17:19:28.000000000 +0000
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
-#include <sys/poll.h>
+#include <poll.h>
 
 #include "fd-util.h"
 #include "io-util.h"
diff -aruN old/src/shared/openssl-util.c new/src/shared/openssl-util.c
--- old/src/shared/openssl-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/openssl-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -46,7 +46,6 @@
                 size_t *ret_suitable_key_size) {
 
         size_t suitable_key_size;
-        const RSA *rsa;
         int bits;
 
         assert_se(pkey);
@@ -58,11 +57,7 @@
         if (EVP_PKEY_base_id(pkey) != EVP_PKEY_RSA)
                 return log_debug_errno(SYNTHETIC_ERRNO(EBADMSG), "X.509 certificate does not refer to RSA key.");
 
-        rsa = EVP_PKEY_get0_RSA(pkey);
-        if (!rsa)
-                return log_debug_errno(SYNTHETIC_ERRNO(EIO), "Failed to acquire RSA public key from X.509 certificate.");
-
-        bits = RSA_bits(rsa);
+        bits = EVP_PKEY_bits(pkey);
         log_debug("Bits in RSA key: %i", bits);
 
         /* We use PKCS#1 padding for the RSA cleartext, hence let's leave some extra space for it, hence only
diff -aruN old/src/shared/openssl-util.h new/src/shared/openssl-util.h
--- old/src/shared/openssl-util.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/openssl-util.h	2021-11-19 17:19:28.000000000 +0000
@@ -11,6 +11,7 @@
 DEFINE_TRIVIAL_CLEANUP_FUNC_FULL(X509_NAME*, X509_NAME_free, NULL);
 DEFINE_TRIVIAL_CLEANUP_FUNC_FULL(EVP_PKEY_CTX*, EVP_PKEY_CTX_free, NULL);
 DEFINE_TRIVIAL_CLEANUP_FUNC_FULL(EVP_CIPHER_CTX*, EVP_CIPHER_CTX_free, NULL);
+DEFINE_TRIVIAL_CLEANUP_FUNC_FULL(EVP_MD_CTX*, EVP_MD_CTX_free, NULL);
 
 int rsa_encrypt_bytes(EVP_PKEY *pkey, const void *decrypted_key, size_t decrypted_key_size, void **ret_encrypt_key, size_t *ret_encrypt_key_size);
 
diff -aruN old/src/shared/seccomp-util.c new/src/shared/seccomp-util.c
--- old/src/shared/seccomp-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/seccomp-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -310,6 +310,7 @@
                 "getpgrp\0"
                 "getpid\0"
                 "getppid\0"
+                "getrandom\0"
                 "getresgid\0"
                 "getresgid32\0"
                 "getresuid\0"
@@ -330,6 +331,7 @@
                 "restart_syscall\0"
                 "rseq\0"
                 "rt_sigreturn\0"
+                "sched_getaffinity\0"
                 "sched_yield\0"
                 "set_robust_list\0"
                 "set_thread_area\0"
@@ -858,7 +860,6 @@
                 "get_mempolicy\0"
                 "getcpu\0"
                 "getpriority\0"
-                "getrandom\0"
                 "ioctl\0"
                 "ioprio_get\0"
                 "kcmp\0"
@@ -874,7 +875,6 @@
                 "remap_file_pages\0"
                 "sched_get_priority_max\0"
                 "sched_get_priority_min\0"
-                "sched_getaffinity\0"
                 "sched_getattr\0"
                 "sched_getparam\0"
                 "sched_getscheduler\0"
@@ -1789,6 +1789,10 @@
         for (unsigned i = 0; seccomp_local_archs[i] != SECCOMP_LOCAL_ARCH_END; ++i) {
                 uint32_t arch = seccomp_local_archs[i];
 
+                /* See above comment, our "native" architecture is never blocked. */
+                if (arch == seccomp_arch_native())
+                        continue;
+
                 /* That architecture might have already been blocked by a previous call to seccomp_restrict_archs. */
                 if (arch == SECCOMP_LOCAL_ARCH_BLOCKED)
                         continue;
diff -aruN old/src/shared/sleep-config.c new/src/shared/sleep-config.c
--- old/src/shared/sleep-config.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/sleep-config.c	2021-11-19 17:19:28.000000000 +0000
@@ -392,15 +392,17 @@
                 }
 
                 /* prefer resume device or highest priority swap with most remaining space */
-                if (hibernate_location && swap->priority < hibernate_location->swap->priority) {
-                        log_debug("%s: ignoring device with lower priority", swap->device);
-                        continue;
-                }
-                if (hibernate_location &&
-                    (swap->priority == hibernate_location->swap->priority
-                     && swap->size - swap->used < hibernate_location->swap->size - hibernate_location->swap->used)) {
-                        log_debug("%s: ignoring device with lower usable space", swap->device);
-                        continue;
+                if (sys_resume == 0) {
+                        if (hibernate_location && swap->priority < hibernate_location->swap->priority) {
+                                log_debug("%s: ignoring device with lower priority", swap->device);
+                                continue;
+                        }
+                        if (hibernate_location &&
+                            (swap->priority == hibernate_location->swap->priority
+                             && swap->size - swap->used < hibernate_location->swap->size - hibernate_location->swap->used)) {
+                                log_debug("%s: ignoring device with lower usable space", swap->device);
+                                continue;
+                        }
                 }
 
                 dev_t swap_device;
diff -aruN old/src/shared/tpm2-util.c new/src/shared/tpm2-util.c
--- old/src/shared/tpm2-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/tpm2-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -182,7 +182,7 @@
                 if (!tcti)
                         return log_oom();
 
-                rc = info->init(tcti, &sz, device);
+                rc = info->init(tcti, &sz, param);
                 if (rc != TPM2_RC_SUCCESS)
                         return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
                                                "Failed to initialize TCTI context: %s", sym_Tss2_RC_Decode(rc));
diff -aruN old/src/shared/user-record.c new/src/shared/user-record.c
--- old/src/shared/user-record.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/user-record.c	2021-11-19 17:19:28.000000000 +0000
@@ -1913,9 +1913,9 @@
         assert(h);
 
         /* Returns a value with kb granularity, since that's what libcryptsetup expects */
-
         if (h->luks_pbkdf_memory_cost == UINT64_MAX)
-                return 64*1024*1024; /* We default to 64M, since this should work on smaller systems too */
+                return streq(user_record_luks_pbkdf_type(h), "pbkdf2") ? 0 : /* doesn't apply for simple pbkdf2 */
+                        64*1024*1024; /* We default to 64M, since this should work on smaller systems too */
 
         return MIN(DIV_ROUND_UP(h->luks_pbkdf_memory_cost, 1024), UINT32_MAX) * 1024;
 }
@@ -1923,8 +1923,9 @@
 uint64_t user_record_luks_pbkdf_parallel_threads(UserRecord *h) {
         assert(h);
 
-        if (h->luks_pbkdf_memory_cost == UINT64_MAX)
-                return 1; /* We default to 1, since this should work on smaller systems too */
+        if (h->luks_pbkdf_parallel_threads == UINT64_MAX)
+                return streq(user_record_luks_pbkdf_type(h), "pbkdf2") ? 0 : /* doesn't apply for simple pbkdf2 */
+                        1; /* We default to 1, since this should work on smaller systems too */
 
         return MIN(h->luks_pbkdf_parallel_threads, UINT32_MAX);
 }
diff -aruN old/src/shared/user-record-show.c new/src/shared/user-record-show.c
--- old/src/shared/user-record-show.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/user-record-show.c	2021-11-19 17:19:28.000000000 +0000
@@ -280,7 +280,7 @@
                 printf("   IO Weight: %" PRIu64 "\n", hr->io_weight);
 
         if (hr->access_mode != MODE_INVALID)
-                printf(" Access Mode: 0%03oo\n", user_record_access_mode(hr));
+                printf(" Access Mode: 0%03o\n", user_record_access_mode(hr));
 
         if (storage == USER_LUKS) {
                 printf("LUKS Discard: online=%s offline=%s\n", yes_no(user_record_luks_discard(hr)), yes_no(user_record_luks_offline_discard(hr)));
diff -aruN old/src/shared/utmp-wtmp.c new/src/shared/utmp-wtmp.c
--- old/src/shared/utmp-wtmp.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/utmp-wtmp.c	2021-11-19 17:19:28.000000000 +0000
@@ -215,13 +215,14 @@
 }
 
 int utmp_put_dead_process(const char *id, pid_t pid, int code, int status) {
+        _cleanup_(utxent_cleanup) bool utmpx = false;
         struct utmpx lookup = {
                 .ut_type = INIT_PROCESS /* looks for DEAD_PROCESS, LOGIN_PROCESS, USER_PROCESS, too */
         }, store, store_wtmp, *found;
 
         assert(id);
 
-        setutxent();
+        utmpx = utxent_start();
 
         /* Copy the whole string if it fits, or just the suffix without the terminating NUL. */
         copy_suffix(store.ut_id, sizeof(store.ut_id), id);
@@ -339,6 +340,7 @@
         bool (*match_tty)(const char *tty, void *userdata),
         void *userdata) {
 
+        _cleanup_(utxent_cleanup) bool utmpx = false;
         _cleanup_free_ char *text = NULL, *hn = NULL, *un = NULL, *stdin_tty = NULL;
         char date[FORMAT_TIMESTAMP_MAX];
         struct utmpx *u;
@@ -368,7 +370,7 @@
                      message) < 0)
                 return -ENOMEM;
 
-        setutxent();
+        utmpx = utxent_start();
 
         r = 0;
 
diff -aruN old/src/shared/varlink.c new/src/shared/varlink.c
--- old/src/shared/varlink.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/varlink.c	2021-11-19 17:19:28.000000000 +0000
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
 #include <malloc.h>
-#include <sys/poll.h>
+#include <poll.h>
 
 #include "alloc-util.h"
 #include "errno-util.h"
@@ -417,9 +417,10 @@
         if (IN_SET(v->state, VARLINK_IDLE_CLIENT) && (v->write_disconnected || v->got_pollhup))
                 goto disconnect;
 
-        /* The server is still expecting to write more, but its write end is disconnected and it got a POLLHUP
-         * (i.e. from a disconnected client), so disconnect. */
-        if (IN_SET(v->state, VARLINK_PENDING_METHOD, VARLINK_PENDING_METHOD_MORE) && v->write_disconnected && v->got_pollhup)
+        /* We are on the server side and still want to send out more replies, but we saw POLLHUP already, and
+         * either got no buffered bytes to write anymore or already saw a write error. In that case we should
+         * shut down the varlink link. */
+        if (IN_SET(v->state, VARLINK_PENDING_METHOD, VARLINK_PENDING_METHOD_MORE) && (v->write_disconnected || v->output_buffer_size == 0) && v->got_pollhup)
                 goto disconnect;
 
         return 0;
@@ -2363,14 +2364,8 @@
 
         assert_return(s, -EINVAL);
 
-        LIST_FOREACH(sockets, ss, s->sockets) {
-
-                if (!ss->event_source)
-                        continue;
-
-                (void) sd_event_source_set_enabled(ss->event_source, SD_EVENT_OFF);
-                ss->event_source = sd_event_source_unref(ss->event_source);
-        }
+        LIST_FOREACH(sockets, ss, s->sockets)
+                ss->event_source = sd_event_source_disable_unref(ss->event_source);
 
         sd_event_unref(s->event);
         return 0;
diff -aruN old/src/shared/watchdog.c new/src/shared/watchdog.c
--- old/src/shared/watchdog.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shared/watchdog.c	2021-11-19 17:19:28.000000000 +0000
@@ -47,8 +47,8 @@
                 flags = WDIOS_ENABLECARD;
                 if (ioctl(watchdog_fd, WDIOC_SETOPTIONS, &flags) < 0) {
                         /* ENOTTY means the watchdog is always enabled so we're fine */
-                        log_full(ERRNO_IS_NOT_SUPPORTED(errno) ? LOG_DEBUG : LOG_WARNING,
-                                 "Failed to enable hardware watchdog: %m");
+                        log_full_errno(ERRNO_IS_NOT_SUPPORTED(errno) ? LOG_DEBUG : LOG_WARNING, errno,
+                                       "Failed to enable hardware watchdog, ignoring: %m");
                         if (!ERRNO_IS_NOT_SUPPORTED(errno))
                                 return -errno;
                 }
diff -aruN old/src/shutdown/umount.c new/src/shutdown/umount.c
--- old/src/shutdown/umount.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/shutdown/umount.c	2021-11-19 17:19:28.000000000 +0000
@@ -15,6 +15,10 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#if HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
 #include "sd-device.h"
 
 #include "alloc-util.h"
@@ -409,6 +413,10 @@
                         return -EBUSY; /* propagate original error */
                 }
 
+#if HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&info, sizeof(info));
+#endif
+
                 if (FLAGS_SET(info.lo_flags, LO_FLAGS_AUTOCLEAR)) /* someone else already set LO_FLAGS_AUTOCLEAR for us? fine by us */
                         return -EBUSY; /* propagate original error */
 
@@ -434,6 +442,10 @@
                 return 1;
         }
 
+#if HAVE_VALGRIND_MEMCHECK_H
+        VALGRIND_MAKE_MEM_DEFINED(&info, sizeof(info));
+#endif
+
         /* Linux makes LOOP_CLR_FD succeed whenever LO_FLAGS_AUTOCLEAR is set without actually doing
          * anything. Very confusing. Let's hence not claim we did anything in this case. */
         if (FLAGS_SET(info.lo_flags, LO_FLAGS_AUTOCLEAR))
diff -aruN old/src/systemctl/systemctl.c new/src/systemctl/systemctl.c
--- old/src/systemctl/systemctl.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/systemctl/systemctl.c	2021-11-19 17:19:28.000000000 +0000
@@ -925,6 +925,11 @@
                         assert_not_reached("Unhandled option");
                 }
 
+        /* If we are in --user mode, there's no point in talking to PolicyKit or the infra to query system
+         * passwords */
+        if (arg_scope != UNIT_FILE_SYSTEM)
+                arg_ask_password = false;
+
         if (arg_transport == BUS_TRANSPORT_REMOTE && arg_scope != UNIT_FILE_SYSTEM)
                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                        "Cannot access user instance remotely.");
diff -aruN old/src/systemctl/systemctl-set-property.c new/src/systemctl/systemctl-set-property.c
--- old/src/systemctl/systemctl-set-property.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/systemctl/systemctl-set-property.c	2021-11-19 17:19:28.000000000 +0000
@@ -6,33 +6,20 @@
 #include "systemctl-util.h"
 #include "systemctl.h"
 
-int set_property(int argc, char *argv[], void *userdata) {
-        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;
+static int set_property_one(sd_bus *bus, const char *name, char **properties) {
         _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;
-        _cleanup_free_ char *n = NULL;
-        UnitType t;
-        sd_bus *bus;
+        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;
         int r;
 
-        r = acquire_bus(BUS_MANAGER, &bus);
-        if (r < 0)
-                return r;
-
-        polkit_agent_open_maybe();
-
         r = bus_message_new_method_call(bus, &m, bus_systemd_mgr, "SetUnitProperties");
         if (r < 0)
                 return bus_log_create_error(r);
 
-        r = unit_name_mangle(argv[1], arg_quiet ? 0 : UNIT_NAME_MANGLE_WARN, &n);
-        if (r < 0)
-                return log_error_errno(r, "Failed to mangle unit name: %m");
-
-        t = unit_name_to_type(n);
+        UnitType t = unit_name_to_type(name);
         if (t < 0)
-                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Invalid unit type: %s", n);
+                return log_error_errno(t, "Invalid unit type: %s", name);
 
-        r = sd_bus_message_append(m, "sb", n, arg_runtime);
+        r = sd_bus_message_append(m, "sb", name, arg_runtime);
         if (r < 0)
                 return bus_log_create_error(r);
 
@@ -40,7 +27,7 @@
         if (r < 0)
                 return bus_log_create_error(r);
 
-        r = bus_append_unit_property_assignment_many(m, t, strv_skip(argv, 2));
+        r = bus_append_unit_property_assignment_many(m, t, properties);
         if (r < 0)
                 return r;
 
@@ -50,7 +37,33 @@
 
         r = sd_bus_call(bus, m, 0, &error, NULL);
         if (r < 0)
-                return log_error_errno(r, "Failed to set unit properties on %s: %s", n, bus_error_message(&error, r));
+                return log_error_errno(r, "Failed to set unit properties on %s: %s",
+                                       name, bus_error_message(&error, r));
 
         return 0;
 }
+
+int set_property(int argc, char *argv[], void *userdata) {
+        sd_bus *bus;
+        _cleanup_strv_free_ char **names = NULL;
+        char **name;
+        int r, k;
+
+        r = acquire_bus(BUS_MANAGER, &bus);
+        if (r < 0)
+                return r;
+
+        polkit_agent_open_maybe();
+
+        r = expand_unit_names(bus, STRV_MAKE(argv[1]), NULL, &names, NULL);
+        if (r < 0)
+                return log_error_errno(r, "Failed to expand '%s' into names: %m", argv[1]);
+
+        r = 0;
+        STRV_FOREACH(name, names) {
+                k = set_property_one(bus, *name, strv_skip(argv, 2));
+                if (k < 0 && r >= 0)
+                        r = k;
+        }
+        return r;
+}
diff -aruN old/src/systemctl/systemctl-show.c new/src/systemctl/systemctl-show.c
--- old/src/systemctl/systemctl-show.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/systemctl/systemctl-show.c	2021-11-19 17:19:28.000000000 +0000
@@ -741,7 +741,7 @@
                         c = 0;
 
                 r = unit_show_processes(bus, i->id, i->control_group, prefix, c, get_output_flags(), &error);
-                if (r == -EBADR) {
+                if (r == -EBADR && arg_transport == BUS_TRANSPORT_LOCAL) {
                         unsigned k = 0;
                         pid_t extra[2];
 
@@ -1649,11 +1649,13 @@
 
                                 r = sd_bus_message_enter_container(m, 'r', "ssba(ss)");
                                 if (r < 0)
-                                        return r;
+                                        return bus_log_parse_error(r);
+                                if (r == 0)
+                                        break;
 
                                 r = sd_bus_message_read(m, "ssb", &source, &destination, &ignore_enoent);
-                                if (r <= 0)
-                                        break;
+                                if (r < 0)
+                                        return bus_log_parse_error(r);
 
                                 str = strjoin(ignore_enoent ? "-" : "",
                                               source,
@@ -1664,28 +1666,82 @@
 
                                 r = sd_bus_message_enter_container(m, 'a', "(ss)");
                                 if (r < 0)
-                                        return r;
+                                        return bus_log_parse_error(r);
 
                                 while ((r = sd_bus_message_read(m, "(ss)", &partition, &mount_options)) > 0)
-                                        if (!strextend_with_separator(&str, ":", partition, ":", mount_options))
+                                        if (!strextend_with_separator(&str, ":", partition, mount_options))
                                                 return log_oom();
                                 if (r < 0)
-                                        return r;
+                                        return bus_log_parse_error(r);
 
                                 if (!strextend_with_separator(&paths, " ", str))
                                         return log_oom();
 
                                 r = sd_bus_message_exit_container(m);
                                 if (r < 0)
-                                        return r;
+                                        return bus_log_parse_error(r);
 
                                 r = sd_bus_message_exit_container(m);
                                 if (r < 0)
-                                        return r;
+                                        return bus_log_parse_error(r);
                         }
+
+                        r = sd_bus_message_exit_container(m);
                         if (r < 0)
                                 return bus_log_parse_error(r);
 
+                        bus_print_property_value(name, expected_value, flags, paths);
+
+                        return 1;
+
+                } else if (streq(name, "ExtensionImages")) {
+                        _cleanup_free_ char *paths = NULL;
+
+                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, "(sba(ss))");
+                        if (r < 0)
+                                return bus_log_parse_error(r);
+
+                        for (;;) {
+                                _cleanup_free_ char *str = NULL;
+                                const char *source, *partition, *mount_options;
+                                int ignore_enoent;
+
+                                r = sd_bus_message_enter_container(m, 'r', "sba(ss)");
+                                if (r < 0)
+                                        return bus_log_parse_error(r);
+                                if (r == 0)
+                                        break;
+
+                                r = sd_bus_message_read(m, "sb", &source, &ignore_enoent);
+                                if (r < 0)
+                                        return bus_log_parse_error(r);
+
+                                str = strjoin(ignore_enoent ? "-" : "", source);
+                                if (!str)
+                                        return log_oom();
+
+                                r = sd_bus_message_enter_container(m, 'a', "(ss)");
+                                if (r < 0)
+                                        return bus_log_parse_error(r);
+
+                                while ((r = sd_bus_message_read(m, "(ss)", &partition, &mount_options)) > 0)
+                                        if (!strextend_with_separator(&str, ":", partition, mount_options))
+                                                return log_oom();
+                                if (r < 0)
+                                        return bus_log_parse_error(r);
+
+                                if (!strextend_with_separator(&paths, " ", str))
+                                        return log_oom();
+
+                                r = sd_bus_message_exit_container(m);
+                                if (r < 0)
+                                        return bus_log_parse_error(r);
+
+                                r = sd_bus_message_exit_container(m);
+                                if (r < 0)
+                                        return bus_log_parse_error(r);
+                        }
+
                         r = sd_bus_message_exit_container(m);
                         if (r < 0)
                                 return bus_log_parse_error(r);
@@ -1915,7 +1971,7 @@
                 return log_error_errno(r, "Failed to get properties: %s", bus_error_message(&error, r));
 
         if (unit && streq_ptr(info.load_state, "not-found") && streq_ptr(info.active_state, "inactive")) {
-                log_full(show_mode == SYSTEMCTL_SHOW_STATUS ? LOG_ERR : LOG_DEBUG,
+                log_full(show_mode == SYSTEMCTL_SHOW_PROPERTIES ? LOG_DEBUG : LOG_ERR,
                          "Unit %s could not be found.", unit);
 
                 if (show_mode == SYSTEMCTL_SHOW_STATUS)
diff -aruN old/src/systemctl/systemctl-start-special.c new/src/systemctl/systemctl-start-special.c
--- old/src/systemctl/systemctl-start-special.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/systemctl/systemctl-start-special.c	2021-11-19 17:19:28.000000000 +0000
@@ -36,7 +36,7 @@
                 return log_error_errno(r,
                                        "No kexec kernel loaded and autodetection failed.\n%s",
                                        is_efi_boot()
-                                       ? "Cannot automatically load kernel: ESP partition mount point not found."
+                                       ? "Cannot automatically load kernel: ESP mount point not found."
                                        : "Automatic loading works only on systems booted with EFI.");
         if (r < 0)
                 return r;
diff -aruN old/src/systemd/sd-bus-vtable.h new/src/systemd/sd-bus-vtable.h
--- old/src/systemd/sd-bus-vtable.h	2021-07-07 18:41:29.000000000 +0100
+++ new/src/systemd/sd-bus-vtable.h	2021-11-19 17:19:28.000000000 +0000
@@ -76,6 +76,9 @@
                         const unsigned *vtable_format_reference;
                 } start;
                 struct {
+                        size_t reserved;
+                } end;
+                struct {
                         const char *member;
                         const char *signature;
                         const char *result;
@@ -185,7 +188,11 @@
         {                                                               \
                 .type = _SD_BUS_VTABLE_END,                             \
                 .flags = 0,                                             \
-                .x = { { 0 } },                                         \
+                .x = {                                                  \
+                    .end = {                                            \
+                        .reserved = 0,                                  \
+                    },                                                  \
+                },                                                      \
         }
 
 #define _SD_ECHO(X) X
diff -aruN old/src/test/meson.build new/src/test/meson.build
--- old/src/test/meson.build	2021-07-07 18:41:29.000000000 +0100
+++ new/src/test/meson.build	2021-11-19 17:19:28.000000000 +0000
@@ -13,7 +13,6 @@
 
 path = run_command(sh, '-c', 'echo "$PATH"').stdout().strip()
 test_env = environment()
-test_env.set('SYSTEMD_KBD_MODEL_MAP', kbd_model_map)
 test_env.set('SYSTEMD_LANGUAGE_FALLBACK_MAP', language_fallback_map)
 test_env.set('PATH', '@0@:@1@'.format(meson.build_root(), path))
 
diff -aruN old/src/test/test-env-util.c new/src/test/test-env-util.c
--- old/src/test/test-env-util.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/test/test-env-util.c	2021-11-19 17:19:28.000000000 +0000
@@ -198,7 +198,7 @@
                 "BAR=bar",
                 NULL
         };
-        _cleanup_free_ char *t = NULL, *s = NULL, *q = NULL, *r = NULL, *p = NULL, *x = NULL;
+        _cleanup_free_ char *t = NULL, *s = NULL, *q = NULL, *r = NULL, *p = NULL, *x = NULL, *y = NULL;
         unsigned flags = REPLACE_ENV_ALLOW_EXTENDED*extended;
 
         t = replace_env("FOO=${FOO:-${BAR}}", (char**) env, flags);
@@ -218,6 +218,9 @@
 
         x = replace_env("XXX=${XXX:+${BAR}post}", (char**) env, flags);
         assert_se(streq(x, extended ? "XXX=" : "XXX=${XXX:+barpost}"));
+
+        y = replace_env("FOO=${FOO}between${BAR:-baz}", (char**) env, flags);
+        assert_se(streq(y, extended ? "FOO=foobetweenbar" : "FOO=foobetween${BAR:-baz}"));
 }
 
 static void test_replace_env_argv(void) {
diff -aruN old/src/test/test-execute.c new/src/test/test-execute.c
--- old/src/test/test-execute.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/test/test-execute.c	2021-11-19 17:19:28.000000000 +0000
@@ -432,8 +432,10 @@
 
         test(m, "exec-systemcallfilter-not-failing.service", 0, CLD_EXITED);
         test(m, "exec-systemcallfilter-not-failing2.service", 0, CLD_EXITED);
+        test(m, "exec-systemcallfilter-not-failing3.service", 0, CLD_EXITED);
         test(m, "exec-systemcallfilter-failing.service", SIGSYS, CLD_KILLED);
         test(m, "exec-systemcallfilter-failing2.service", SIGSYS, CLD_KILLED);
+        test(m, "exec-systemcallfilter-failing3.service", SIGSYS, CLD_KILLED);
 
         r = find_executable("python3", NULL);
         if (r < 0) {
diff -aruN old/src/test/test-fileio.c new/src/test/test-fileio.c
--- old/src/test/test-fileio.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/test/test-fileio.c	2021-11-19 17:19:28.000000000 +0000
@@ -1028,7 +1028,11 @@
         FOREACH_STRING(filename,
                        "/proc/1/cmdline",
                        "/etc/nsswitch.conf",
-                       "/sys/kernel/uevent_seqnum") {
+                       "/sys/kernel/uevent_seqnum",
+                       "/proc/kcore",
+                       "/proc/kallsyms",
+                       "/proc/self/exe",
+                       "/proc/self/pagemap") {
 
                 _cleanup_free_ char *buf = NULL;
                 size_t size = 0;
@@ -1036,7 +1040,11 @@
                 r = read_virtual_file(filename, max_size, &buf, &size);
                 if (r < 0) {
                         log_info_errno(r, "read_virtual_file(\"%s\", %zu): %m", filename, max_size);
-                        assert_se(ERRNO_IS_PRIVILEGE(r) || r == -ENOENT);
+                        assert_se(ERRNO_IS_PRIVILEGE(r) || /* /proc/kcore is not accessible to unpriv */
+                                  IN_SET(r,
+                                         -ENOENT,  /* Some of the files might be absent */
+                                         -EINVAL,  /* too small reads from /proc/self/pagemap trigger EINVAL */
+                                         -EFBIG)); /* /proc/kcore and /proc/self/pagemap should be too large */
                 } else
                         log_info("read_virtual_file(\"%s\", %zu): %s (%zu bytes)", filename, max_size, r ? "non-truncated" : "truncated", size);
         }
diff -aruN old/src/test/test-path.c new/src/test/test-path.c
--- old/src/test/test-path.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/test/test-path.c	2021-11-19 17:19:28.000000000 +0000
@@ -306,7 +306,7 @@
 }
 
 static void test_path_directorynotempty(Manager *m) {
-        const char *test_path = "/tmp/test-path_directorynotempty/";
+        const char *test_file, *test_path = "/tmp/test-path_directorynotempty/";
         Unit *unit = NULL;
         Path *path = NULL;
         Service *service = NULL;
@@ -328,7 +328,8 @@
         assert_se(access(test_path, F_OK) < 0);
 
         assert_se(mkdir_p(test_path, 0755) >= 0);
-        assert_se(touch(strjoina(test_path, "test_file")) >= 0);
+        test_file = strjoina(test_path, "test_file");
+        assert_se(touch(test_file) >= 0);
         if (check_states(m, path, service, PATH_RUNNING, SERVICE_RUNNING) < 0)
                 return;
 
diff -aruN old/src/test/test-seccomp.c new/src/test/test-seccomp.c
--- old/src/test/test-seccomp.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/test/test-seccomp.c	2021-11-19 17:19:28.000000000 +0000
@@ -890,6 +890,66 @@
         assert_se(wait_for_terminate_and_check("syscallrawseccomp", pid, WAIT_LOG) == EXIT_SUCCESS);
 }
 
+static void test_native_syscalls_filtered(void) {
+        pid_t pid;
+
+        log_info("/* %s */", __func__);
+
+        if (!is_seccomp_available()) {
+                log_notice("Seccomp not available, skipping %s", __func__);
+                return;
+        }
+        if (!have_seccomp_privs()) {
+                log_notice("Not privileged, skipping %s", __func__);
+                return;
+        }
+
+        pid = fork();
+        assert_se(pid >= 0);
+
+        if (pid == 0) {
+                _cleanup_set_free_ Set *arch_s = NULL;
+                _cleanup_hashmap_free_ Hashmap *s = NULL;
+
+                /* Passing "native" or an empty set is equivalent, just do both here. */
+                assert_se(arch_s = set_new(NULL));
+                assert_se(seccomp_restrict_archs(arch_s) >= 0);
+                assert_se(set_put(arch_s, SCMP_ARCH_NATIVE) >= 0);
+                assert_se(seccomp_restrict_archs(arch_s) >= 0);
+
+                assert_se(access("/", F_OK) >= 0);
+                assert_se(poll(NULL, 0, 0) == 0);
+
+                assert_se(seccomp_load_syscall_filter_set_raw(SCMP_ACT_ALLOW, NULL, scmp_act_kill_process(), true) >= 0);
+                assert_se(access("/", F_OK) >= 0);
+                assert_se(poll(NULL, 0, 0) == 0);
+
+                assert_se(s = hashmap_new(NULL));
+#if defined __NR_access && __NR_access >= 0
+                assert_se(hashmap_put(s, UINT32_TO_PTR(__NR_access + 1), INT_TO_PTR(-1)) >= 0);
+                log_debug("has access()");
+#endif
+#if defined __NR_faccessat && __NR_faccessat >= 0
+                assert_se(hashmap_put(s, UINT32_TO_PTR(__NR_faccessat + 1), INT_TO_PTR(-1)) >= 0);
+                log_debug("has faccessat()");
+#endif
+#if defined __NR_faccessat2 && __NR_faccessat2 >= 0
+                assert_se(hashmap_put(s, UINT32_TO_PTR(__NR_faccessat2 + 1), INT_TO_PTR(-1)) >= 0);
+                log_debug("has faccessat2()");
+#endif
+
+                assert_se(!hashmap_isempty(s));
+                assert_se(seccomp_load_syscall_filter_set_raw(SCMP_ACT_ALLOW, s, SCMP_ACT_ERRNO(EUCLEAN), true) >= 0);
+
+                assert_se(access("/", F_OK) < 0);
+                assert_se(errno == EUCLEAN);
+
+                _exit(EXIT_SUCCESS);
+        }
+
+        assert_se(wait_for_terminate_and_check("nativeseccomp", pid, WAIT_LOG) == EXIT_SUCCESS);
+}
+
 static void test_lock_personality(void) {
         unsigned long current;
         pid_t pid;
@@ -1171,6 +1231,7 @@
         test_memory_deny_write_execute_shmat();
         test_restrict_archs();
         test_load_syscall_filter_set_raw();
+        test_native_syscalls_filtered();
         test_lock_personality();
         test_restrict_suid_sgid();
 
diff -aruN old/src/test/test-sizeof.c new/src/test/test-sizeof.c
--- old/src/test/test-sizeof.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/test/test-sizeof.c	2021-11-19 17:19:28.000000000 +0000
@@ -89,5 +89,7 @@
         printf("big_enum2_pos → %zu\n", sizeof(big_enum2_pos));
         printf("big_enum2_neg → %zu\n", sizeof(big_enum2_neg));
 
+        printf("timeval: %zu\n", sizeof(struct timeval));
+        printf("timespec: %zu\n", sizeof(struct timespec));
         return 0;
 }
diff -aruN old/src/timesync/timesyncd-manager.c new/src/timesync/timesyncd-manager.c
--- old/src/timesync/timesyncd-manager.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/timesync/timesyncd-manager.c	2021-11-19 17:19:28.000000000 +0000
@@ -412,7 +412,8 @@
                 .iov_base = &ntpmsg,
                 .iov_len = sizeof(ntpmsg),
         };
-        CMSG_BUFFER_TYPE(CMSG_SPACE(sizeof(struct timeval))) control;
+        /* This needs to be initialized with zero. See #20741. */
+        CMSG_BUFFER_TYPE(CMSG_SPACE_TIMESPEC) control = {};
         union sockaddr_union server_addr;
         struct msghdr msghdr = {
                 .msg_iov = &iov,
@@ -467,6 +468,8 @@
 
                 switch (cmsg->cmsg_type) {
                 case SCM_TIMESTAMPNS:
+                        assert(cmsg->cmsg_len == CMSG_LEN(sizeof(struct timespec)));
+
                         recv_time = (struct timespec *) CMSG_DATA(cmsg);
                         break;
                 }
diff -aruN old/src/udev/dmi_memory_id/dmi_memory_id.c new/src/udev/dmi_memory_id/dmi_memory_id.c
--- old/src/udev/dmi_memory_id/dmi_memory_id.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/udev/dmi_memory_id/dmi_memory_id.c	2021-11-19 17:19:28.000000000 +0000
@@ -539,7 +539,7 @@
 
                 /* If a short entry is found (less than 4 bytes), not only it
                  * is invalid, but we cannot reliably locate the next entry.
-                 * Better stop at this point, and let the user know his/her
+                 * Better stop at this point, and let the user know their
                  * table is broken. */
                 if (h.length < 4)
                         break;
diff -aruN old/src/udev/udev-builtin-net_id.c new/src/udev/udev-builtin-net_id.c
--- old/src/udev/udev-builtin-net_id.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/udev/udev-builtin-net_id.c	2021-11-19 17:19:28.000000000 +0000
@@ -103,7 +103,6 @@
         _cleanup_(sd_device_unrefp) sd_device *physfn_pcidev = NULL;
         const char *physfn_link_file, *syspath;
         _cleanup_free_ char *physfn_pci_syspath = NULL;
-        _cleanup_free_ char *virtfn_pci_syspath = NULL;
         struct dirent *dent;
         _cleanup_closedir_ DIR *dir = NULL;
         char suffix[ALTIFNAMSIZ];
@@ -134,7 +133,7 @@
                 return -errno;
 
         FOREACH_DIRENT_ALL(dent, dir, break) {
-                _cleanup_free_ char *virtfn_link_file = NULL;
+                _cleanup_free_ char *virtfn_link_file = NULL, *virtfn_pci_syspath = NULL;
 
                 if (!startswith(dent->d_name, "virtfn"))
                         continue;
diff -aruN old/src/udev/udev-builtin-net_setup_link.c new/src/udev/udev-builtin-net_setup_link.c
--- old/src/udev/udev-builtin-net_setup_link.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/udev/udev-builtin-net_setup_link.c	2021-11-19 17:19:28.000000000 +0000
@@ -28,10 +28,12 @@
 
         r = link_config_get(ctx, dev, &link);
         if (r < 0) {
-                if (r == -ENOENT)
-                        return log_device_debug_errno(dev, r, "No matching link configuration found.");
                 if (r == -ENODEV)
                         return log_device_debug_errno(dev, r, "Link vanished while searching for configuration for it.");
+                if (r == -ENOENT) {
+                        log_device_debug_errno(dev, r, "No matching link configuration found, ignoring device.");
+                        return 0;
+                }
 
                 return log_device_error_errno(dev, r, "Failed to get link config: %m");
         }
diff -aruN old/src/udev/udev-event.c new/src/udev/udev-event.c
--- old/src/udev/udev-event.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/udev/udev-event.c	2021-11-19 17:19:28.000000000 +0000
@@ -828,6 +828,7 @@
 static int rename_netif(UdevEvent *event) {
         sd_device *dev = event->dev;
         const char *oldname;
+        unsigned flags;
         int ifindex, r;
 
         if (!event->name)
@@ -855,6 +856,16 @@
                 return 0;
         }
 
+        r = rtnl_get_link_info(&event->rtnl, ifindex, NULL, &flags);
+        if (r < 0)
+                return log_device_warning_errno(dev, r, "Failed to get link flags: %m");
+
+        if (FLAGS_SET(flags, IFF_UP)) {
+                log_device_info(dev, "Network interface '%s' is already up, refusing to rename to '%s'.",
+                                oldname, event->name);
+                return 0;
+        }
+
         /* Set ID_RENAMING boolean property here, and drop it in the corresponding move uevent later. */
         r = device_add_property(dev, "ID_RENAMING", "1");
         if (r < 0)
diff -aruN old/src/userdb/userdbctl.c new/src/userdb/userdbctl.c
--- old/src/userdb/userdbctl.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/userdb/userdbctl.c	2021-11-19 17:19:28.000000000 +0000
@@ -512,7 +512,7 @@
                 if (fd < 0)
                         return log_error_errno(r, "Failed to allocate AF_UNIX/SOCK_STREAM socket: %m");
 
-                if (connect(fd, &sockaddr.un, sockaddr_len) < 0) {
+                if (connect(fd, &sockaddr.sa, sockaddr_len) < 0) {
                         no = strjoin("No (", errno_to_name(errno), ")");
                         if (!no)
                                 return log_oom();
diff -aruN old/src/veritysetup/veritysetup.c new/src/veritysetup/veritysetup.c
--- old/src/veritysetup/veritysetup.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/veritysetup/veritysetup.c	2021-11-19 17:19:28.000000000 +0000
@@ -30,7 +30,7 @@
 
         printf("%s attach VOLUME DATADEVICE HASHDEVICE ROOTHASH [OPTIONS]\n"
                "%s detach VOLUME\n\n"
-               "Attaches or detaches an integrity protected block device.\n"
+               "Attach or detach a verity protected block device.\n"
                "\nSee the %s for details.\n",
                program_invocation_short_name,
                program_invocation_short_name,
@@ -130,7 +130,10 @@
         _cleanup_(crypt_freep) struct crypt_device *cd = NULL;
         int r;
 
-        if (argc <= 1)
+        if (argc <= 1 ||
+            strv_contains(strv_skip(argv, 1), "--help") ||
+            strv_contains(strv_skip(argv, 1), "-h") ||
+            streq(argv[1], "help"))
                 return help();
 
         if (argc < 3)
diff -aruN old/src/veritysetup/veritysetup-generator.c new/src/veritysetup/veritysetup-generator.c
--- old/src/veritysetup/veritysetup-generator.c	2021-07-07 18:41:29.000000000 +0100
+++ new/src/veritysetup/veritysetup-generator.c	2021-11-19 17:19:28.000000000 +0000
@@ -100,7 +100,7 @@
 
         fprintf(f,
                 "[Unit]\n"
-                "Description=Integrity Protection Setup for %%I\n"
+                "Description=Verity Protection Setup for %%I\n"
                 "Documentation=man:systemd-veritysetup-generator(8) man:systemd-veritysetup@.service(8)\n"
                 "SourcePath=/proc/cmdline\n"
                 "DefaultDependencies=no\n"
diff -aruN old/test/meson.build new/test/meson.build
--- old/test/meson.build	2021-07-07 18:41:29.000000000 +0100
+++ new/test/meson.build	2021-11-19 17:19:28.000000000 +0000
@@ -34,6 +34,9 @@
         install_subdir('testsuite-52.units',
                        install_dir : testdata_dir)
 
+        install_data(kbd_model_map,
+                     install_dir : testdata_dir + '/test-keymap-util')
+
         testsuite08_dir = testdata_dir + '/testsuite-08.units'
         install_data('testsuite-08.units/-.mount',
                      install_dir : testsuite08_dir)
diff -aruN old/test/networkd-test.py new/test/networkd-test.py
--- old/test/networkd-test.py	2021-07-07 18:41:29.000000000 +0100
+++ new/test/networkd-test.py	2021-11-19 17:19:28.000000000 +0000
@@ -635,7 +635,7 @@
 [Network]
 DHCP=ipv4
 IPv6AcceptRA=False
-DNSSECNegativeTrustAnchors=megasearch.net
+DNSSECNegativeTrustAnchors=search.example.com
 '''.format(self.iface))
 
         # create second device/dnsmasq for a .company/.lab VPN interface
@@ -681,8 +681,8 @@
         self.assertIn(b'kettle.cantina.company: 10.241.4.4', out)
 
         # test general domains
-        out = subprocess.check_output(['resolvectl', 'query', 'megasearch.net'])
-        self.assertIn(b'megasearch.net: 192.168.42.1', out)
+        out = subprocess.check_output(['resolvectl', 'query', 'search.example.com'])
+        self.assertIn(b'search.example.com: 192.168.42.1', out)
 
         with open(self.dnsmasq_log) as f:
             general_log = f.read()
@@ -696,8 +696,8 @@
         self.assertNotIn('.company', general_log)
 
         # general domains should not be sent to the VPN DNS
-        self.assertRegex(general_log, 'query.*megasearch.net')
-        self.assertNotIn('megasearch.net', vpn_log)
+        self.assertRegex(general_log, 'query.*search.example.com')
+        self.assertNotIn('search.example.com', vpn_log)
 
     def test_resolved_etc_hosts(self):
         '''resolved queries to /etc/hosts'''
diff -aruN old/test/TEST-52-HONORFIRSTSHUTDOWN/test.sh new/test/TEST-52-HONORFIRSTSHUTDOWN/test.sh
--- old/test/TEST-52-HONORFIRSTSHUTDOWN/test.sh	2021-07-07 18:41:29.000000000 +0100
+++ new/test/TEST-52-HONORFIRSTSHUTDOWN/test.sh	2021-11-19 17:19:28.000000000 +0000
@@ -11,7 +11,7 @@
 # Using timeout because if the test fails it can loop.
 # The reason is because the poweroff executed by end.service
 # could turn into a reboot if the test fails.
-NSPAWN_TIMEOUT=20
+NSPAWN_TIMEOUT=60
 
 # Remove this file if it exists. This is used along with
 # the make target "finish". Since concrete confirmation is
diff -aruN old/test/test-execute/exec-systemcallfilter-failing3.service new/test/test-execute/exec-systemcallfilter-failing3.service
--- old/test/test-execute/exec-systemcallfilter-failing3.service	1970-01-01 01:00:00.000000000 +0100
+++ new/test/test-execute/exec-systemcallfilter-failing3.service	2021-11-19 17:19:28.000000000 +0000
@@ -0,0 +1,9 @@
+[Unit]
+Description=Test for SystemCallFilter
+
+[Service]
+ExecStart=/bin/sh -c '/bin/echo "This should not be seen"'
+Type=oneshot
+LimitCORE=0
+SystemCallArchitectures=native
+SystemCallFilter=~write open execve fexecve execveat exit_group close mmap munmap fstat DONOTEXIST
diff -aruN old/test/test-execute/exec-systemcallfilter-not-failing3.service new/test/test-execute/exec-systemcallfilter-not-failing3.service
--- old/test/test-execute/exec-systemcallfilter-not-failing3.service	1970-01-01 01:00:00.000000000 +0100
+++ new/test/test-execute/exec-systemcallfilter-not-failing3.service	2021-11-19 17:19:28.000000000 +0000
@@ -0,0 +1,8 @@
+[Unit]
+Description=Test for SystemCallFilter
+
+[Service]
+ExecStart=/bin/sh -c 'echo "Foo bar"'
+Type=oneshot
+SystemCallArchitectures=native
+SystemCallFilter=
diff -aruN old/test/test-functions new/test/test-functions
--- old/test/test-functions	2021-07-07 18:41:29.000000000 +0100
+++ new/test/test-functions	2021-11-19 17:19:28.000000000 +0000
@@ -35,6 +35,7 @@
 # To force creating a new image from scratch (eg: to encrypt it), also define
 # TEST_FORCE_NEWIMAGE=1 in the test setup script.
 IMAGE_NAME=${IMAGE_NAME:-default}
+STRIP_BINARIES="${STRIP_BINARIES:-yes}"
 TEST_REQUIRE_INSTALL_TESTS="${TEST_REQUIRE_INSTALL_TESTS:-1}"
 TEST_PARALLELIZE="${TEST_PARALLELIZE:-0}"
 LOOPDEV=
@@ -228,7 +229,7 @@
 
     # Borrowed from https://github.com/google/oss-fuzz/blob/cd9acd02f9d3f6e80011cc1e9549be526ce5f270/infra/base-images/base-runner/bad_build_check#L182
     local _asan_calls
-    _asan_calls="$(objdump -dC "$SYSTEMD_JOURNALD" | grep -E "callq?\s+[0-9a-f]+\s+<__asan" -c)"
+    _asan_calls="$(objdump -dC "$SYSTEMD_JOURNALD" | grep -E "(callq?|brasl?)\s+[^ <]+\s+<__asan" -c)"
     if ((_asan_calls < 1000)); then
         return 1
     else
@@ -347,12 +348,14 @@
             [ "$ARCH" ] || ARCH=$(uname -m)
             case $ARCH in
                 ppc64*)
-                KERNEL_BIN="/boot/vmlinux-$KERNEL_VER"
-                CONSOLE=hvc0
-                ;;
+                    # Ubuntu ppc64* calls the kernel binary as vmlinux-*, RHEL/CentOS
+                    # uses the "standard" vmlinuz- prefix
+                    [[ -e "/boot/vmlinux-$KERNEL_VER" ]] && KERNEL_BIN="/boot/vmlinux-$KERNEL_VER" || KERNEL_BIN="/boot/vmlinuz-$KERNEL_VER"
+                    CONSOLE=hvc0
+                    ;;
                 *)
-                KERNEL_BIN="/boot/vmlinuz-$KERNEL_VER"
-                ;;
+                    KERNEL_BIN="/boot/vmlinuz-$KERNEL_VER"
+                    ;;
             esac
         fi
     fi
diff -aruN old/test/test-keymap-util/kbd-model-map new/test/test-keymap-util/kbd-model-map
--- old/test/test-keymap-util/kbd-model-map	1970-01-01 01:00:00.000000000 +0100
+++ new/test/test-keymap-util/kbd-model-map	2021-11-19 17:19:28.000000000 +0000
@@ -0,0 +1,71 @@
+# Originally generated from system-config-keyboard's model list.
+# consolelayout		xlayout	xmodel		xvariant	xoptions
+sg			ch	pc105		de_nodeadkeys	terminate:ctrl_alt_bksp
+nl			nl	pc105		-		terminate:ctrl_alt_bksp
+mk-utf			mk,us	pc105		-		terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+trq			tr	pc105		-		terminate:ctrl_alt_bksp
+uk			gb	pc105		-		terminate:ctrl_alt_bksp
+is-latin1		is	pc105		-		terminate:ctrl_alt_bksp
+de			de	pc105		-		terminate:ctrl_alt_bksp
+la-latin1		latam	pc105		-		terminate:ctrl_alt_bksp
+us			us	pc105+inet	-		terminate:ctrl_alt_bksp
+ko			kr	pc105		-		terminate:ctrl_alt_bksp
+ro-std			ro	pc105		std		terminate:ctrl_alt_bksp
+de-latin1		de	pc105		-		terminate:ctrl_alt_bksp
+slovene			si	pc105		-		terminate:ctrl_alt_bksp
+hu101			hu	pc105		qwerty		terminate:ctrl_alt_bksp
+jp106			jp	jp106		-		terminate:ctrl_alt_bksp
+croat			hr	pc105		-		terminate:ctrl_alt_bksp
+it2			it	pc105		-		terminate:ctrl_alt_bksp
+hu			hu	pc105		-		terminate:ctrl_alt_bksp
+sr-latin		rs	pc105		latin		terminate:ctrl_alt_bksp
+fi			fi	pc105		-		terminate:ctrl_alt_bksp
+fr_CH			ch	pc105		fr		terminate:ctrl_alt_bksp
+dk-latin1		dk	pc105		-		terminate:ctrl_alt_bksp
+fr			fr	pc105		-		terminate:ctrl_alt_bksp
+it			it	pc105		-		terminate:ctrl_alt_bksp
+ua-utf			ua,us	pc105		-		terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+fr-latin1		fr	pc105		-		terminate:ctrl_alt_bksp
+sg-latin1		ch	pc105		de_nodeadkeys	terminate:ctrl_alt_bksp
+be-latin1		be	pc105		-		terminate:ctrl_alt_bksp
+dk			dk	pc105		-		terminate:ctrl_alt_bksp
+fr-pc			fr	pc105		-		terminate:ctrl_alt_bksp
+bg_pho-utf8		bg,us	pc105		,phonetic	terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+it-ibm			it	pc105		-		terminate:ctrl_alt_bksp
+cz-us-qwertz		cz,us	pc105		-		terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+br-abnt2		br	abnt2		-		terminate:ctrl_alt_bksp
+ro			ro	pc105		-		terminate:ctrl_alt_bksp
+us-acentos		us	pc105		intl		terminate:ctrl_alt_bksp
+pt-latin1		pt	pc105		-		terminate:ctrl_alt_bksp
+ro-std-cedilla		ro	pc105		std_cedilla	terminate:ctrl_alt_bksp
+tj_alt-UTF8		tj	pc105		-		terminate:ctrl_alt_bksp
+de-latin1-nodeadkeys	de	pc105		nodeadkeys	terminate:ctrl_alt_bksp
+no			no	pc105		-		terminate:ctrl_alt_bksp
+bg_bds-utf8		bg,us	pc105		-		terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+dvorak			us	pc105		dvorak		terminate:ctrl_alt_bksp
+dvorak			us	pc105		dvorak-alt-intl	terminate:ctrl_alt_bksp
+ru			ru,us	pc105		-		terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+cz-lat2			cz	pc105		qwerty		terminate:ctrl_alt_bksp
+pl2			pl	pc105		-		terminate:ctrl_alt_bksp
+es			es	pc105		-		terminate:ctrl_alt_bksp
+ro-cedilla		ro	pc105		cedilla		terminate:ctrl_alt_bksp
+ie			ie	pc105		-		terminate:ctrl_alt_bksp
+et			ee	pc105		-		terminate:ctrl_alt_bksp
+sk-qwerty		sk	pc105		-		terminate:ctrl_alt_bksp,qwerty
+sk-qwertz		sk	pc105		-		terminate:ctrl_alt_bksp
+fr-latin9		fr	pc105		latin9		terminate:ctrl_alt_bksp
+fr_CH-latin1		ch	pc105		fr		terminate:ctrl_alt_bksp
+cf			ca	pc105		-		terminate:ctrl_alt_bksp
+sv-latin1		se	pc105		-		terminate:ctrl_alt_bksp
+sr-cy			rs	pc105		-		terminate:ctrl_alt_bksp
+gr			gr,us	pc105		-		terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+by			by,us	pc105		-		terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+il			il	pc105		-		terminate:ctrl_alt_bksp
+kazakh			kz,us	pc105		-		terminate:ctrl_alt_bksp,grp:shifts_toggle,grp_led:scroll
+lt.baltic		lt	pc105		-		terminate:ctrl_alt_bksp
+lt.l4			lt	pc105		-		terminate:ctrl_alt_bksp
+lt			lt	pc105		-		terminate:ctrl_alt_bksp
+khmer			kh,us	pc105		-		terminate:ctrl_alt_bksp
+es-dvorak		es	microsoftpro	dvorak		terminate:ctrl_alt_bksp
+lv			lv	pc105		apostrophe	terminate:ctrl_alt_bksp
+lv-tilde		lv	pc105		tilde		terminate:ctrl_alt_bksp
diff -aruN old/test/test-network/conf/25-nexthop.network new/test/test-network/conf/25-nexthop.network
--- old/test/test-network/conf/25-nexthop.network	2021-07-07 18:41:29.000000000 +0100
+++ new/test/test-network/conf/25-nexthop.network	2021-11-19 17:19:28.000000000 +0000
@@ -39,6 +39,10 @@
 Blackhole=yes
 
 [NextHop]
+Id=8
+Gateway=fe80::222:4dff:ff:ff:ff:ff
+
+[NextHop]
 Gateway=192.168.5.2
 
 [NextHop]
diff -aruN old/test/test-network/conf/25-route-static.network new/test/test-network/conf/25-route-static.network
--- old/test/test-network/conf/25-route-static.network	2021-07-07 18:41:29.000000000 +0100
+++ new/test/test-network/conf/25-route-static.network	2021-11-19 17:19:28.000000000 +0000
@@ -18,6 +18,10 @@
 Gateway=2001:1234:5:8fff:ff:ff:ff:ff
 
 [Route]
+Destination=2001:1234:5:afff:ff:ff:ff:ff/128
+Gateway=fe80::222:4dff:ff:ff:ff:ff
+
+[Route]
 Destination=149.10.124.64
 Scope=link
 
diff -aruN old/test/test-network/conf/networkd-manage-foreign-routes-no.conf new/test/test-network/conf/networkd-manage-foreign-routes-no.conf
--- old/test/test-network/conf/networkd-manage-foreign-routes-no.conf	1970-01-01 01:00:00.000000000 +0100
+++ new/test/test-network/conf/networkd-manage-foreign-routes-no.conf	2021-11-19 17:19:28.000000000 +0000
@@ -0,0 +1,2 @@
+[Network]
+ManageForeignRoutes=no
diff -aruN old/test/test-network/systemd-networkd-tests.py new/test/test-network/systemd-networkd-tests.py
--- old/test/test-network/systemd-networkd-tests.py	2021-07-07 18:41:29.000000000 +0100
+++ new/test/test-network/systemd-networkd-tests.py	2021-11-19 17:19:28.000000000 +0000
@@ -16,6 +16,7 @@
 
 network_unit_file_path='/run/systemd/network'
 networkd_runtime_directory='/run/systemd/netif'
+networkd_conf_dropin_path='/run/systemd/networkd.conf.d'
 networkd_ci_path='/run/networkd-ci'
 network_sysctl_ipv6_path='/proc/sys/net/ipv6/conf'
 network_sysctl_ipv4_path='/proc/sys/net/ipv4/conf'
@@ -263,6 +264,7 @@
     global running_units
 
     os.makedirs(network_unit_file_path, exist_ok=True)
+    os.makedirs(networkd_conf_dropin_path, exist_ok=True)
     os.makedirs(networkd_ci_path, exist_ok=True)
 
     shutil.rmtree(networkd_ci_path)
@@ -460,6 +462,17 @@
             if (os.path.exists(os.path.join(network_unit_file_path, unit + '.d'))):
                 shutil.rmtree(os.path.join(network_unit_file_path, unit + '.d'))
 
+def copy_networkd_conf_dropin(*dropins):
+    """Copy networkd.conf dropin files into the testbed."""
+    for dropin in dropins:
+        shutil.copy(os.path.join(networkd_ci_path, dropin), networkd_conf_dropin_path)
+
+def remove_networkd_conf_dropin(dropins):
+    """Remove previously copied networkd.conf dropin files from the testbed."""
+    for dropin in dropins:
+        if (os.path.exists(os.path.join(networkd_conf_dropin_path, dropin))):
+            os.remove(os.path.join(networkd_conf_dropin_path, dropin))
+
 def start_dnsmasq(additional_options='', ipv4_range='192.168.5.10,192.168.5.200', ipv6_range='2600::10,2600::20', lease_time='1h'):
     dnsmasq_command = f'dnsmasq -8 /var/run/networkd-ci/test-dnsmasq-log-file --log-queries=extra --log-dhcp --pid-file=/var/run/networkd-ci/test-test-dnsmasq.pid --conf-file=/dev/null --interface=veth-peer --enable-ra --dhcp-range={ipv6_range},{lease_time} --dhcp-range={ipv4_range},{lease_time} -R --dhcp-leasefile=/var/run/networkd-ci/lease --dhcp-option=26,1492 --dhcp-option=option:router,192.168.5.1 --port=0 ' + additional_options
     check_output(dnsmasq_command)
@@ -1858,6 +1871,10 @@
         'routing-policy-rule-reconfigure2.network',
     ]
 
+    networkd_conf_dropins = [
+        'networkd-manage-foreign-routes-no.conf',
+    ]
+
     routing_policy_rule_tables = ['7', '8', '9', '10', '1011']
     routes = [['blackhole', '202.54.1.2'], ['unreachable', '202.54.1.3'], ['prohibit', '202.54.1.4']]
 
@@ -1875,6 +1892,7 @@
         remove_routes(self.routes)
         remove_links(self.links)
         remove_unit_from_networkd_path(self.units)
+        remove_networkd_conf_dropin(self.networkd_conf_dropins)
         stop_networkd(show_logs=True)
         call('ip netns del ns99', stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
 
@@ -1990,12 +2008,10 @@
             print('### ip route show table 42 dev dummy98')
             print(output)
             self.assertRegex(output, 'local 10.20.22.1 proto kernel scope host src 10.20.22.1')
-            self.assertRegex(output, 'broadcast 10.20.33.0 proto kernel scope link src 10.20.33.1')
             self.assertRegex(output, '10.20.33.0/24 proto kernel scope link src 10.20.33.1')
             self.assertRegex(output, 'local 10.20.33.1 proto kernel scope host src 10.20.33.1')
             self.assertRegex(output, 'broadcast 10.20.33.255 proto kernel scope link src 10.20.33.1')
             self.assertRegex(output, 'local 10.20.44.1 proto kernel scope host src 10.20.44.1')
-            self.assertRegex(output, 'broadcast 10.20.55.0 proto kernel scope link src 10.20.55.1')
             self.assertRegex(output, 'local 10.20.55.1 proto kernel scope host src 10.20.55.1')
             self.assertRegex(output, 'broadcast 10.20.55.255 proto kernel scope link src 10.20.55.1')
             output = check_output('ip -6 route show table 42 dev dummy98')
@@ -2022,11 +2038,9 @@
             print('### ip route show table local dev test1')
             print(output)
             self.assertRegex(output, 'local 10.21.22.1 proto kernel scope host src 10.21.22.1')
-            self.assertRegex(output, 'broadcast 10.21.33.0 proto kernel scope link src 10.21.33.1')
             self.assertRegex(output, 'local 10.21.33.1 proto kernel scope host src 10.21.33.1')
             self.assertRegex(output, 'broadcast 10.21.33.255 proto kernel scope link src 10.21.33.1')
             self.assertRegex(output, 'local 10.21.44.1 proto kernel scope host src 10.21.44.1')
-            self.assertRegex(output, 'broadcast 10.21.55.0 proto kernel scope link src 10.21.55.1')
             self.assertRegex(output, 'local 10.21.55.1 proto kernel scope host src 10.21.55.1')
             self.assertRegex(output, 'broadcast 10.21.55.255 proto kernel scope link src 10.21.55.1')
             output = check_output('ip -6 route show dev test1')
@@ -2253,7 +2267,10 @@
         self.assertRegex(output, 'lookup 7')
         self.assertRegex(output, 'uidrange 100-200')
 
-    def test_route_static(self):
+    def _test_route_static(self, manage_foreign_routes):
+        if not manage_foreign_routes:
+            copy_networkd_conf_dropin('networkd-manage-foreign-routes-no.conf')
+
         copy_unit_to_networkd_unit_path('25-route-static.network', '12-dummy.netdev')
         start_networkd()
         self.wait_online(['dummy98:routable'])
@@ -2266,6 +2283,7 @@
         print(output)
         self.assertIn('2001:1234:5:8fff:ff:ff:ff:ff proto static', output)
         self.assertIn('2001:1234:5:8f63::1 proto kernel', output)
+        self.assertIn('2001:1234:5:afff:ff:ff:ff:ff via fe80:0:222:4dff:ff:ff:ff:ff proto static', output)
 
         print('### ip -6 route show default')
         output = check_output('ip -6 route show default')
@@ -2459,6 +2477,13 @@
         print(output)
         self.assertEqual(output, '')
 
+        self.tearDown()
+
+    def test_route_static(self):
+        for manage_foreign_routes in [True, False]:
+            with self.subTest(manage_foreign_routes=manage_foreign_routes):
+                self._test_route_static(manage_foreign_routes)
+
     @expectedFailureIfRTA_VIAIsNotSupported()
     def test_route_via_ipv6(self):
         copy_unit_to_networkd_unit_path('25-route-via-ipv6.network', '12-dummy.netdev')
@@ -2907,6 +2932,7 @@
             self.assertIn('id 3 dev veth99', output)
             self.assertIn('id 4 dev veth99', output)
             self.assertRegex(output, 'id 5 via 192.168.10.1 dev veth99 .*onlink')
+            self.assertIn('id 8 via fe80:0:222:4dff:ff:ff:ff:ff dev veth99', output)
             self.assertRegex(output, r'id [0-9]* via 192.168.5.2 dev veth99')
 
             output = check_output('ip nexthop list dev dummy98')
@@ -3614,7 +3640,7 @@
 
         output = check_output('ip rule list table 100')
         print(output)
-        self.assertIn('0:	from all to 8.8.8.8 lookup 100', output)
+        self.assertIn('from all to 8.8.8.8 lookup 100', output)
 
 class NetworkdLLDPTests(unittest.TestCase, Utilities):
     links = ['veth99']
diff -aruN old/test/units/testsuite-23.sh new/test/units/testsuite-23.sh
--- old/test/units/testsuite-23.sh	2021-07-07 18:41:29.000000000 +0100
+++ new/test/units/testsuite-23.sh	2021-11-19 17:19:28.000000000 +0000
@@ -27,6 +27,37 @@
 systemctl restart seven.service
 systemctl stop seven.service
 
+# For issue #20933
+
+# Should work normally
+busctl call \
+  org.freedesktop.systemd1 /org/freedesktop/systemd1 \
+  org.freedesktop.systemd1.Manager StartTransientUnit \
+  "ssa(sv)a(sa(sv))" test-20933-ok.service replace 1 \
+    ExecStart "a(sasb)" 1 \
+      /usr/bin/sleep 2 /usr/bin/sleep 1 true \
+  0
+
+# DBus call should fail but not crash systemd
+busctl call \
+  org.freedesktop.systemd1 /org/freedesktop/systemd1 \
+  org.freedesktop.systemd1.Manager StartTransientUnit \
+  "ssa(sv)a(sa(sv))" test-20933-bad.service replace 1 \
+    ExecStart "a(sasb)" 1 \
+      /usr/bin/sleep 0 true \
+  0 && { echo 'unexpected success'; exit 1; }
+
+# Same but with the empty argv in the middle
+busctl call \
+  org.freedesktop.systemd1 /org/freedesktop/systemd1 \
+  org.freedesktop.systemd1.Manager StartTransientUnit \
+  "ssa(sv)a(sa(sv))" test-20933-bad-middle.service replace 1 \
+    ExecStart "a(sasb)" 3 \
+      /usr/bin/sleep 2 /usr/bin/sleep 1 true \
+      /usr/bin/sleep 0                  true \
+      /usr/bin/sleep 2 /usr/bin/sleep 1 true \
+  0 && { echo 'unexpected success'; exit 1; }
+
 systemd-analyze log-level info
 
 echo OK >/testok
diff -aruN old/test/units/testsuite-60.sh new/test/units/testsuite-60.sh
--- old/test/units/testsuite-60.sh	2021-07-07 18:41:29.000000000 +0100
+++ new/test/units/testsuite-60.sh	2021-11-19 17:19:28.000000000 +0000
@@ -26,6 +26,7 @@
 
 # figure out if we have entered the rate limit state
 
+entered_rl=0
 exited_rl=0
 timeout="$(date -ud "2 minutes" +%s)"
 while [[ $(date -u +%s) -le ${timeout} ]]; do
diff -aruN old/units/remote-veritysetup.target new/units/remote-veritysetup.target
--- old/units/remote-veritysetup.target	2021-07-07 18:41:29.000000000 +0100
+++ new/units/remote-veritysetup.target	2021-11-19 17:19:28.000000000 +0000
@@ -8,7 +8,7 @@
 #  (at your option) any later version.
 
 [Unit]
-Description=Remote Verity Integrity Protected Volumes
+Description=Remote Verity Protected Volumes
 Documentation=man:systemd.special(7)
 After=remote-fs-pre.target veritysetup-pre.target
 DefaultDependencies=no
diff -aruN old/units/systemd-homed.service.in new/units/systemd-homed.service.in
--- old/units/systemd-homed.service.in	2021-07-07 18:41:29.000000000 +0100
+++ new/units/systemd-homed.service.in	2021-11-19 17:19:28.000000000 +0000
@@ -16,18 +16,18 @@
 
 [Service]
 BusName=org.freedesktop.home1
-CapabilityBoundingSet=CAP_SYS_ADMIN CAP_CHOWN CAP_DAC_OVERRIDE CAP_FOWNER CAP_FSETID CAP_SETGID CAP_SETUID CAP_SYS_RESOURCE
+CapabilityBoundingSet=CAP_SYS_ADMIN CAP_CHOWN CAP_DAC_OVERRIDE CAP_FOWNER CAP_FSETID CAP_SETGID CAP_SETUID CAP_SYS_RESOURCE CAP_SETPCAP CAP_DAC_READ_SEARCH
 DeviceAllow=/dev/loop-control rw
 DeviceAllow=/dev/mapper/control rw
 DeviceAllow=block-* rw
+DeviceAllow=char-hidraw rw
 ExecStart={{ROOTLIBEXECDIR}}/systemd-homed
-IPAddressDeny=any
 KillMode=mixed
 LimitNOFILE={{HIGH_RLIMIT_NOFILE}}
 LockPersonality=yes
 MemoryDenyWriteExecute=yes
 NoNewPrivileges=yes
-RestrictAddressFamilies=AF_UNIX AF_NETLINK AF_ALG
+RestrictAddressFamilies=AF_UNIX AF_NETLINK AF_ALG AF_INET AF_INET6
 RestrictNamespaces=mnt
 RestrictRealtime=yes
 StateDirectory=systemd/home
diff -aruN old/units/systemd-oomd.service.in new/units/systemd-oomd.service.in
--- old/units/systemd-oomd.service.in	2021-07-07 18:41:29.000000000 +0100
+++ new/units/systemd-oomd.service.in	2021-11-19 17:19:28.000000000 +0000
@@ -14,6 +14,7 @@
 Before=multi-user.target shutdown.target
 Conflicts=shutdown.target
 ConditionControlGroupController=v2
+ConditionControlGroupController=memory
 ConditionPathExists=/proc/pressure/cpu
 ConditionPathExists=/proc/pressure/io
 ConditionPathExists=/proc/pressure/memory
diff -aruN old/units/veritysetup-pre.target new/units/veritysetup-pre.target
--- old/units/veritysetup-pre.target	2021-07-07 18:41:29.000000000 +0100
+++ new/units/veritysetup-pre.target	2021-11-19 17:19:28.000000000 +0000
@@ -8,7 +8,7 @@
 #  (at your option) any later version.
 
 [Unit]
-Description=Local Verity Integrity Protected Volumes (Pre)
+Description=Local Verity Protected Volumes (Pre)
 Documentation=man:systemd.special(7)
 RefuseManualStart=yes
 Before=veritysetup.target
diff -aruN old/units/veritysetup.target new/units/veritysetup.target
--- old/units/veritysetup.target	2021-07-07 18:41:29.000000000 +0100
+++ new/units/veritysetup.target	2021-11-19 17:19:28.000000000 +0000
@@ -8,5 +8,5 @@
 #  (at your option) any later version.
 
 [Unit]
-Description=Local Verity Integrity Protected Volumes
+Description=Local Verity Protected Volumes
 Documentation=man:systemd.special(7)
